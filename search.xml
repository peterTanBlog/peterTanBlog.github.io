<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Markdown 语法</title>
      <link href="/2022/10/08/Markdown-%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/10/08/Markdown-%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="MarkDown"><a href="#MarkDown" class="headerlink" title="MarkDown"></a>MarkDown</h1><p>一、Markdown简介<br>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p><p>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</p><p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p><p>Markdown 编写的文档后缀为 .md, .markdown。</p><p>Markdown 能被使用来撰写电子书，如：Gitbook。</p><p>当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。</p><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p><p>使用#号标记标题语法格式：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><h1 id="三、Markdown段落"><a href="#三、Markdown段落" class="headerlink" title="三、Markdown段落"></a>三、Markdown段落</h1><p>Markdown的段落没有特殊的格式，直接编写文字就好，段落的换行号是使用两个以上的空格加回车。</p><ul><li>3.1 字体</li></ul><p>Markdown 可以使用以下几种字体：</p><p>用1个星号<em>或底线_表示斜体<br>用2个星号</em>或底线_表示粗体<br>用3个星号*或底线_表示粗斜体<br>语法格式：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">*斜体文字*</span></span><br><span class="line"><span class="emphasis">_斜体文字_</span></span><br><span class="line"><span class="strong">**粗体文字**</span></span><br><span class="line"><span class="emphasis">__粗体文字__</span></span><br><span class="line"><span class="strong">***粗斜体文字**</span>*</span><br><span class="line"><span class="emphasis">___粗斜体文字__</span>_</span><br></pre></td></tr></table></figure><p>显示效果</p><p><em>斜体文字</em></p><p><em>斜体文字</em></p><p><strong>粗体文字</strong></p><p><strong>粗体文字</strong></p><p><em><strong>粗斜体文字</strong></em></p><p><em><strong>粗斜体文字</strong></em></p><h1 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h1><p>也可以用’’’包裹一段代码</p><h1 id="Markdown链接"><a href="#Markdown链接" class="headerlink" title="Markdown链接"></a>Markdown链接</h1><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name">链接名称</span>](<span class="name">链接地址</span>)</span><br></pre></td></tr></table></figure><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!<span class="selector-attr">[alt 属性文本]</span>(图片地址)</span><br></pre></td></tr></table></figure><p>更多请参考<a href="https://zhuanlan.zhihu.com/p/108984311">markdown语法</a></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java 面试题目</title>
      <link href="/2022/10/08/Java-%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
      <url>/2022/10/08/Java-%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h1><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ul><li>封装：<br>封装的意义，在于明确标识出允许外部使用的所有成员函数和数据项，内部细节对外部调用透明，外部调用无需修改或者关心内部实现</li><li>继承：<br>继承基类的方法，并做出自己的改变和&#x2F;或扩展，子类共性的方法或者属性直接使用父类的，而不需要自己再定义，只需扩展自己个性化的</li><li>多态：<br>基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同</li><li>意义<br>面向对象开发模式更有利于人们开拓思维，在具体的开发过程中便于程序的划分，方便程序员分工合作，提高开发效率。面向对象程序设计有以下优点。<ul><li>可重用性：代码重复使用，减少代码量，提高开发效率。</li><li>可扩展性：指新的功能可以很容易地加入到系统中来，便于软件的修改。</li><li>可管理性：能够将功能与数据结合，方便管理。</li></ul></li></ul><h2 id="JDK、JRE、JVM之间的区别"><a href="#JDK、JRE、JVM之间的区别" class="headerlink" title="JDK、JRE、JVM之间的区别"></a>JDK、JRE、JVM之间的区别</h2><ul><li>JDK：Java Develpment Kit java 开发工具</li><li>JRE：Java Runtime Environment  java运行时环境</li><li>JVM：java Virtual Machine java 虚拟机</li></ul><h2 id="x3D-x3D-和equals方法之前的区别"><a href="#x3D-x3D-和equals方法之前的区别" class="headerlink" title="&#x3D;&#x3D;和equals方法之前的区别"></a>&#x3D;&#x3D;和equals方法之前的区别</h2><ul><li>&#x3D;&#x3D;：对比的是栈中的值，基本数据类型是变量值，引用类型是堆中内存对象的地址</li><li>equals：object中默认也是采用&#x3D;&#x3D;比较，通常会重写</li></ul><h2 id="hashCode-与equals-之间的关系"><a href="#hashCode-与equals-之间的关系" class="headerlink" title="hashCode()与equals()之间的关系"></a>hashCode()与equals()之间的关系</h2><ul><li>HashCode介绍：hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，Java中的任何类都包含有hashCode() 函数。</li><li>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</li><li>如果两个对象相等，则hashcode一定也是相同的<br>两个对象相等,对两个对象分别调用equals方法都返回true<br>两个对象有相同的hashcode值，它们也不一定是相等的<br>因此，equals方法被覆盖过，则hashCode方法也必须被覆盖</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ul><h2 id="final关键字的作用是什么？"><a href="#final关键字的作用是什么？" class="headerlink" title="final关键字的作用是什么？"></a>final关键字的作用是什么？</h2><ul><li>修饰类：表示类不可被继承</li><li>修饰方法：表示方法不可被子类覆盖，但是可以重载</li><li>修饰变量：表示变量一旦被赋值就不可以更改它的值。</li><li>修饰成员变量：<ul><li>如果final修饰的是类变量，只能在静态初始化块中指定初始值或者声明该类变量时指定初始值。</li><li>如果final修饰的是成员变量，可以在非静态初始化块、声明该变量或者构造器中执行初始值。</li></ul></li><li>修饰局部变量：系统不会为局部变量进行初始化，局部变量必须由程序员显示初始化。因此使用final修饰局部变量时，即可以在定义时指定默认值（后面的代码不能对变量再赋值），也可以不指定默认值，而在后面的代码中对final变量赋初值（仅一次）</li><li>修饰基本类型数据和引用类型数据：<ul><li>如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；</li><li>如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。但是引用的值是可变的。</li></ul></li></ul><h2 id="String、StringBuffer、StringBuilder的区别"><a href="#String、StringBuffer、StringBuilder的区别" class="headerlink" title="String、StringBuffer、StringBuilder的区别"></a>String、StringBuffer、StringBuilder的区别</h2><ul><li>String是不可变的，如果尝试去修改，会新生成一个字符串对象，StringBuffer和StringBuilder是可变的</li><li>StringBuffer是线程安全的，StringBuilder是线程不安全的，所以在单线程环境下StringBuilder效率会更高</li></ul><h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><ul><li>重载：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。</li><li>重写：发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为private则子类就不能重写该方法。</li></ul><h2 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h2><ul><li>抽象类可以存在普通成员函数，而接口中只能存在public abstract 方法。</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的。</li><li>抽象类只能继承一个，接口可以实现多个。</li></ul><h2 id="List和Set的区别"><a href="#List和Set的区别" class="headerlink" title="List和Set的区别"></a>List和Set的区别</h2><ul><li>List：有序，按对象进入的顺序保存对象，可重复，允许多个Null元素对象，可以使用Iterator取出所有元素，在逐一遍历，还可以使用get(int index)获取指定下标的元素</li><li>Set：无序，不可重复，最多允许有一个Null元素对象，取元素时只能用Iterator接口取得所有元素，在逐一遍历各个元素</li></ul><h2 id="ArrayList和LinkedList区别"><a href="#ArrayList和LinkedList区别" class="headerlink" title="ArrayList和LinkedList区别"></a>ArrayList和LinkedList区别</h2><ul><li>首先，他们的底层数据结构不同，ArrayList底层是基于数组实现的，LinkedList底层是基于链表实现的</li><li>由于底层数据结构不同，他们所适用的场景也不同，ArrayList更适合随机查找，LinkedList更适合删除和添加，查询、添加、删除的时间复杂度不同</li><li>另外ArrayList和LinkedList都实现了List接口，但是LinkedList还额外实现了Deque接口，所以LinkedList还可以当做队列来使用</li></ul><h2 id="HashMap和HashTable有什么区别？其底层实现是什么？"><a href="#HashMap和HashTable有什么区别？其底层实现是什么？" class="headerlink" title="HashMap和HashTable有什么区别？其底层实现是什么？"></a>HashMap和HashTable有什么区别？其底层实现是什么？</h2><ul><li>区别 ：<ul><li>HashMap方法没有synchronized修饰，线程非安全，HashTable线程安全；</li><li>HashMap允许key和value为null，而HashTable不允许</li></ul></li><li>底层实现<ul><li>计算key的hash值，二次hash然后对数组长度取模，对应到数组下标</li><li>如果没有产生hash冲突(下标位置没有元素)，则直接创建Node存入数组</li><li>如果产生hash冲突，先进行equal比较，相同则取代该元素，不同，则判断链表高度插入链表，链表高度达到8，并且数组长度到64则转变为红黑树，长度低于6则将红黑树转回链表</li><li>key为null，存在下标0的位置</li></ul></li></ul><h2 id="谈谈ConcurrentHashMap的扩容机制"><a href="#谈谈ConcurrentHashMap的扩容机制" class="headerlink" title="谈谈ConcurrentHashMap的扩容机制"></a>谈谈ConcurrentHashMap的扩容机制</h2><ul><li>1.7版本<ol><li>1.7版本的ConcurrentHashMap是基于Segment分段实现的</li><li>每个Segment相对于一个小型的HashMap</li><li>每个Segment内部会进行扩容，和HashMap的扩容逻辑类似</li><li>先生成新的数组，然后转移元素到新数组中</li><li>扩容的判断也是每个Segment内部单独判断的，判断是否超过阈值</li></ol></li><li>1.8版本<ol><li>1.8版本的ConcurrentHashMap不再基于Segment实现</li><li>当某个线程进行put时，如果发现ConcurrentHashMap正在进行扩容那么该线程一起进行扩容</li><li>如果某个线程put时，发现没有正在进行扩容，则将key-value添加到ConcurrentHashMap中，然后判断是否超过阈值，超过了则进行扩容</li><li>ConcurrentHashMap是支持多个线程同时扩容的</li><li>扩容之前也先生成一个新的数组</li><li>在转移元素时，先将原数组分组，将每组分给不同的线程来进行元素的转移，每个线程负责一组或多组的元素转移工作</li></ol></li></ul><h2 id="Jdk1-7到Jdk1-8-HashMap-发生了什么变化-底层"><a href="#Jdk1-7到Jdk1-8-HashMap-发生了什么变化-底层" class="headerlink" title="Jdk1.7到Jdk1.8 HashMap 发生了什么变化(底层)?"></a>Jdk1.7到Jdk1.8 HashMap 发生了什么变化(底层)?</h2><ol><li>1.7中底层是数组+链表，1.8中底层是数组+链表+红黑树，加红黑树的目的是提高HashMap插入和查询整体效率</li><li>1.7中链表插入使用的是头插法，1.8中链表插入使用的是尾插法，因为1.8中插入key和value时需要判断链表元素个数，所以需要遍历链表统计链表元素个数，所以正好就直接使用尾插法</li><li>1.7中哈希算法比较复杂，存在各种右移与异或运算，1.8中进行了简化，因为复杂的哈希算法的目的就是提高散列性，来提供HashMap的整体效率，而1.8中新增了红黑树，所以可以适当的简化哈希算法，节省CPU资源</li></ol><h2 id="说一下HashMap的Put方法"><a href="#说一下HashMap的Put方法" class="headerlink" title="说一下HashMap的Put方法"></a>说一下HashMap的Put方法</h2><ol><li>根据Key通过哈希算法与与运算得出数组下标</li><li>如果数组下标位置元素为空，则将key和value封装为Entry对象（JDK1.7中是Entry对象，JDK1.8中是Node对象）并放入该位置</li><li>如果数组下标位置元素不为空，则要分情况讨论<ol><li>如果是JDK1.7，则先判断是否需要扩容，如果要扩容就进行扩容，如果不用扩容就生成Entry对象，并使用头插法添加到当前位置的链表中</li><li>如果是JDK1.8，则会先判断当前位置上的Node的类型，看是红黑树Node，还是链表Node<ol><li>如果是红黑树Node，则将key和value封装为一个红黑树节点并添加到红黑树中去，在这个过程中会判断红黑树中是否存在当前key，如果存在则更新value</li><li>如果此位置上的Node对象是链表节点，则将key和value封装为一个链表Node并通过尾插法插入到链表的最后位置去，因为是尾插法，所以需要遍历链表，在遍历链表的过程中会判断是否存在当前key，如果存在则更新value，当遍历完链表后，将新链表Node插入到链表中，插入到链表后，会看当前链表的节点个数，如果大于等于8，那么则会将该链表转成红黑树</li><li>将key和value封装为Node插入到链表或红黑树中后，再判断是否需要进行扩容，如果需要就扩容，如果不需要就结束PUT方法</li></ol></li></ol></li></ol><h2 id="泛型中extends和super的区别"><a href="#泛型中extends和super的区别" class="headerlink" title="泛型中extends和super的区别"></a>泛型中extends和super的区别</h2><ol><li>&lt;? extends T&gt;表示包括T在内的任何T的子类</li><li>&lt;? super T&gt;表示包括T在内的任何T的父类</li></ol><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><ol><li>深拷贝和浅拷贝就是指对象的拷贝，一个对象中存在两种类型的属性，一种是基本数据类型，一种是实例对象的引用。</li><li>浅拷贝是指，只会拷贝基本数据类型的值，以及实例对象的引用地址，并不会复制一份引用地址所指向的对象，也就是浅拷贝出来的对象，内部的类属性指向的是同一个对象</li><li>深拷贝是指，既会拷贝基本数据类型的值，也会针对实例对象的引用地址所指向的对象进行复制，深拷贝出来的对象，内部的属性指向的不是同一个对象</li></ol><h2 id="HashMap的扩容机制原理"><a href="#HashMap的扩容机制原理" class="headerlink" title="HashMap的扩容机制原理"></a>HashMap的扩容机制原理</h2><ul><li>1.7版本<ol><li>先生成新数组</li><li>遍历老数组中的每个位置上的链表上的每个元素</li><li>取每个元素的key，并基于新数组长度，计算出每个元素在新数组中的下标</li><li>将元素添加到新数组中去</li><li>所有元素转移完了之后，将新数组赋值给HashMap对象的table属性<br>1.8版本</li><li>先生成新数组</li><li>遍历老数组中的每个位置上的链表或红黑树</li><li>如果是链表，则直接将链表中的每个元素重新计算下标，并添加到新数组中去</li><li>如果是红黑树，则先遍历红黑树，先计算出红黑树中每个元素对应在新数组中的下标位置<ol><li>统计每个下标位置的元素个数</li><li>如果该位置下的元素个数超过了8，则生成一个新的红黑树，并将根节点的添加到新数组的对应位置</li><li>如果该位置下的元素个数没有超过8，那么则生成一个链表，并将链表的头节点添加到新数组的对应位置</li></ol></li><li>所有元素转移完了之后，将新数组赋值给HashMap对象的table属性</li></ol></li></ul><h2 id="CopyOnWriteArrayList的底层原理是怎样的"><a href="#CopyOnWriteArrayList的底层原理是怎样的" class="headerlink" title="CopyOnWriteArrayList的底层原理是怎样的"></a>CopyOnWriteArrayList的底层原理是怎样的</h2><ol><li>首先CopyOnWriteArrayList内部也是用过数组来实现的，在向CopyOnWriteArrayList添加元素时，会复制一个新的数组，写操作在新数组上进行，读操作在原数组上进行</li><li>并且，写操作会加锁，防止出现并发写入丢失数据的问题</li><li>写操作结束之后会把原数组指向新数组</li><li>CopyOnWriteArrayList允许在写操作时来读取数据，大大提高了读的性能，因此适合读多写少的应用场景，但是CopyOnWriteArrayList会比较占内存，同时可能读到的数据不是实时最新的数据，所以不适合实时性要求很高的场景</li></ol><h2 id="什么是字节码？采用字节码的好处是什么？"><a href="#什么是字节码？采用字节码的好处是什么？" class="headerlink" title="什么是字节码？采用字节码的好处是什么？"></a>什么是字节码？采用字节码的好处是什么？</h2><ul><li>Java中的编译器和解释器：Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做 字节码（即扩展名为 .class的文件），它不面向任何特定的处理器，只面向虚拟机。<br>每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。这也就是解释了Java的编译与解释并存的特点。</li><li>Java源代码—-&gt;编译器—-&gt;jvm可执行的Java字节码(即虚拟指令)—-&gt;jvm—-&gt;jvm中解释器—–&gt;机器可执行的二进制机器码—-&gt;程序运行。</li><li>采用字节码的好处：Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</li></ul><h2 id="Java中的异常体系是怎样的"><a href="#Java中的异常体系是怎样的" class="headerlink" title="Java中的异常体系是怎样的"></a>Java中的异常体系是怎样的</h2><ul><li>Java中的所有异常都来自顶级父类Throwable。</li><li>Throwable下有两个子类Exception和Error。</li><li>Error是程序无法处理的错误，一旦出现这个错误，则程序将被迫停止运行。</li><li>Exception不会导致程序停止，又分为两个部分RunTimeException运行时异常和CheckedException检查异常。</li><li>RunTimeException常常发生在程序运行过程中，会导致程序当前线程执行失败。CheckedException常常发生在程序编译过程中，会导致程序编译不通过。</li></ul><h2 id="Java中有哪些类加载器"><a href="#Java中有哪些类加载器" class="headerlink" title="Java中有哪些类加载器"></a>Java中有哪些类加载器</h2><ul><li>BootStrapClassLoader是ExtClassLoader的父类加载器，默认负责加载%JAVA_HOME%lib下的jar包和class文件。</li><li>ExtClassLoader是AppClassLoader的父类加载器，负责加载%JAVA_HOME%&#x2F;lib&#x2F;ext文件夹下的jar包和class类。</li><li>AppClassLoader是自定义类加载器的父类，负责加载classpath下的类文件。</li></ul><h2 id="说说类加载器双亲委派模型"><a href="#说说类加载器双亲委派模型" class="headerlink" title="说说类加载器双亲委派模型"></a>说说类加载器双亲委派模型</h2><ol><li>BootstrapClassLoader</li><li>ExtClassLoader</li><li>AppClassLoader</li></ol><ul><li>AppClassLoader的父加载器是ExtClassLoader，ExtClassLoader的父加载器是BootstrapClassLoader。</li><li>JVM在加载一个类时，会调用AppClassLoader的loadClass方法来加载这个类，不过在这个方法中，会先使用ExtClassLoader的loadClass方法来加载类，同样ExtClassLoader的loadClass方法中会先使用BootstrapClassLoader来加载类，如果BootstrapClassLoader加载到了就直接成功，如果BootstrapClassLoader没有加载到，那么ExtClassLoader就会自己尝试加载该类，如果没有加载到，那么则会由AppClassLoader来加载这个类。</li><li>所以，双亲委派指得是，JVM在加载类时，会委派给Ext和Bootstrap进行加载，如果没加载到才由自己进行加载。</li></ul><h2 id="GC如何判断对象可以被回收"><a href="#GC如何判断对象可以被回收" class="headerlink" title="GC如何判断对象可以被回收"></a>GC如何判断对象可以被回收</h2><ul><li>引用计数法：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收，</li><li><ul><li>可达性分析法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的，那么虚拟机就判断是可回收对象。</li></ul></li><li>GC Roots的对象有：<ul><li>虚拟机栈(栈帧中的本地变量表）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI(即一般说的Native方法)引用的对象</li></ul></li></ul><h2 id="JVM中哪些是线程共享区"><a href="#JVM中哪些是线程共享区" class="headerlink" title="JVM中哪些是线程共享区"></a>JVM中哪些是线程共享区</h2><ul><li>线程共享<ul><li>堆区</li><li>方法区</li></ul></li><li>线程独有<ul><li>栈</li><li>本地方法栈</li><li>程序计数器</li></ul></li></ul><h2 id="JVM参数有哪些？"><a href="#JVM参数有哪些？" class="headerlink" title="JVM参数有哪些？"></a>JVM参数有哪些？</h2><ul><li>JVM参数大致可以分为三类：<ol><li>标注指令： -开头，这些是所有的HotSpot都支持的参数。可以用java -help 打印出来。</li><li>非标准指令： -X开头，这些指令通常是跟特定的HotSpot版本对应的。可以用java -X 打印出来。</li><li>不稳定参数： -XX 开头，这一类参数是跟特定HotSpot版本对应的，并且变化非常大。详细的文档资料非常少。</li><li>在JDK1.8版本下，有几个常用的不稳定指令：<ol><li>java -XX:+PrintCommandLineFlags ： 查看当前命令的不稳定指令。</li><li>java -XX:+PrintFlagsInitial ： 查看所有不稳定指令的默认值。</li><li>java -XX:+PrintFlagsFinal： 查看所有不稳定指令最终生效的实际值。</li></ol></li></ol></li></ul><h2 id="JVM有哪些垃圾回收算法？"><a href="#JVM有哪些垃圾回收算法？" class="headerlink" title="JVM有哪些垃圾回收算法？"></a>JVM有哪些垃圾回收算法？</h2><ol><li>MarkSweep 标记清除算法：这个算法分为两个阶段，标记阶段：把垃圾内存标记出来，清除阶段：直接将垃圾内存回收。这种算法是比较简单的，但是有个很严重的问题，就是会产生大量的内存碎片。</li><li>Copying 拷贝算法：为了解决标记清除算法的内存碎片问题，就产生了拷贝算法。拷贝算法将内存分为大小相等的两半，每次只使用其中一半。垃圾回收时，将当前这一块的存活对象全部拷贝到另一半，然后当前这一半内存就可以直接清除。这种算法没有内存碎片，但是他的问题就在于浪费空间。而且，他的效率跟存货对象的个数有关。</li><li>MarkCompack 标记压缩算法：为了解决拷贝算法的缺陷，就提出了标记压缩算法。这种算法在标记阶段跟标记清除算法是一样的，但是在完成标记之后，不是直接清理垃圾内存，而是将存活对象往一端移动，然后将端边界以外的所有内存直接清除。</li></ol><h2 id="JVM有哪些垃圾回收器？"><a href="#JVM有哪些垃圾回收器？" class="headerlink" title="JVM有哪些垃圾回收器？"></a>JVM有哪些垃圾回收器？</h2><ul><li>新生代收集器：<ul><li>Serial</li><li>ParNew</li><li>Parallel Scavenge</li></ul></li><li>老年代收集器：<ul><li>CMS</li><li>Serial Old</li><li>Parallel Old</li></ul></li><li>整堆收集器：<ul><li>G1</li></ul></li></ul><h2 id="垃圾回收分为哪些阶段"><a href="#垃圾回收分为哪些阶段" class="headerlink" title="垃圾回收分为哪些阶段"></a>垃圾回收分为哪些阶段</h2><ul><li>第一：初始标记 标记出GCRoot直接引用的对象。STW</li><li>第二：标记Region，通过RSet标记出上一个阶段标记的Region引用到的Old区Region。</li><li>第三：并发标记阶段：跟CMS的步骤是差不多的。只是遍历的范围不再是整个Old区，而只需要遍历第二步标记出来的Region。</li><li>第四：重新标记： 跟CMS中的重新标记过程是差不多的。</li><li>第五：垃圾清理：与CMS不同的是，G1可以采用拷贝算法，直接将整个Region中的对象拷贝到另一个Region。而这个阶段，G1只选择垃圾较多的Region来清理，并不是完全清理。</li></ul><h2 id="什么是STW？"><a href="#什么是STW？" class="headerlink" title="什么是STW？"></a>什么是STW？</h2><ul><li>STW: Stop-The-World，是在垃圾回收算法执行过程当中，需要将JVM内存冻结的一种状态。在STW状态下，JAVA的所有线程都是停止执行的-GC线程除外，native方法可以执行，但是，不能与JVM交互。GC各种算法优化的重点，就是减少STW，同时这也是JVM调优的重点。</li></ul><h2 id="什么是三色标记？"><a href="#什么是三色标记？" class="headerlink" title="什么是三色标记？"></a>什么是三色标记？</h2><p>三色标记:是一种逻辑上的抽象。<br>将每个内存对象分成三种颜色:</p><ol><li>黑色：表示自己和成员变量都已经标记完毕。</li><li>灰色：自己标记完了，但是成员变量还没有完全标记完。</li><li>白色：自己未标记完。</li></ol><h2 id="怎么确定一个对象到底是不是垃圾？"><a href="#怎么确定一个对象到底是不是垃圾？" class="headerlink" title="怎么确定一个对象到底是不是垃圾？"></a>怎么确定一个对象到底是不是垃圾？</h2><ol><li>引用计数： 这种方式是给堆内存当中的每个对象记录一个引用个数。引用个数为0的就认为是垃圾。这是早期JDK中使用的方式。引用计数无法解决循环引用的问题。</li><li>根可达算法： 这种方式是在内存中，从引用根对象向下一直找引用，找不到的对象就是垃圾。</li></ol><h2 id="一个对象从加载到JVM，再到被GC清除，都经历了什么过程？"><a href="#一个对象从加载到JVM，再到被GC清除，都经历了什么过程？" class="headerlink" title="一个对象从加载到JVM，再到被GC清除，都经历了什么过程？"></a>一个对象从加载到JVM，再到被GC清除，都经历了什么过程？</h2><ol><li>用户创建一个对象，JVM首先需要到方法区去找对象的类型信息。然后再创建对象。</li><li>JVM要实例化一个对象，首先要在堆当中先创建一个对象。-&gt; 半初始化状态</li><li>对象首先会分配在堆内存中新生代的Eden。然后经过一次Minor GC，对象如果存活，就会进入S区。在后续的每次GC中，如果对象一直存活，就会在S区来回拷贝，每移动一次，年龄加1。-&gt; 多大年龄才会移入老年代？ 年龄最大15， 超过一定年龄后，对象转入老年代。</li><li>当方法执行结束后，栈中的指针会先移除掉。</li><li>堆中的对象，经过Full GC，就会被标记为垃圾，然后被GC线程清理掉。</li></ol><h2 id="你们项目如何排查JVM问题"><a href="#你们项目如何排查JVM问题" class="headerlink" title="你们项目如何排查JVM问题"></a>你们项目如何排查JVM问题</h2><ul><li>对于还在正常运行的系统：<ol><li>可以使用jmap来查看JVM中各个区域的使用情况</li><li>可以通过jstack来查看线程的运行情况，比如哪些线程阻塞、是否出现了死锁</li><li>可以通过jstat命令来查看垃圾回收的情况，特别是fullgc，如果发现fullgc比较频繁，那么就得进行调优了</li><li>通过各个命令的结果，或者jvisualvm等工具来进行分析</li><li>首先，初步猜测频繁发送fullgc的原因，如果频繁发生fullgc但是又一直没有出现内存溢出，那么表示fullgc实际上是回收了很多对象了，所以这些对象最好能在younggc过程中就直接回收掉，避免这些对象进入到老年代，对于这种情况，就要考虑这些存活时间不长的对象是不是比较大，导致年轻代放不下，直接进入到了老年代，尝试加大年轻代的大小，如果改完之后，fullgc减少，则证明修改有效</li><li>同时，还可以找到占用CPU最多的线程，定位到具体的方法，优化这个方法的执行，看是否能避免某些对象的创建，从而节省内存</li></ol></li><li>对于已经发生了OOM的系统：<ol><li>一般生产系统中都会设置当系统发生了OOM时，生成当时的dump文件（-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;&#x2F;usr&#x2F;local&#x2F;base）</li><li>我们可以利用jsisualvm等工具来分析dump文件</li><li>根据dump文件找到异常的实例对象，和异常的线程（占用CPU高），定位到具体的代码</li><li>然后再进行详细的分析和调试</li></ol></li><li>总之，调优不是一蹴而就的，需要分析、推理、实践、总结、再分析，最终定位到具体的问题</li></ul><h1 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h1><h2 id="线程的生命周期？线程有几种状态"><a href="#线程的生命周期？线程有几种状态" class="headerlink" title="线程的生命周期？线程有几种状态"></a>线程的生命周期？线程有几种状态</h2><ul><li>线程通常有五种状态：<ol><li>新建状态（New）：新创建了一个线程对象。</li><li>就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。</li><li>运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。</li><li>阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。</li><li>死亡状态（Dead）：线程执行完了或者因异常退出了run方法，该线程结束生命周期。</li></ol></li><li>阻塞的情况又分为三种：<ol><li>等待阻塞：运行的线程执行wait方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify或notifyAll方法才能被唤醒，wait是object类的方法</li><li>同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中。</li><li>其他阻塞：运行的线程执行sleep或join方法，或者发出了I&#x2F;O请求时，JVM会把该线程置为阻塞状态。当sleep状态超时、join等待线程终止或者超时、或者I&#x2F;O处理完毕时，线程重新转入就绪状态。sleep是Thread类的方法</li></ol></li></ul><h2 id="sleep-、wait-、join-、yield-之间的的区别"><a href="#sleep-、wait-、join-、yield-之间的的区别" class="headerlink" title="sleep()、wait()、join()、yield()之间的的区别"></a>sleep()、wait()、join()、yield()之间的的区别</h2><ol><li>sleep 是 Thread 类的静态本地方法，wait 则是 Object 类的本地方法。</li><li>sleep方法不会释放lock，但是wait会释放，而且会加入到等待队列中。</li><li>sleep方法不依赖于同步器synchronized，但是wait需要依赖synchronized关键字。</li><li>sleep不需要被唤醒（休眠之后推出阻塞），但是wait需要（不指定时间需要被别人中断）。</li><li>sleep 一般用于当前线程休眠，或者轮循暂停操作，wait 则多用于多线程之间的通信。</li><li>sleep 会让出 CPU 执行时间且强制上下文切换，而 wait 则不一定，wait 后可能还是有机会重新竞争到锁继续执行的。</li><li>yield（）执行后线程直接进入就绪状态，马上释放了cpu的执行权，但是依然保留了cpu的执行资格，所以有可能cpu下次进行线程调度还会让这个线程获取到执行权继续执行</li><li>join（）执行后线程进入阻塞状态，例如在线程B中调用线程A的join（），那线程B会进入到阻塞队列，直到线程A结束或中断线程</li></ol><h2 id="对线程安全的理解"><a href="#对线程安全的理解" class="headerlink" title="对线程安全的理解"></a>对线程安全的理解</h2><ul><li>不是线程安全、应该是内存安全，堆是共享内存，可以被所有线程访问，当多个线程访问一个对象时，如果不用进行额外的同步控制或其他的协调操作，调用这个对象的行为都可以获得正确的结果，我们就说这个对象是线程安全的。</li><li>堆是进程和线程共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是用完了要还给操作系统，要不然就是内存泄漏。在Java中，堆是Java虚拟机所管理的内存中最大的一块，是所有线程共享的一块内存区域，在虚拟机启动时创建。堆所存在的内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</li><li>栈是每个线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，因此，栈是线程安全的。操作系统在切换线程的时候会自动切换栈。栈空间不需要在高级语言里面显式的分配和释放。</li><li>目前主流操作系统都是多任务的，即多个进程同时运行。为了保证安全，每个进程只能访问分配给自己的内存空间，而不能访问别的进程的，这是由操作系统保障的。</li><li>在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）。进程内的所有线程都可以访问到该区域，这就是造成问题的潜在原因。</li></ul><h2 id="Thread和Runable的区别"><a href="#Thread和Runable的区别" class="headerlink" title="Thread和Runable的区别"></a>Thread和Runable的区别</h2><ul><li>Thread和Runnable的实质是继承关系，没有可比性。无论使用Runnable还是Thread，都会new Thread，然后执行run方法。用法上，如果有复杂的线程操作需求，那就选择继承Thread，如果只是简单的执行一个任务，那就实现runnable。</li></ul><h2 id="对守护线程的理解"><a href="#对守护线程的理解" class="headerlink" title="对守护线程的理解"></a>对守护线程的理解</h2><ul><li>守护线程：为所有非守护线程提供服务的线程；任何一个守护线程都是整个JVM中所有非守护线程的保姆；守护线程类似于整个进程的一个默默无闻的小喽喽；它的生死无关重要，它却依赖整个进程而运行；哪天其他线程结束了，没有要执行的了，程序就结束了，理都没理守护线程，就把它中断了；</li><li>注意： 由于守护线程的终止是自身无法控制的，因此千万不要把IO、File等重要操作逻辑分配给它；因为它不靠谱；</li><li>守护线程的作用是什么？举例， GC垃圾回收线程：就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是JVM上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。 应用场景：（1）来为其它线程提供服务支持的情况；（2） 或者在任何情况下，程序结束时，这个线程必须正常且立刻关闭，就可以作为守护线程来使用；反之，如果一个正在执行某个操作的线程必须要正确地关闭掉否则就会出现不好的后果的话，那么这个线程就不能是守护线程，而是用户线程。通常都是些关键的事务，比方说，数据库录入或者更新，这些操作都是不能中断的。</li></ul><h2 id="ThreadLocal的底层原理"><a href="#ThreadLocal的底层原理" class="headerlink" title="ThreadLocal的底层原理"></a>ThreadLocal的底层原理</h2><ol><li>ThreadLocal是Java中所提供的线程本地存储机制，可以利用该机制将数据缓存在某个线程内部，该线程可以在任意时刻、任意方法中获取缓存的数据</li><li>ThreadLocal底层是通过ThreadLocalMap来实现的，每个Thread对象（注意不是ThreadLocal对象）中都存在一个ThreadLocalMap，Map的key为ThreadLocal对象，Map的value为需要缓存的值</li><li>如果在线程池中使用ThreadLocal会造成内存泄漏，因为当ThreadLocal对象使用完之后，应该要把设置的key，value，也就是Entry对象进行回收，但线程池中的线程不会回收，而线程对象是通过强引用指向ThreadLocalMap，ThreadLocalMap也是通过强引用指向Entry对象，线程不被回收，Entry对象也就不会被回收，从而出现内存泄漏，解决办法是，在使用了ThreadLocal对象之后，手动调用ThreadLocal的remove方法，手动清楚Entry对象</li><li>ThreadLocal经典的应用场景就是连接管理（一个线程持有一个连接，该连接对象可以在不同的方法之间进行传递，线程之间不共享同一个连接）</li></ol><h2 id="并发、并行、串行之间的区别"><a href="#并发、并行、串行之间的区别" class="headerlink" title="并发、并行、串行之间的区别"></a>并发、并行、串行之间的区别</h2><ol><li>串行在时间上不可能发生重叠，前一个任务没搞定，下一个任务就只能等着</li><li>并行在时间上是重叠的，两个任务在同一时刻互不干扰的同时执行。</li><li>并发允许两个任务彼此干扰。统一时间点、只有一个任务运行，交替执行</li></ol><h2 id="并发的三大特性"><a href="#并发的三大特性" class="headerlink" title="并发的三大特性"></a>并发的三大特性</h2><ul><li>原子性：原子性是指在一个操作中cpu不可以在中途暂停然后再调度，即不被中断操作，要不全部执行完成，要不都不执行。就好比转账，从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。2个操作必须全部完成。</li><li>可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</li><li>有序性：虚拟机在进行代码编译时，对于那些改变顺序之后不会对最终结果造成影响的代码，虚拟机不一定会按照我们写的代码的顺序来执行，有可能将他们重排序。实际上，对于有些代码进行重排序之后，虽然对变量的值没有造成影响，但有可能会出现线程安全问题。</li></ul><h2 id="Java死锁如何避免？"><a href="#Java死锁如何避免？" class="headerlink" title="Java死锁如何避免？"></a>Java死锁如何避免？</h2><ul><li>造成死锁的几个原因：<ol><li>一个资源每次只能被一个线程使用</li><li>一个线程在阻塞等待某个资源时，不释放已占有资源</li><li>一个线程已经获得的资源，在未使用完之前，不能被强行剥夺</li><li>若干线程形成头尾相接的循环等待资源关系</li><li>这是造成死锁必须要达到的4个条件，如果要避免死锁，只需要不满足其中某一个条件即可。而其中前3个条件是作为锁要符合的条件，所以要避免死锁就需要打破第4个条件，不出现循环等待锁的关系。</li></ol></li><li>在开发过程中：<ol><li>要注意加锁顺序，保证每个线程按同样的顺序进行加锁</li><li>要注意加锁时限，可以针对所设置一个超时时间</li><li>要注意死锁检查，这是一种预防机制，确保在第一时间发现死锁并进行解决</li></ol></li><li>为什么用线程池？解释下线程池参数？<ul><li>降低资源消耗；提高线程利用率，降低创建和销毁线程的消耗。</li><li>提高响应速度；任务来了，直接有线程可用可执行，而不是先创建线程，再执行。</li><li>提高线程的可管理性；线程是稀缺资源，使用线程池可以统一分配调优监控。<ul><li><code>corePoolSize</code> 代表核心线程数，也就是正常情况下创建工作的线程数，这些线程创建后并不会消除，而是一种常驻线程</li><li><code>maxinumPoolSize</code> 代表的是最大线程数，它与核心线程数相对应，表示最大允许被创建的线程数，比如当前任务较多，将核心线程数都用完了，还无法满足需时，此时就会创建新的线程，但是线程池内线程总数不会超过最大线程数</li><li><code>keepAliveTime</code>、<code>unit</code> 表示超出核心线程数之外的线程的空闲存活时间，也就是核心线程不会消除，但是超出核心线程数的部分线程如果空闲一定的时间则会被消除,我们可以通过 <code>setKeepAliveTime</code> 来设置空闲时间</li><li><code>workQueue</code> 用来存放待执行的任务，假设我们现在核心线程都已被使用，还有任务进来则全部放入队列，直到整个队列被放满但任务还再持续进入则会开始创建新的线程</li><li><code>ThreadFactory</code> 实际上是一个线程工厂，用来生产线程执行任务。我们可以选择使用默认的创建工厂，产生的线程都在同一个组内，拥有相同的优先级，且都不是守护线程。当然我们也可以选择自定义线程工厂，一般我们会根据业务来制定不同的线程工厂</li><li><code>Handler</code> 任务拒绝策略，有两种情况，第一种是当我们调用<code>shutdown</code> 等方法关闭线程池后，这时候即使线程池内部还有没执行完的任务正在执行，但是由于线程池已经关闭，我们再继续想线程池提交任务就会遭到拒绝。另一种情况就是当达到最大线程数，线程池已经没有能力继续处理新提交的任务时，这是也就拒绝</li></ul></li></ul></li></ul><h2 id="线程池的底层工作原理"><a href="#线程池的底层工作原理" class="headerlink" title="线程池的底层工作原理"></a>线程池的底层工作原理</h2><ul><li>线程池内部是通过队列+线程实现的，当我们利用线程池执行任务时：<ol><li>如果此时线程池中的线程数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。</li><li>如果此时线程池中的线程数量等于corePoolSize，但是缓冲队列workQueue未满，那么任务被放入缓冲队列。</li><li>如果此时线程池中的线程数量大于等于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。</li><li>如果此时线程池中的线程数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。</li><li>当线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数</li></ol></li></ul><h2 id="线程池中阻塞队列的作用？为什么是先添加列队而不是先创建最大线程？"><a href="#线程池中阻塞队列的作用？为什么是先添加列队而不是先创建最大线程？" class="headerlink" title="线程池中阻塞队列的作用？为什么是先添加列队而不是先创建最大线程？"></a>线程池中阻塞队列的作用？为什么是先添加列队而不是先创建最大线程？</h2><ol><li>一般的队列只能保证作为一个有限长度的缓冲区，如果超出了缓冲长度，就无法保留当前的任务了，阻塞队列通过阻塞可以保留住当前想要继续入队的任务。阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程，使得线程进入wait状态，释放cpu资源。阻塞队列自带阻塞和唤醒的功能，不需要额外处理，无任务执行时,线程池利用阻塞队列的take方法挂起，从而维持核心线程的存活、不至于一直占用cpu资源</li><li>在创建新线程的时候，是要获取全局锁的，这个时候其它的就得阻塞，影响了整体效率。就好比一个企业里面有10个（core）正式工的名额，最多招10个正式工，要是任务超过正式工人数（task &gt; core）的情况下，工厂领导（线程池）不是首先扩招工人，还是这10人，但是任务可以稍微积压一下，即先放到队列去（代价低）。10个正式工慢慢干，迟早会干完的，要是任务还在继续增加，超过正式工的加班忍耐极限了（队列满了），就的招外包帮忙了（注意是临时工）要是正式工加上外包还是不能完成任务，那新来的任务就会被领导拒绝了（线程池的拒绝策略）。</li></ol><h2 id="线程池中线程复用原理"><a href="#线程池中线程复用原理" class="headerlink" title="线程池中线程复用原理"></a>线程池中线程复用原理</h2><ul><li>线程池将线程和任务进行解耦，线程是线程，任务是任务，摆脱了之前通过 Thread 创建线程时的一个线程必须对应一个任务的限制。</li><li>在线程池中，同一个线程可以从阻塞队列中不断获取新任务来执行，其核心原理在于线程池对 Thread 进行了封装，并不是每次执行任务都会调用 Thread.start() 来创建新线程，而是让每个线程去执行一个“循环任务”，在这个“循环任务”中不停检查是否有任务需要被执行，如果有则直接执行，也就是调用任务中的 run 方法，将 run 方法当成一个普通的方法执行，通过这种方式只使用固定的线程就将所有任务的 run 方法串联起来。</li></ul><h2 id="ReentrantLock中的公平锁和非公平锁的底层实现"><a href="#ReentrantLock中的公平锁和非公平锁的底层实现" class="headerlink" title="ReentrantLock中的公平锁和非公平锁的底层实现"></a>ReentrantLock中的公平锁和非公平锁的底层实现</h2><ul><li>首先不管是公平锁和非公平锁，它们的底层实现都会使用AQS来进行排队，它们的区别在于：线程在使用lock()方法加锁时，如果是公平锁，会先检查AQS队列中是否存在线程在排队，如果有线程在排队，则当前线程也进行排队，如果是非公平锁，则不会去检查是否有线程在排队，而是直接竞争锁。</li><li>不管是公平锁还是非公平锁，一旦没竞争到锁，都会进行排队，当锁释放时，都是唤醒排在最前面的线程，所以非公平锁只是体现在了线程加锁阶段，而没有体现在线程被唤醒阶段。</li><li>另外，ReentrantLock是可重入锁，不管是公平锁还是非公平锁都是可重入的。</li></ul><h2 id="ReentrantLock中tryLock-和lock-方法的区别"><a href="#ReentrantLock中tryLock-和lock-方法的区别" class="headerlink" title="ReentrantLock中tryLock()和lock()方法的区别"></a>ReentrantLock中tryLock()和lock()方法的区别</h2><ul><li><ol><li>tryLock()表示尝试加锁，可能加到，也可能加不到，该方法不会阻塞线程，如果加到锁则返回true，没有加到则返回false</li></ol></li><li><ol start="2"><li>lock()表示阻塞加锁，线程会阻塞直到加到锁，方法也没有返回值</li></ol></li></ul><h2 id="CountDownLatch和Semaphore的区别和底层原理"><a href="#CountDownLatch和Semaphore的区别和底层原理" class="headerlink" title="CountDownLatch和Semaphore的区别和底层原理"></a>CountDownLatch和Semaphore的区别和底层原理</h2><ul><li>CountDownLatch表示计数器，可以给CountDownLatch设置一个数字，一个线程调用CountDownLatch的await()将会阻塞，其他线程可以调用CountDownLatch的countDown()方法来对CountDownLatch中的数字减一，当数字被减成0后，所有await的线程都将被唤醒。对应的底层原理就是，调用await()方法的线程会利用AQS排队，一旦数字被减为0，则会将AQS中排队的线程依次唤醒。</li><li>Semaphore表示信号量，可以设置许可的个数，表示同时允许最多多少个线程使用该信号量，通过acquire()来获取许可，如果没有许可可用则线程阻塞，并通过AQS来排队，可以通过release()方法来释放许可，当某个线程释放了某个许可后，会从AQS中正在排队的第一个线程开始依次唤醒，直到没有空闲许可。</li></ul><h2 id="Sychronized的偏向锁、轻量级锁、重量级锁"><a href="#Sychronized的偏向锁、轻量级锁、重量级锁" class="headerlink" title="Sychronized的偏向锁、轻量级锁、重量级锁"></a>Sychronized的偏向锁、轻量级锁、重量级锁</h2><ol><li>偏向锁：在锁对象的对象头中记录一下当前获取到该锁的线程ID，该线程下次如果又来获取该锁就可以直接获取到了</li><li>轻量级锁：由偏向锁升级而来，当一个线程获取到锁后，此时这把锁是偏向锁，此时如果有第二个线程来竞争锁，偏向锁就会升级为轻量级锁，之所以叫轻量级锁，是为了和重量级锁区分开来，轻量级锁底层是通过自旋来实现的，并不会阻塞线程</li><li>如果自旋次数过多仍然没有获取到锁，则会升级为重量级锁，重量级锁会导致线程阻塞</li><li>自旋锁：自旋锁就是线程在获取锁的过程中，不会去阻塞线程，也就无所谓唤醒线程，阻塞和唤醒这两个步骤都是需要操作系统去进行的，比较消耗时间，自旋锁是线程通过CAS获取预期的一个标记，如果没有获取到，则继续循环获取，如果获取到了则表示获取到了锁，这个过程线程一直在运行中，相对而言没有使用太多的操作系统资源，比较轻量。</li></ol><h2 id="Sychronized和ReentrantLock的区别"><a href="#Sychronized和ReentrantLock的区别" class="headerlink" title="Sychronized和ReentrantLock的区别"></a>Sychronized和ReentrantLock的区别</h2><ol><li>sychronized是一个关键字，ReentrantLock是一个类</li><li>sychronized会自动的加锁与释放锁，ReentrantLock需要程序员手动加锁与释放锁</li><li>sychronized的底层是JVM层面的锁，ReentrantLock是API层面的锁</li><li>sychronized是非公平锁，ReentrantLock可以选择公平锁或非公平锁</li><li>sychronized锁的是对象，锁信息保存在对象头中，ReentrantLock通过代码中int类型的state标识来标识锁的状态</li><li>sychronized底层有一个锁升级的过程</li></ol><h2 id="谈谈你对AQS的理解，AQS如何实现可重入锁？"><a href="#谈谈你对AQS的理解，AQS如何实现可重入锁？" class="headerlink" title="谈谈你对AQS的理解，AQS如何实现可重入锁？"></a>谈谈你对AQS的理解，AQS如何实现可重入锁？</h2><ol><li>AQS是一个JAVA线程同步的框架。是JDK中很多锁工具的核心实现框架。</li><li>在AQS中，维护了一个信号量state和一个线程组成的双向链表队列。其中，这个线程队列，就是用来给线程排队的，而state就像是一个红绿灯，用来控制线程排队或者放行的。 在不同的场景下，有不用的意义。</li><li>在可重入锁这个场景下，state就用来表示加锁的次数。0标识无锁，每加一次锁，state就加1。释放锁state就减1。</li></ol><h1 id="开发框架"><a href="#开发框架" class="headerlink" title="开发框架"></a>开发框架</h1><h2 id="谈谈你对AOP的理解"><a href="#谈谈你对AOP的理解" class="headerlink" title="谈谈你对AOP的理解"></a>谈谈你对AOP的理解</h2><ul><li>系统是由许多不同的组件所组成的，每一个组件各负责一块特定功能。除了实现自身核心功能之外，这些组件还经常承担着额外的职责。例如日志、事务管理和安全这样的核心服务经常融入到自身具有核心业务逻辑的组件中去。这些系统服务经常被称为横切关注点，因为它们会跨越系统的多个组件。</li><li>当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。</li><li>日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。</li><li>在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</li><li>AOP：将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到目标对象（具体业务逻辑）中去。AOP可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增强，可以在执行某个方法之前额外的做一些事情，在某个方法执行之后额外的做一些事情</li></ul><h2 id="谈谈你对IOC的理解"><a href="#谈谈你对IOC的理解" class="headerlink" title="谈谈你对IOC的理解"></a>谈谈你对IOC的理解</h2><ul><li>容器概念、控制反转、依赖注入</li><li>ioc容器：实际上就是个map（key，value），里面存的是各种对象（在xml里配置的bean节点、@repository、@service、@controller、@component），在项目启动的时候会读取配置文件里面的bean节点，根据全限定类名使用反射创建对象放到map里、扫描到打上上述注解的类还是通过反射创建对象放到map里。这个时候map里就有各种对象了，接下来我们在代码里需要用到里面的对象时，再通过DI注入（autowired、resource等注解，xml里bean节点内的ref属性，项目启动的时候会读取xml节点ref属性根据id注入，也会扫描这些注解，根据类型或id注入；id就是对象名）。</li><li>控制反转：没有引入IOC容器之前，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。引入IOC容器之后，对象A与对象B之间失去了直接联系，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。通过前后的对比，不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。</li><li>依赖注入：“获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。依赖注入是实现IOC的方法，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。</li></ul><h2 id="解释下Spring支持的几种bean的作用域。"><a href="#解释下Spring支持的几种bean的作用域。" class="headerlink" title="解释下Spring支持的几种bean的作用域。"></a>解释下Spring支持的几种bean的作用域。</h2><ul><li>singleton：默认，每个容器中只有一个bean的实例，单例的模式由BeanFactory自身来维护。该对象的生命周期是与Spring IOC容器一致的（但在第一次被注入时才会创建）。</li><li>prototype：为每一个bean请求提供一个实例。在每次注入时都会创建一个新的对象</li><li>request：bean被定义为在每个HTTP请求中创建一个单例对象，也就是说在单个请求中都会复用这一个单例对象。</li><li>session：与request范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。</li><li>application：bean被定义为在ServletContext的生命周期中复用一个单例对象。</li><li>websocket：bean被定义为在websocket的生命周期中复用一个单例对象。 global-session：全局作用域，global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。全局作用域与Servlet中的session作用域效果相同。</li></ul><h2 id="Spring事务传播机制"><a href="#Spring事务传播机制" class="headerlink" title="Spring事务传播机制"></a>Spring事务传播机制</h2><p>多个事务方法相互调用时，事务如何在这些方法间传播,方法A是一-个事务的方法，方法A执行过程</p><ol><li>REQUIRED(Spring默认的事务传播类型)：如果当前没有事务，则自己新建一个事务，如果当前存在事务，则加入这个事务</li><li>SUPPORTS：当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行</li><li>MANDATORY：当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常。</li><li>REQUIRES_NEW：创建一个新事务，如果存在当前事务，则挂起该事务。</li><li>NOT_SUPPORTED：以非事务方式执行,如果当前存在事务，则挂起当前事务</li><li>NEVER：不使用事务，如果当前事务存在，则抛出异常</li><li>NESTED：如果当前事务存在，则在嵌套事务中执行，否则REQUIRED的操作一样（开启一个事务）</li></ol><h2 id="Spring事务什么时候会失效"><a href="#Spring事务什么时候会失效" class="headerlink" title="Spring事务什么时候会失效?"></a>Spring事务什么时候会失效?</h2><p>spring事务的原理是AOP，进行了切面增强，那么失效的根本原因是这个AOP不起作用了!常见情况</p><ol><li>发生自调用，类里面使用this调用本类的方法（this通常省略），此时这个this对象不是代理类，而是UserService对象本身！ 解决方法很简单，让那个this变成UserService的代理类即可！</li><li>方法不是public的：@Transactional 只能用于 public 的方法上，否则事务不会失效，如果要用在非 public 方法上，可以开启 AspectJ 代理模式。</li><li>数据库不支持事务</li><li>没有被spring管理</li><li>异常被吃掉，事务不会回滚(或者抛出的异常没有被定义，默认为RuntimeException)</li></ol><h2 id="Spring中的Bean创建的生命周期有哪些步骤"><a href="#Spring中的Bean创建的生命周期有哪些步骤" class="headerlink" title="Spring中的Bean创建的生命周期有哪些步骤"></a>Spring中的Bean创建的生命周期有哪些步骤</h2><p>Spring中一个Bean的创建大概分为以下几个步骤:</p><ol><li>推断构造方法</li><li>实例化</li><li>填充属性，也就是依赖注入</li><li>处理Aware回调</li><li>初始化前，处理@PostConstruct注解</li><li>初始化，处理InitializingBean接口</li><li>初始化后，进行AOP</li></ol><h2 id="Spring中Bean是线程安全的吗"><a href="#Spring中Bean是线程安全的吗" class="headerlink" title="Spring中Bean是线程安全的吗"></a>Spring中Bean是线程安全的吗</h2><ul><li>Spring本身并没有针对Bean做线程安全的处理，所以：<ol><li>如果Bean是无状态的，那么Bean则是线程安全的</li><li>如果Bean是有状态的，那么Bean则不是线程安全的</li></ol></li><li>另外，Bean是不是线程安全，跟Bean的作用域没有关系，Bean的作用域只是表示Bean的生命周期范围，对于任何生命周期的Bean都是一个对象，这个对象是不是线程安全的，还是得看这个Bean对象本身。</li></ul><h2 id="ApplicationContext和BeanFactory有什么区别"><a href="#ApplicationContext和BeanFactory有什么区别" class="headerlink" title="ApplicationContext和BeanFactory有什么区别"></a>ApplicationContext和BeanFactory有什么区别</h2><ul><li>BeanFactory是Spring中非常核心的组件，表示Bean工厂，可以生成Bean，维护Bean，而ApplicationContext继承了BeanFactory，所以ApplicationContext拥有BeanFactory所有的特点，也是一个Bean工厂，但是ApplicationContext除开继承了BeanFactory之外，还继承了诸如EnvironmentCapable、MessageSource、ApplicationEventPublisher等接口，从而ApplicationContext还有获取系统环境变量、国际化、事件发布等功能，这是BeanFactory所不具备的</li></ul><h2 id="Spring中的事务是如何实现的"><a href="#Spring中的事务是如何实现的" class="headerlink" title="Spring中的事务是如何实现的"></a>Spring中的事务是如何实现的</h2><ol><li>Spring事务底层是基于数据库事务和AOP机制的</li><li>首先对于使用了@Transactional注解的Bean，Spring会创建一个代理对象作为Bean</li><li>当调用代理对象的方法时，会先判断该方法上是否加了@Transactional注解</li><li>如果加了，那么则利用事务管理器创建一个数据库连接</li><li>并且修改数据库连接的autocommit属性为false，禁止此连接的自动提交，这是实现Spring事务非常重要的一步</li><li>然后执行当前方法，方法中会执行sql</li><li>执行完当前方法后，如果没有出现异常就直接提交事务</li><li>如果出现了异常，并且这个异常是需要回滚的就会回滚事务，否则仍然提交事务</li><li>Spring事务的隔离级别对应的就是数据库的隔离级别</li><li>Spring事务的传播机制是Spring事务自己实现的，也是Spring事务中最复杂的</li><li>Spring事务的传播机制是基于数据库连接来做的，一个数据库连接一个事务，如果传播机制配置为需要新开一个事务，那么实际上就是先建立一个数据库连接，在此新数据库连接上执行sql</li></ol><h2 id="Spring中什么时候-Transactional会失效"><a href="#Spring中什么时候-Transactional会失效" class="headerlink" title="Spring中什么时候@Transactional会失效"></a>Spring中什么时候@Transactional会失效</h2><ul><li>因为Spring事务是基于代理来实现的，所以某个加了@Transactional的方法只有是被代理对象调用时，那么这个注解才会生效，所以如果是被代理对象来调用这个方法，那么@Transactional是不会失效的。</li><li>同时如果某个方法是private的，那么@Transactional也会失效，因为底层cglib是基于父子类来实现的，子类是不能重载父类的private方法的，所以无法很好的利用代理，也会导致@Transactianal失效</li></ul><h2 id="Spring容器启动流程是怎样的"><a href="#Spring容器启动流程是怎样的" class="headerlink" title="Spring容器启动流程是怎样的"></a>Spring容器启动流程是怎样的</h2><ol><li>在创建Spring容器，也就是启动Spring时：</li><li>首先会进行扫描，扫描得到所有的BeanDefinition对象，并存在一个Map中</li><li>然后筛选出非懒加载的单例BeanDefinition进行创建Bean，对于多例Bean不需要在启动过程中去进行创建，对于多例Bean会在每次获取Bean时利用BeanDefinition去创建</li><li>利用BeanDefinition创建Bean就是Bean的创建生命周期，这期间包括了合并BeanDefinition、推断构造方法、实例化、属性填充、初始化前、初始化、初始化后等步骤，其中AOP就是发生在初始化后这一步骤中</li><li>单例Bean创建完了之后，Spring会发布一个容器启动事件</li><li>Spring启动结束</li><li>在源码中会更复杂，比如源码中会提供一些模板方法，让子类来实现，比如源码中还涉及到一些BeanFactoryPostProcessor和BeanPostProcessor的注册，Spring的扫描就是通过BenaFactoryPostProcessor来实现的，依赖注入就是通过BeanPostProcessor来实现的</li><li>在Spring启动过程中还会去处理@Import等注解</li></ol><h2 id="Spring用到了哪些设计模式"><a href="#Spring用到了哪些设计模式" class="headerlink" title="Spring用到了哪些设计模式"></a>Spring用到了哪些设计模式</h2><ul><li>责任链模式<ul><li>DefaultAdvisorChainFactory<ul><li>负责构造一条AdvisorChain，代理对象执行某个方法时会依次经过AdvisorChain中的每个Advisor</li></ul></li><li>QualifierAnnotationAutowireCandidateResolver<ul><li>判断某个Bean能不能用来进行依赖注入<ul><li>勉强可以认为也是责任链</li></ul></li></ul></li></ul></li><li>模板方法模式<ul><li>AbstractApplicationContext<ul><li>postProcessBeanFactory()<br>子类可以继续处理BeanFactory</li><li>onRefresh()<br>子类可以做一些额外的初始化</li></ul></li></ul></li><li>策略模式<ul><li>InstantiationStrategy<ul><li>Spring需要根据BeanDefinition来实例化Bean，但是具体可以选择不同的策略来进行实例化</li></ul></li><li>BeanNameGenerator<ul><li>beanName生成器</li></ul></li></ul></li><li>观察者模式<ul><li>ApplicationListener<ul><li>事件监听机制</li></ul></li><li>AdvisedSupportListener<ul><li>ProxyFactory可以提交此监听器，用来监听ProxyFactory创建代理对象完成事件、添加Advisor事件等</li></ul></li></ul></li><li>代理模式<ul><li>方式生成了代理对象的地方就用到了代理模式</li><li>AOP</li><li>@Configuration</li><li>@Lazy</li></ul></li><li>装饰器模式<ul><li>BeanWrapper<ul><li>比单纯的Bean对象功能更加强大</li></ul></li><li>HttpRequestWrapper</li></ul></li><li>访问者模式<ul><li>PropertyAccessor<ul><li>属性访问器，用来访问和设置某个对象的某个属性</li></ul></li><li>MessageSourceAccessor<ul><li>国际化资源访问器</li></ul></li></ul></li><li>适配器模式<ul><li>ApplicationListenerMethodAdapter<ul><li>将@EventListener注解的方法适配成ApplicationListener</li></ul></li><li>AdvisorAdapter<ul><li>把Advisor适配成MethodInterceptor</li></ul></li></ul></li><li>构建器模式<ul><li>BeanDefinitionBuilder<ul><li>BeanDefinition构造器</li></ul></li><li>BeanFactoryAspectJAdvisorsBuilder<ul><li>解析并构造@AspectJ注解的Bean中所定义的Advisor</li></ul></li><li>StringBuilder</li></ul></li></ul><h2 id="Spring-MVC-工作流程"><a href="#Spring-MVC-工作流程" class="headerlink" title="Spring MVC 工作流程"></a>Spring MVC 工作流程</h2><ol><li>用户发送请求至前端控制器 DispatcherServlet。</li><li>DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。</li><li>处理器映射器找到具体的处理器(可以根据 xml 配置、注解进行查找)，生成处理器及处理器拦截器(如果有则生成)一并返回给 DispatcherServlet。</li><li>DispatcherServlet 调用 HandlerAdapter 处理器适配器。</li><li>HandlerAdapter 经过适配调用具体的处理器(Controller，也叫后端控制器)</li><li>Controller 执行完成返回 ModelAndView。</li><li>HandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServlet。8）DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器。</li><li>ViewReslover 解析后返回具体 View。</li><li>DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）。</li><li>DispatcherServlet 响应用户。</li></ol><h2 id="Spring-MVC的主要组件？"><a href="#Spring-MVC的主要组件？" class="headerlink" title="Spring MVC的主要组件？"></a>Spring MVC的主要组件？</h2><ol><li>Handler：也就是处理器。它直接应对着MVC中的C也就是Controller层，它的具体表现形式有很多，可以是类，也可以是方法。在Controller层中@RequestMapping标注的所有方法都可以看成是一个Handler，只要可以实际处理请求就可以是Handler</li><li>HandlerMapping：initHandlerMappings(context)，处理器映射器，根据用户请求的资源uri来查找Handler的。在SpringMVC中会有很多请求，每个请求都需要一个Handler处理，具体接收到一个请求之后使用哪个Handler进行，这就是HandlerMapping需要做的事。</li><li>HandlerAdapter：initHandlerAdapters(context)，适配器。因为SpringMVC中的Handler可以是任意的形式，只要能处理请求就ok，但是Servlet需要的处理方法的结构却是固定的，都是以request和response为参数的方法。如何让固定的Servlet处理方法调用灵活的Handler来进行处理呢？这就是HandlerAdapter要做的事情。 Handler是用来干活的工具；HandlerMapping用于根据需要干的活找到相应的工具；HandlerAdapter是使用工具干活的人。</li><li>HandlerExceptionResolver：initHandlerExceptionResolvers(context)， 其它组件都是用来干活的。在干活的过程中难免会出现问题，出问题后怎么办呢？这就需要有一个专门的角色对异常情况进行处理，在SpringMVC中就是HandlerExceptionResolver。具体来说，此组件的作用是根据异常设置ModelAndView，之后再交给render方法进行渲染。</li><li>ViewResolver：initViewResolvers(context)，ViewResolver用来将String类型的视图名和Locale解析为View类型的视图。View是用来渲染页面的，也就是将程序返回的参数填入模板里，生成html（也可能是其它类型）文件。这里就有两个关键问题：使用哪个模板？用什么技术（规则）填入参数？这其实是ViewResolver主要要做的工作，ViewResolver需要找到渲染所用的模板和所用的技术（也就是视图的类型）进行渲染，具体的渲染过程则交由不同的视图自己完成。</li><li>RequestToViewNameTranslator：initRequestToViewNameTranslator(context)，ViewResolver是根据ViewName查找View，但有的Handler处理完后并没有设置View也没有设置ViewName，这时就需要从request获取ViewName了，如何从request中获取ViewName就是RequestToViewNameTranslator要做的事情了。RequestToViewNameTranslator在Spring MVC容器里只可以配置一个，所以所有request到ViewName的转换规则都要在一个Translator里面全部实现。</li><li>LocaleResolver：initLocaleResolver(context)， 解析视图需要两个参数：一是视图名，另一个是Locale。视图名是处理器返回的，Locale是从哪里来的？这就是LocaleResolver要做的事情。LocaleResolver用于从request解析出Locale，Locale就是zh-cn之类，表示一个区域，有了这个就可以对不同区域的用户显示不同的结果。SpringMVC主要有两个地方用到了Locale：一是ViewResolver视图解析的时候；二是用到国际化资源或者主题的时候。</li><li>ThemeResolver：initThemeResolver(context)，用于解析主题。SpringMVC中一个主题对应一个properties文件，里面存放着跟当前主题相关的所有资源、如图片、css样式等。SpringMVC的主题也支持国际化，同一个主题不同区域也可以显示不同的风格。SpringMVC中跟主题相关的类有 ThemeResolver、ThemeSource和Theme。主题是通过一系列资源来具体体现的，要得到一个主题的资源，首先要得到资源的名称，这是ThemeResolver的工作。然后通过主题名称找到对应的主题（可以理解为一个配置）文件，这是ThemeSource的工作。最后从主题中获取资源就可以了。</li><li>MultipartResolver：initMultipartResolver(context)，用于处理上传请求。处理方法是将普通的request包装成MultipartHttpServletRequest，后者可以直接调用getFile方法获取File，如果上传多个文件，还可以调用getFileMap得到FileName-&gt;File结构的Map。此组件中一共有三个方法，作用分别是判断是不是上传请求，将request包装成MultipartHttpServletRequest、处理完后清理上传过程中产生的临时资源。</li><li>FlashMapManager：initFlashMapManager(context)，用来管理FlashMap的，FlashMap主要用在redirect中传递参数。</li></ol><h2 id="如何理解-Spring-Boot-中的-Starter"><a href="#如何理解-Spring-Boot-中的-Starter" class="headerlink" title="如何理解 Spring Boot 中的 Starter"></a>如何理解 Spring Boot 中的 Starter</h2><ul><li>使用spring + springmvc使用，如果需要引入mybatis等框架，需要到xml中定义mybatis需要的bean</li><li>starter就是定义一个starter的jar包，写一个@Configuration配置类、将这些bean定义在里面，然后在starter包的META-INF&#x2F;spring.factories中写入该配置类，springboot会按照约定来加载该配置类</li><li>开发人员只需要将相应的starter包依赖进应用，进行相应的属性配置（使用默认配置时，不需要配置），就可以直接进行代码开发，使用对应的功能了，比如mybatis-spring-boot–starter，spring-boot-starter-redis</li></ul><h2 id="Spring-Boot中常用注解及其底层实现"><a href="#Spring-Boot中常用注解及其底层实现" class="headerlink" title="Spring Boot中常用注解及其底层实现"></a>Spring Boot中常用注解及其底层实现</h2><ol><li>@SpringBootApplication注解：这个注解标识了一个SpringBoot工程，它实际上是另外三个注解的组合，这三个注解是：</li><li>@SpringBootConfiguration：这个注解实际就是一个@Configuration，表示启动类也是一个配置类</li><li>@EnableAutoConfiguration：向Spring容器中导入了一个Selector，用来加载ClassPath下SpringFactories中所定义的自动配置类，将这些自动加载为配置Bean</li><li>@ComponentScan：标识扫描路径，因为默认是没有配置实际扫描路径，所以SpringBoot扫描的路径是启动类所在的当前目录</li><li>@Bean注解：用来定义Bean，类似于XML中的&lt;bean&gt;标签，Spring在启动时，会对加了@Bean注解的方法进行解析，将方法的名字做为beanName，并通过执行方法得到bean对象</li><li>@Controller、@Service、@ResponseBody、@Autowired都可以说</li></ol><h2 id="Spring-Boot是如何启动Tomcat的"><a href="#Spring-Boot是如何启动Tomcat的" class="headerlink" title="Spring Boot是如何启动Tomcat的"></a>Spring Boot是如何启动Tomcat的</h2><ol><li>首先，SpringBoot在启动时会先创建一个Spring容器</li><li>在创建Spring容器过程中，会利用@ConditionalOnClass技术来判断当前classpath中是否存在Tomcat依赖，如果存在则会生成一个启动Tomcat的Bean</li><li>Spring容器创建完之后，就会获取启动Tomcat的Bean，并创建Tomcat对象，并绑定端口等，然后启动Tomcat</li></ol><h2 id="Spring-Boot中配置文件的加载顺序是怎样的？"><a href="#Spring-Boot中配置文件的加载顺序是怎样的？" class="headerlink" title="Spring Boot中配置文件的加载顺序是怎样的？"></a>Spring Boot中配置文件的加载顺序是怎样的？</h2><ol><li>命令行参数。所有的配置都可以在命令行上进行指定；</li><li>Java系统属性（System.getProperties()）；</li><li>操作系统环境变量 ；</li><li>jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件</li><li>jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 再来加载不带profile</li><li>jar包外部的application.properties或application.yml(不带spring.profile)配置文件</li><li>jar包内部的application.properties或application.yml(不带spring.profile)配置文件</li><li>@Configuration注解类上的@PropertySource</li></ol><h2 id="Mybatis的优缺点"><a href="#Mybatis的优缺点" class="headerlink" title="Mybatis的优缺点"></a>Mybatis的优缺点</h2><ul><li><p>优点：</p><ol><li>基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML 标签， 支持编写动态 SQL 语句， 并可重用。</li><li>与 JDBC 相比，减少了 50%以上的代码量，消除了 JDBC 大量冗余的代码，不需要手动开关连接；</li><li>很好的与各种数据库兼容（ 因为 MyBatis 使用 JDBC 来连接数据库，所以只要JDBC 支持的数据库 MyBatis 都支持）。</li><li>能够与 Spring 很好的集成；</li><li>提供映射标签， 支持对象与数据库的 ORM 字段关系映射； 提供对象关系映射标签， 支持对象关系组件维护。</li></ol></li><li><p>缺点：</p><ol><li>SQL 语句的编写工作量较大， 尤其当字段多、关联表多时， 对开发人员编写SQL 语句的功底有一定要求。</li><li>SQL 语句依赖于数据库， 导致数据库移植性差， 不能随意更换数据库。</li></ol></li></ul><h2 id="MyBatis-与Hibernate-有哪些不同？"><a href="#MyBatis-与Hibernate-有哪些不同？" class="headerlink" title="MyBatis 与Hibernate 有哪些不同？"></a>MyBatis 与Hibernate 有哪些不同？</h2><ul><li>开发速度的对比：Hibernate的真正掌握要比Mybatis难些。Mybatis框架相对简单很容易上手，但也相对简陋些。 比起两者的开发速度，不仅仅要考虑到两者的特性及性能，更要根据项目需求去考虑究竟哪一个更适合项目开发，比如：一个项目中用到的复杂查询基本没有，就是简单的增删改查，这样选择hibernate效率就很快了，因为基本的sql语句已经被封装好了，根本不需要你去写sql语句，这就节省了大量的时间，但是对于一个大型项目，复杂语句较多，这样再去选择hibernate就不是一个太好的选择，选择mybatis就会加快许多，而且语句的管理也比较方便。</li><li>开发工作量的对比：Hibernate和MyBatis都有相应的代码生成工具。可以生成简单基本的DAO层方法。针对高级查询，Mybatis需要手动编写SQL语句，以及ResultMap。而Hibernate有良好的映射机制，开发者无需关心SQL的生成与结果映射，可以更专注于业务流程</li><li>sql优化方面：Hibernate的查询会将表中的所有字段查询出来，这一点会有性能消耗。Hibernate也可以自己写SQL来指定需要查询的字段，但这样就破坏了Hibernate开发的简洁性。而Mybatis的SQL是手动编写的，所以可以按需求指定查询的字段。 Hibernate HQL语句的调优需要将SQL打印出来，而Hibernate的SQL被很多人嫌弃因为太丑了。MyBatis的SQL是自己手动写的所以调整方便。但Hibernate具有自己的日志统计。Mybatis本身不带日志统计，使用Log4j进行日志记录。</li><li>对象管理的对比：Hibernate 是完整的对象&#x2F;关系映射解决方案，它提供了对象状态管理（state management）的功能，使开发者不再需要理会底层数据库系统的细节。也就是说，相对于常见的 JDBC&#x2F;SQL 持久层方案中需要管理 SQL 语句，Hibernate采用了更自然的面向对象的视角来持久化 Java 应用中的数据。 换句话说，使用 Hibernate 的开发者应该总是关注对象的状态（state），不必考虑 SQL 语句的执行。这部分细节已经由 Hibernate 掌管妥当，只有开发者在进行系统性能调优的时候才需要进行了解。而MyBatis在这一块没有文档说明，用户需要对对象自己进行详细的管理。</li><li>缓存机制对比：<ul><li>相同点：都可以实现自己的缓存或使用其他第三方缓存方案，创建适配器来完全覆盖缓存行为。</li><li>不同点：Hibernate的二级缓存配置在SessionFactory生成的配置文件中进行详细配置，然后再在具体的表-对象映射中配置是哪种缓存。</li></ul></li></ul><h2 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h2><ul><li>#{}是预编译处理、是占位符， * ${}是字符串替换、是拼接符。</li><li>Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 来赋值；<br>Mybatis 在处理!{}替换成变量的值，调用 Statement 来赋值；</li><li>#{} 的变量替换是在DBMS 中、变量替换后，#{} 对应的变量自动加上单引号，{} 的变量替换是在 DBMS 外、变量替换后，{} 对应的变量不会加上单引号</li><li>使用#{}可以有效的防止 SQL 注入， 提高系统安全性。</li><li>Thread和Runnable的实质是继承关系，没有可比性。无论使用Runnable还是Thread，都会new Thread，然后执行run方法。用法上，如果有复杂的线程操作需求，那就选择继承Thread，如果只是简单的执行一个任务，那就实现runnable。</li></ul><h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h2 id="索引的基本原理"><a href="#索引的基本原理" class="headerlink" title="索引的基本原理"></a>索引的基本原理</h2><ol><li>把创建了索引的列的内容进行排序</li><li>对排序结果生成倒排表</li><li>在倒排表内容上拼上数据地址链</li><li>在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</li></ol><h2 id="Mysql聚簇和非聚簇索引的区别"><a href="#Mysql聚簇和非聚簇索引的区别" class="headerlink" title="Mysql聚簇和非聚簇索引的区别"></a>Mysql聚簇和非聚簇索引的区别</h2><ul><li>都是B+树的数据结构<ul><li>聚簇索引：将数据存储与索引放到了一块、并且是按照一定的顺序组织的，找到索引也就找到了数据，数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的</li><li>非聚簇索引：叶子节点不存储数据、存储的是数据行地址，也就是说根据索引查找到数据行的位置再取磁盘查找数据，这个就有点类似一本树的目录，比如我们要找第三章第一节，那我们先在这个目录里面找，找到对应的页码后再去对应的页码看文章。</li></ul></li><li>优势：<ul><li>查询通过聚簇索引可以直接获取数据，相比非聚簇索引需要第二次查询（非覆盖索引的情况下）效率要高</li><li>聚簇索引对于范围查询的效率很高，因为其数据是按照大小排列的</li><li>聚簇索引适合用在排序的场合，非聚簇索引不适合</li></ul></li><li>劣势：<ul><li>维护索引很昂贵，特别是插入新行或者主键被更新导至要分页(page split)的时候。建议在大量插入新行后，选在负载较低的时间段，通过OPTIMIZE TABLE优化表，因为必须被移动的行数据可能造成碎片。使用独享表空间可以弱化碎片<br>表因为使用UUId（随机ID）作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫面更慢，所以建议使用int的auto_increment作为主键</li><li>如果主键比较大的话，那辅助索引将会变的更大，因为辅助索引的叶子存储的是主键值；过长的主键值，会导致非叶子节点占用占用更多的物理空间</li></ul></li></ul><h2 id="Mysql索引的数据结构，各自优劣"><a href="#Mysql索引的数据结构，各自优劣" class="headerlink" title="Mysql索引的数据结构，各自优劣"></a>Mysql索引的数据结构，各自优劣</h2><ul><li>B+树：B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接。在B+树上的常规检索，从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高。因此，B+树索引被广泛应用于数据库、文件系统等场景。</li><li>哈希索引：哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快</li></ul><h2 id="索引设计的原则？"><a href="#索引设计的原则？" class="headerlink" title="索引设计的原则？"></a>索引设计的原则？</h2><ol><li>适合索引的列是出现在where子句中的列，或者连接子句中指定的列</li><li>基数较小的表，索引效果较差，没有必要在此列建立索引</li><li>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间，如果搜索词超过索引前缀长度，则使用索引排除不匹配的行，然后检查其余行是否可能匹配。</li><li>不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</li><li>定义有外键的数据列一定要建立索引。</li><li>更新频繁字段不适合创建索引</li><li>若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</li><li>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</li><li>对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</li><li>对于定义为text、image和bit的数据类型的列不要建立索引。</li></ol><h2 id="InnoDB存储引擎的锁的算法"><a href="#InnoDB存储引擎的锁的算法" class="headerlink" title="InnoDB存储引擎的锁的算法"></a>InnoDB存储引擎的锁的算法</h2><ul><li>Record lock：单个行记录上的锁</li><li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li><li>Next-key lock：record+gap 锁定一个范围，包含记录本身</li><li>相关知识点：<ol><li>innodb对于行的查询使用next-key lock</li><li>Next-locking keying为了解决Phantom Problem幻读问题</li><li>当查询的索引含有唯一属性时，将next-key lock降级为record key</li><li>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li><li>有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1</li></ol></li></ul><h2 id="关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"><a href="#关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？" class="headerlink" title="关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"></a>关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？</h2><ul><li>首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。</li><li>分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。</li><li>如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</li></ul><h2 id="事务的基本特性和隔离级别"><a href="#事务的基本特性和隔离级别" class="headerlink" title="事务的基本特性和隔离级别"></a>事务的基本特性和隔离级别</h2><ul><li>事务基本特性ACID分别是：<ul><li>原子性指的是一个事务中的操作要么全部成功，要么全部失败。</li><li>一致性指的是数据库总是从一个一致性的状态转换到另外一个一致性的状态。比如A转账给B100块钱，假设A只有90块，支付之前我们数据库里的数据都是符合约束的,但是如果事务执行成功了,我们的数据库数据就破坏约束了,因此事务不能成功,这里我们说事务提供了一致性的保证</li><li>隔离性指的是一个事务的修改在最终提交前，对其他事务是不可见的。</li><li>持久性指的是一旦事务提交，所做的修改就会永久保存到数据库中。</li></ul></li><li>隔离性有4个隔离级别，分别是：<ul><li>read uncommit  读未提交，可能会读到其他事务未提交的数据，也叫做脏读。 用户本来应该读取到id&#x3D;1的用户age应该是10，结果读取到了其他事务还没有提交的事务，结果读取结果age&#x3D;20，这就是脏读。</li><li>read commit  读已提交，两次读取结果不一致，叫做不可重复读。不可重复读解决了脏读的问题，他只会读取已经提交的事务。用户开启事务读取id&#x3D;1用户，查询到age&#x3D;10，再次读取发现结果&#x3D;20，在同一个事务里同一个查询读取到不同的结果叫做不可重复读。</li><li>repeatable read  可重复复读，这是mysql的默认级别，就是每次读取结果都一样，但是有可能产生幻读。</li><li>serializable  串行，一般是不会使用的，他会给每一行读取的数据加锁，会导致大量超时和锁竞争的问题。</li></ul></li></ul><h2 id="分表后非sharding-key的查询怎么处理，分表后的排序？"><a href="#分表后非sharding-key的查询怎么处理，分表后的排序？" class="headerlink" title="分表后非sharding_key的查询怎么处理，分表后的排序？"></a>分表后非sharding_key的查询怎么处理，分表后的排序？</h2><ol><li>可以做一个mapping表，比如这时候商家要查询订单列表怎么办呢？不带user_id查询的话你总不能扫全表吧？所以我们可以做一个映射关系表，保存商家和用户的关系，查询的时候先通过商家查询到用户列表，再通过user_id去查询。</li><li>宽表，对数据实时性要求不是很高的场景，比如查询订单列表，可以把订单表同步到离线（实时）数仓，再基于数仓去做成一张宽表，再基于其他如es提供查询服务。</li><li>数据量不是很大的话，比如后台的一些查询之类的，也可以通过多线程扫表，然后再聚合结果的方式来做。或者异步的形式也是可以的。</li></ol><h2 id="Mysql主从同步原理"><a href="#Mysql主从同步原理" class="headerlink" title="Mysql主从同步原理"></a>Mysql主从同步原理</h2><ul><li>主节点 binlog，主从复制的基础是主库记录数据库的所有变更记录到 binlog。binlog 是数据库服务器启动的那一刻起，保存所有修改数据库结构或内容的一个文件。</li><li>主节点 log dump 线程，当 binlog 有变动时，log dump 线程读取其内容并发送给从节点。</li><li>从节点 I&#x2F;O线程接收 binlog 内容，并将其写入到 relay log 文件中。</li><li>从节点的SQL 线程读取 relay log 文件内容对数据更新进行重放，最终保证主从数据库的一致性。</li></ul><h2 id="简述MyISAM和InnoDB的区别"><a href="#简述MyISAM和InnoDB的区别" class="headerlink" title="简述MyISAM和InnoDB的区别"></a>简述MyISAM和InnoDB的区别</h2><ul><li>MyISAM<ul><li>不支持事务，但是每次查询都是原子的；</li><li>支持表级锁，即每次操作是对整个表加锁；</li><li>存储表的总行数；</li><li>一个MYISAM表有三个文件：索引文件、表结构文件、数据文件；</li><li>采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。</li></ul></li><li>InnoDb<ul><li>支持ACID的事务，支持事务的四种隔离级别；</li><li>支持行级锁及外键约束：因此可以支持写并发；</li><li>不存储总行数；</li><li>一个InnoDb引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G），受操作系统文件大小的限制；</li><li>主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。</li></ul></li></ul><h2 id="简述Mysql中索引类型及对数据库的性能的影响"><a href="#简述Mysql中索引类型及对数据库的性能的影响" class="headerlink" title="简述Mysql中索引类型及对数据库的性能的影响"></a>简述Mysql中索引类型及对数据库的性能的影响</h2><ul><li>普通索引：允许被索引的数据列包含重复的值。</li><li>唯一索引：可以保证数据记录的唯一性。</li><li>主键：是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。</li><li>联合索引：索引可以覆盖多个数据列，如像INDEX(columnA, columnB)索引。</li><li>全文索引：通过建立<code>倒排索引</code>,可以极大的提升检索效率,解决判断字段是否包含的问题，是目前搜索引擎使用的一种关键技术。可以通过ALTER TABLE table_name ADD FULLTEXT (column);创建全文索引</li></ul><h2 id="Explain语句结果中各个字段分表表示什么"><a href="#Explain语句结果中各个字段分表表示什么" class="headerlink" title="Explain语句结果中各个字段分表表示什么"></a>Explain语句结果中各个字段分表表示什么</h2><ul><li>id：查询语句中每出现一个SELECT关键字，MySQL就会为它分配一个唯一的id值，某些子查询会被优化为join查询，那么出现的id会一样</li><li>select_type：SELECT关键字对应的那个查询的类型</li><li>table：表名</li><li>partitions：匹配的分区信息</li><li>type：针对单表的查询方式（全表扫描、索引）</li><li>possible_keys：可能用到的索引</li><li>key：实际上使用的索引</li><li>key_len：实际使用到的索引长度</li><li>ref：当使用索引列等值查询时，与索引列进行等值匹配的对象信息</li><li>rows：预估的需要读取的记录条数</li><li>filtered：某个表经过搜索条件过滤后剩余记录条数的百分比</li><li>Extra：一些额外的信息，比如排序等</li></ul><h2 id="索引覆盖是什么"><a href="#索引覆盖是什么" class="headerlink" title="索引覆盖是什么"></a>索引覆盖是什么</h2><ul><li>索引覆盖就是一个SQL在执行时，可以利用索引来快速查找，并且此SQL所要查询的字段在当前索引对应的字段中都包含了，那么就表示此SQL走完索引后不用回表了，所需要的字段都在当前索引的叶子节点上存在，可以直接作为结果返回了</li></ul><h2 id="最左前缀原则是什么"><a href="#最左前缀原则是什么" class="headerlink" title="最左前缀原则是什么"></a>最左前缀原则是什么</h2><ul><li>当一个SQL想要利用索引是，就一定要提供该索引所对应的字段中最左边的字段，也就是排在最前面的字段，比如针对a,b,c三个字段建立了一个联合索引，那么在写一个sql时就一定要提供a字段的条件，这样才能用到联合索引，这是由于在建立a,b,c三个字段的联合索引时，底层的B+树是按照a,b,c三个字段从左往右去比较大小进行排序的，所以如果想要利用B+树进行快速查找也得符合这个规则</li></ul><h2 id="Innodb是如何实现事务的"><a href="#Innodb是如何实现事务的" class="headerlink" title="Innodb是如何实现事务的"></a>Innodb是如何实现事务的</h2><ol><li>Innodb在收到一个update语句后，会先根据条件找到数据所在的页，并将该页缓存在Buffer Pool中</li><li>执行update语句，修改Buffer Pool中的数据，也就是内存中的数据</li><li>针对update语句生成一个RedoLog对象，并存入LogBuffer中</li><li>针对update语句生成undolog日志，用于事务回滚</li><li>如果事务提交，那么则把RedoLog对象进行持久化，后续还有其他机制将Buffer Pool中所修改的数据页持久化到磁盘中</li><li>如果事务回滚，则利用undolog日志进行回滚</li></ol><h2 id="B树和B-树的区别，为什么Mysql使用B-树"><a href="#B树和B-树的区别，为什么Mysql使用B-树" class="headerlink" title="B树和B+树的区别，为什么Mysql使用B+树"></a>B树和B+树的区别，为什么Mysql使用B+树</h2><ul><li>B树的特点：<ul><li><ol><li>节点排序</li></ol></li><li><ol start="2"><li>一个节点了可以存多个元素，多个元素也排序了</li></ol></li></ul></li><li>B+树的特点：<ol><li>拥有B树的特点</li><li>叶子节点之间有指针</li><li>非叶子节点上的元素在叶子节点上都冗余了，也就是叶子节点中存储了所有的元素，并且排好顺序</li></ol></li><li>Mysql索引使用的是B+树，因为索引是用来加快查询的，而B+树通过对数据进行排序所以是可以提高查询速度的，然后通过一个节点中可以存储多个元素，从而可以使得B+树的高度不会太高，在Mysql中一个Innodb页就是一个B+树节点，一个Innodb页默认16kb，所以一般情况下一颗两层的B+树可以存2000万行左右的数据，然后通过利用B+树叶子节点存储了所有数据并且进行了排序，并且叶子节点之间有指针，可以很好的支持全表扫描，范围查找等SQL语句。</li></ul><h2 id="Mysql锁有哪些，如何理解"><a href="#Mysql锁有哪些，如何理解" class="headerlink" title="Mysql锁有哪些，如何理解"></a>Mysql锁有哪些，如何理解</h2><ul><li>行锁：锁某行数据，锁粒度最小，并发度高</li><li>表锁：锁整张表，锁粒度最大，并发度低</li><li>间隙锁：锁的是一个区间</li><li>共享锁：也就是读锁，一个事务给某行数据加了读锁，其他事务也可以读，但是不能写</li><li>排它锁：也就是写锁，一个事务给某行数据加了写锁，其他事务不能读，也不能写</li><li>乐观锁：并不会真正的去锁某行记录，而是通过一个版本号来实现的</li><li>悲观锁：上面所的行锁、表锁等都是悲观锁</li></ul><h2 id="Mysql慢查询该如何优化？"><a href="#Mysql慢查询该如何优化？" class="headerlink" title="Mysql慢查询该如何优化？"></a>Mysql慢查询该如何优化？</h2><ol><li>检查是否走了索引，如果没有则优化SQL利用索引</li><li>检查所利用的索引，是否是最优索引</li><li>检查所查字段是否都是必须的，是否查询了过多字段，查出了多余数据</li><li>检查表中数据是否过多，是否应该进行分库分表了</li><li>检查数据库实例所在机器的性能配置，是否太低，是否可以适当增加资源</li></ol><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="什么是RDB和AOF"><a href="#什么是RDB和AOF" class="headerlink" title="什么是RDB和AOF"></a>什么是RDB和AOF</h2><ul><li>RDB：Redis DataBase，在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。<ul><li>优点：<ol><li>整个Redis数据库将只包含一个文件 dump.rdb，方便持久化。</li><li>容灾性好，方便备份。</li><li>性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能</li><li>相对于数据集大时，比 AOF 的启动效率更高。</li></ol></li><li>缺点：<ol><li>数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)</li><li>由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</li></ol></li></ul></li><li>AOF：Append Only File，以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录<ul><li>优点：<ol><li>数据安全，Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。。</li><li>通过 append 模式写文件，即使中途服务器宕机也不会破坏已经存在的内容，可以通过 redis-check-aof 工具解决数据一致性问题。</li><li>AOF 机制的 rewrite 模式。定期对AOF文件进行重写，以达到压缩的目的</li></ol></li><li>缺点：<ol><li>AOF 文件比 RDB 文件大，且恢复速度慢。</li><li>数据集大的时候，比 rdb 启动效率低。</li><li>运行效率没有RDB高</li></ol></li></ul></li><li>对比：AOF文件比RDB更新频率高，优先使用AOF还原数据，AOF比RDB更安全也更大，RDB性能比AOF好，如果两个都配了优先加载AOF。</li></ul><h2 id="Redis的过期键的删除策略"><a href="#Redis的过期键的删除策略" class="headerlink" title="Redis的过期键的删除策略"></a>Redis的过期键的删除策略</h2><ul><li>惰性过期 ：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</li><li>定期过期 ：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。</li></ul><h2 id="Redis线程模型、单线程快的原因"><a href="#Redis线程模型、单线程快的原因" class="headerlink" title="Redis线程模型、单线程快的原因"></a>Redis线程模型、单线程快的原因</h2><ul><li>Redis基于Reactor模式开发了网络事件处理器，这个处理器叫做文件事件处理器 file event handler。这个文件事件处理器，它是单线程的，所以 Redis 才叫做单线程的模型，它采用IO多路复用机制来同时监听多个Socket，根据Socket上的事件类型来选择对应的事件处理器来处理这个事件。可以实现高性能的网络通信模型，又可以跟内部其他单线程的模块进行对接，保证了 Redis 内部的线程模型的简单性。</li><li>文件事件处理器的结构包含4个部分：多个Socket、IO多路复用程序、文件事件分派器以及事件处理器（命令请求处理器、命令回复处理器、连接应答处理器等）。 多个 Socket 可能并发的产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用程序会监听多个 Socket，会将 Socket 放入一个队列中排队，每次从队列中取出一个 Socket 给事件分派器，事件分派器把 Socket 给对应的事件处理器。 然后一个 Socket 的事件处理完之后，IO多路复用程序才会将队列中的下一个 Socket 给事件分派器。文件事件分派器会根据每个 Socket 当前产生的事件，来选择对应的事件处理器来处理。</li><li>单线程快的原因：<ul><li>纯内存操作</li><li>核心是基于非阻塞的IO多路复用机制</li><li>单线程反而避免了多线程的频繁上下文切换带来的性能问题</li></ul></li></ul><h2 id="简述Redis事务实现"><a href="#简述Redis事务实现" class="headerlink" title="简述Redis事务实现"></a>简述Redis事务实现</h2><ol><li>事务开始： _MULTI_命令的执行，标识着一个事务的开始。_MULTI_命令会将客户端状态的<code>flags</code>属性中打开<code>REDIS_MULTI</code>标识来完成的。</li><li>命令入队： 当一个客户端切换到事务状态之后，服务器会根据这个客户端发送来的命令来执行不同的操作。如果客户端发送的命令为_MULTI_、<em>EXEC</em>、<em>WATCH</em>、_DISCARD_中的一个，立即执行这个命令，否则将命令放入一个事务队列里面，然后向客户端返回<code>QUEUED</code>回复<ul><li>如果客户端发送的命令为 EXEC、DISCARD、WATCH、MULTI 四个命令的其中一个，那么服务器立即执行这个命令。</li><li>如果客户端发送的是四个命令以外的其他命令，那么服务器并不立即执行这个命令。 首先检查此命令的格式是否正确，如果不正确，服务器会在客户端状态（redisClient）的 flags 属性关闭 REDIS_MULTI 标识，并且返回错误信息给客户端。 如果正确，将这个命令放入一个事务队列里面，然后向客户端返回 QUEUED 回复</li><li>事务队列是按照FIFO的方式保存入队的命令</li></ul></li><li>事务执行： 客户端发送 EXEC 命令，服务器执行 EXEC 命令逻辑<ul><li>如果客户端状态的 flags 属性不包含 REDIS_MULTI 标识，或者包含 REDIS_DIRTY_CAS 或者 REDIS_DIRTY_EXEC 标识，那么就直接取消事务的执行。</li><li>否则客户端处于事务状态（flags 有 REDIS_MULTI 标识），服务器会遍历客户端的事务队列，然后执行事务队列中的所有命令，最后将返回结果全部返回给客户端；</li></ul></li></ol><h2 id="Redis-主从复制的核心原理"><a href="#Redis-主从复制的核心原理" class="headerlink" title="Redis 主从复制的核心原理"></a>Redis 主从复制的核心原理</h2><ol><li>主节点通过bgsave命令fork子进程进行RDB持久化，该过程是非常消耗CPU、内存(页表复制)、硬盘IO的</li><li>主节点通过网络将RDB文件发送给从节点，对主从节点的带宽都会带来很大的消耗</li><li>从节点清空老数据、载入新RDB文件的过程是阻塞的，无法响应客户端的命令；如果从节点执行bgrewriteaof，也会带来额外的消耗<ol><li>复制偏移量：执行复制的双方，主从节点，分别会维护一个复制偏移量offset</li><li>复制积压缓冲区：主节点内部维护了一个固定长度的、先进先出(FIFO)队列 作为复制积压缓冲区，当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。</li></ol></li><li>服务器运行ID(runid)：每个Redis节点，都有其运行ID，运行ID由节点在启动时自动生成，主节点会将自己的运行ID发送给从节点，从节点会将主节点的运行ID存起来。 从节点Redis断开重连的时候，就是根据运行ID来判断同步的进度：<ul><li>如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)；</li><li>如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制。</li></ul></li></ol><h2 id="Redis有哪些数据结构？分别有哪些典型的应用场景？"><a href="#Redis有哪些数据结构？分别有哪些典型的应用场景？" class="headerlink" title="Redis有哪些数据结构？分别有哪些典型的应用场景？"></a>Redis有哪些数据结构？分别有哪些典型的应用场景？</h2><ol><li>字符串：可以用来做最简单的数据，可以缓存某个简单的字符串，也可以缓存某个json格式的字符串，Redis分布式锁的实现就利用了这种数据结构，还包括可以实现计数器、Session共享、分布式ID</li><li>哈希表：可以用来存储一些key-value对，更适合用来存储对象</li><li>列表：Redis的列表通过命令的组合，既可以当做栈，也可以当做队列来使用，可以用来缓存类似微信公众号、微博等消息流数据</li><li>集合：和列表类似，也可以存储多个元素，但是不能重复，集合可以进行交集、并集、差集操作，从而可以实现类似，我和某人共同关注的人、朋友圈点赞等功能</li><li>有序集合：集合是无序的，有序集合可以设置顺序，可以用来实现排行榜功能</li></ol><h2 id="Redis分布式锁底层是如何实现的？"><a href="#Redis分布式锁底层是如何实现的？" class="headerlink" title="Redis分布式锁底层是如何实现的？"></a>Redis分布式锁底层是如何实现的？</h2><ol><li>首先利用setnx来保证：如果key不存在才能获取到锁，如果key存在，则获取不到锁</li><li>然后还要利用lua脚本来保证多个redis操作的原子性</li><li>同时还要考虑到锁过期，所以需要额外的一个看门狗定时任务来监听锁是否需要续约</li><li>同时还要考虑到redis节点挂掉后的情况，所以需要采用红锁的方式来同时向N&#x2F;2+1个节点申请锁，都申请到了才证明获取锁成功，这样就算其中某个redis节点挂掉了，锁也不能被其他客户端获取到</li></ol><h2 id="Redis主从复制的核心原理"><a href="#Redis主从复制的核心原理" class="headerlink" title="Redis主从复制的核心原理"></a>Redis主从复制的核心原理</h2><ol><li>集群启动时，主从库间会先建立连接，为全量复制做准备</li><li>主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载，这个过程依赖于内存快照RDB</li><li>在主库将数据同步给从库的过程中，主库不会阻塞，仍然可以正常接收请求。否则，redis的服务就被中断了。但是，这些请求中的写操作并没有记录到刚刚生成的RDB文件中。为了保证主从库的数据一致性，主库会在内存中用专门的replication buffer，记录RDB文件生成收到的所有写操作。</li><li>最后，也就是第三个阶段，主库会把第二阶段执行过程中新收到的写命令，再发送给从库。具体的操作是，当主库完成RDB文件发送后，就会把此时replocation buffer中修改操作发送给从库，从库再执行这些操作。这样一来，主从库就实现同步了</li><li>后续主库和从库都可以处理客户端读操作，写操作只能交给主库处理，主库接收到写操作后，还会将写操作发送给从库，实现增量同步</li></ol><h2 id="Redis集群策略"><a href="#Redis集群策略" class="headerlink" title="Redis集群策略"></a>Redis集群策略</h2><ol><li>主从模式：这种模式比较简单，主库可以读写，并且会和从库进行数据同步，这种模式下，客户端直接连主库或某个从库，但是但主库或从库宕机后，客户端需要手动修改IP，另外，这种模式也比较难进行扩容，整个集群所能存储的数据受到某台机器的内存容量，所以不可能支持特大数据量</li><li>哨兵模式：这种模式在主从的基础上新增了哨兵节点，但主库节点宕机后，哨兵会发现主库节点宕机，然后在从库中选择一个库作为进的主库，另外哨兵也可以做集群，从而可以保证但某一个哨兵节点宕机后，还有其他哨兵节点可以继续工作，这种模式可以比较好的保证Redis集群的高可用，但是仍然不能很好的解决Redis的容量上限问题。</li><li>Cluster模式：Cluster模式是用得比较多的模式，它支持多主多从，这种模式会按照key进行槽位的分配，可以使得不同的key分散到不同的主节点上，利用这种模式可以使得整个集群支持更大的数据容量，同时每个主节点可以拥有自己的多个从节点，如果该主节点宕机，会从它的从节点中选举一个新的主节点。</li><li>对于这三种模式，如果Redis要存的数据量不大，可以选择哨兵模式，如果Redis要存的数据量大，并且需要持续的扩容，那么选择Cluster模式。</li></ol><h2 id="缓存穿透、缓存击穿、缓存雪崩分别是什么"><a href="#缓存穿透、缓存击穿、缓存雪崩分别是什么" class="headerlink" title="缓存穿透、缓存击穿、缓存雪崩分别是什么"></a>缓存穿透、缓存击穿、缓存雪崩分别是什么</h2><ol><li>缓存雪崩：如果缓存中某一时刻大批热点数据同时过期，那么就可能导致大量请求直接访问Mysql了，解决办法就是在过期时间上增加一点随机值，另外如果搭建一个高可用的Redis集群也是防止缓存雪崩的有效手段</li><li>缓存击穿：和缓存雪崩类似，缓存雪崩是大批热点数据失效，而缓存击穿是指某一个热点key突然失效，也导致了大量请求直接访问Mysql数据库，这就是缓存击穿，解决方案就是考虑这个热点key不设过期时间</li><li>缓存穿透：假如某一时刻访问redis的大量key都在redis中不存在（比如黑客故意伪造一些乱七八糟的key），那么也会给数据造成压力，这就是缓存穿透，解决方案是使用布隆过滤器，它的作用就是如果它认为一个key不存在，那么这个key就肯定不存在，所以可以在缓存之前加一层布隆过滤器来拦截不存在的key</li></ol><h2 id="Redis和Mysql如何保证数据一致"><a href="#Redis和Mysql如何保证数据一致" class="headerlink" title="Redis和Mysql如何保证数据一致"></a>Redis和Mysql如何保证数据一致</h2><ol><li>先更新Mysql，再更新Redis，如果更新Redis失败，可能仍然不一致</li><li>先删除Redis缓存数据，再更新Mysql，再次查询的时候在将数据添加到缓存中，这种方案能解决1方案的问题，但是在高并发下性能较低，而且仍然会出现数据不一致的问题，比如线程1删除了Redis缓存数据，正在更新Mysql，此时另外一个查询再查询，那么就会把Mysql中老数据又查到Redis中</li><li>延时双删，步骤是：先删除Redis缓存数据，再更新Mysql，延迟几百毫秒再删除Redis缓存数据，这样就算在更新Mysql时，有其他线程读了Mysql，把老数据读到了Redis中，那么也会被删除掉，从而把数据保持一致</li></ol><h2 id="Redis单线程为什么这么快"><a href="#Redis单线程为什么这么快" class="headerlink" title="Redis单线程为什么这么快"></a>Redis单线程为什么这么快</h2><ol><li>纯内存操作</li><li>核心是基于非阻塞的IO多路复用机制</li><li>单线程反而避免了多线程的频繁上下文切换带来的性能问题</li></ol><h2 id="简述Redis事务实现-1"><a href="#简述Redis事务实现-1" class="headerlink" title="简述Redis事务实现"></a>简述Redis事务实现</h2><ul><li>事务开始：MULTI命令的执行，标识着一个事务的开始。MULTI命令会将客户端状态的 flags属性中打开REDIS_MULTI标识来完成的。</li><li>命令入队：当一个客户端切换到事务状态之后，服务器会根据这个客户端发送来的命令来执行不同的操作。如果客 户端发送的命令为MULTI、EXEC、WATCH、DISCARD中的一个，立即执行这个命令，否则将命令放入一 个事务队列里面，然后向客户端返回QUEUED回复，如果客户端发送的命令为 EXEC、DISCARD、WATCH、MULTI 四个命令的其中一个，那么服务器立即执行这个命令。如果客户端发送的是四个命令以外的其他命令，那么服务器并不立即执行这个命令。首先检查此命令的格式是否正确，如果不正确，服务器会在客户端状态（redisClient）的 flags 属性关闭 REDIS_MULTI 标识，并且返回错误信息给客户端。如果正确，将这个命令放入一个事务队列里面，然后向客户端返回 QUEUED 回复事务队列是按照FIFO的方式保存入队的命令</li><li>事务执行：客户端发送 EXEC 命令，服务器执行 EXEC 命令逻辑。如果客户端状态的 flags 属性不包含 REDIS_MULTI 标识，或者包含 REDIS_DIRTY_CAS 或者REDIS_DIRTY_EXEC 标识，那么就直接取消事务的执行。 否则客户端处于事务状态（flags有 REDIS_MULTI 标识），服务器会遍历客户端的事务队列，然后执行事务队列中的所有命令，最后将返回结果全部返回给客户端；Redis不支持事务回滚机制，但是它会检查每一个事务中的命令是否错误。Redis事务不支持检查那些程序员自己逻辑错误。例如对 String 类型的数据库键执行对 HashMap 类型的操作！</li></ul><h1 id="分布式与微服务"><a href="#分布式与微服务" class="headerlink" title="分布式与微服务"></a>分布式与微服务</h1><h2 id="什么是CAP理论"><a href="#什么是CAP理论" class="headerlink" title="什么是CAP理论"></a>什么是CAP理论</h2><ul><li>分区容错性表示，一个系统虽然是分布式的，但是对外看上去应该是一个整体，不能由于分布式系统内部的某个结点挂点，或网络出现了故障，而导致系统对外出现异常。所以，对于分布式系统而言是一定要保证分区容错性的。</li><li>强一致性表示，一个分布式系统中各个结点之间能及时的同步数据，在数据同步过程中，是不能对外提供服务的，不然就会造成数据不一致，所以强一致性和可用性是不能同时满足的。</li><li>可用性表示，一个分布式系统对外要保证可用。</li></ul><h2 id="什么是BASE理论"><a href="#什么是BASE理论" class="headerlink" title="什么是BASE理论"></a>什么是BASE理论</h2><ol><li>BA：Basically Available，表示基本可用，表示可以允许一定程度的不可用，比如由于系统故障，请求时间变长，或者由于系统故障导致部分非核心功能不可用，都是允许的</li><li>S：Soft state：表示分布式系统可以处于一种中间状态，比如数据正在同步</li><li>E：Eventually consistent，表示最终一致性，不要求分布式系统数据实时达到一致，允许在经过一段时间后再达到一致，在达到一致过程中，系统也是可用的​</li></ol><h2 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h2><ul><li>RPC，表示远程过程调用，对于Java这种面试对象语言，也可以理解为远程方法调用，RPC调用和HTTP调用是有区别的，RPC表示的是一种调用远程方法的方式，可以使用HTTP协议、或直接基于TCP协议来实现RPC，在Java中，我们可以通过直接使用某个服务接口的代理对象来执行方法，而底层则通过构造HTTP请求来调用远端的方法，所以，有一种说法是RPC协议是HTTP协议之上的一种协议，也是可以理解的。</li></ul><h2 id="数据一致性模型有哪些"><a href="#数据一致性模型有哪些" class="headerlink" title="数据一致性模型有哪些"></a>数据一致性模型有哪些</h2><ul><li>强一致性：当更新操作完成之后，任何多个后续进程的访问都会返回最新的更新过的值，这种是对用户 最友好的，就是用户上一次写什么，下一次就保证能读到什么。根据 CAP理论，这种实现需要牺牲可用性。</li><li>弱一致性：系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后 可以读到。用户读到某一操作对系统数据的更新需要一段时间，我们称这段时间为“不一致性窗口”。</li><li>最终一致性：最终一致性是弱一致性的特例，强调的是所有的数据副本，在经过一段时间的同步之后， 最终都能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而 不需要实时保证系统数据的强一致性。到达最终一致性的时间 ，就是不一致窗口时间，在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。最终一致性模型根据其提供的不同保证可以划分为更多的模型，包括因果一致性和会话一致性等。</li></ul><h2 id="分布式ID是什么？有哪些解决方案？"><a href="#分布式ID是什么？有哪些解决方案？" class="headerlink" title="分布式ID是什么？有哪些解决方案？"></a>分布式ID是什么？有哪些解决方案？</h2><ol><li>uuid，这种方案复杂度最低，但是会影响存储空间和性能</li><li>利用单机数据库的自增主键，作为分布式ID的生成器，复杂度适中，ID长度较之uuid更短，但是受到单机数据库性能的限制，并发量大的时候，此方案也不是最优方案</li><li>利用redis、zookeeper的特性来生成id，比如redis的自增命令、zookeeper的顺序节点，这种方案和单机数据库(mysql)相比，性能有所提高，可以适当选用</li><li>雪花算法，一切问题如果能直接用算法解决，那就是最合适的，利用雪花算法也可以生成分布式ID，底层原理就是通过某台机器在某一毫秒内对某一个数字自增，这种方案也能保证分布式架构中的系统id唯一，但是只能保证趋势递增。业界存在tinyid、leaf等开源中间件实现了雪花算法。</li></ol><h2 id="分布式锁的使用场景是什么？有哪些实现方案？"><a href="#分布式锁的使用场景是什么？有哪些实现方案？" class="headerlink" title="分布式锁的使用场景是什么？有哪些实现方案？"></a>分布式锁的使用场景是什么？有哪些实现方案？</h2><ul><li>在单体架构中，多个线程都是属于同一个进程的，所以在线程并发执行时，遇到资源竞争时，可以利用ReentrantLock、synchronized等技术来作为锁，来控制共享资源的使用。</li><li>而在分布式架构中，多个线程是可能处于不同进程中的，而这些线程并发执行遇到资源竞争时，利用ReentrantLock、synchronized等技术是没办法来控制多个进程中的线程的，所以需要分布式锁，意思就是，需要一个分布式锁生成器，分布式系统中的应用程序都可以来使用这个生成器所提供的锁，从而达到多个进程中的线程使用同一把锁。</li><li>目前主流的分布式锁的实现方案有两种：<ol><li>zookeeper：利用的是zookeeper的临时节点、顺序节点、watch机制来实现的，zookeeper分布式锁的特点是高一致性，因为zookeeper保证的是CP，所以由它实现的分布式锁更可靠，不会出现混乱</li><li>redis：利用redis的setnx、lua脚本、消费订阅等机制来实现的，redis分布式锁的特点是高可用，因为redis保证的是AP，所以由它实现的分布式锁可能不可靠，不稳定（一旦redis中的数据出现了不一致），可能会出现多个客户端同时加到锁的情况</li></ol></li></ul><h2 id="什么是分布式事务？有哪些实现方案？"><a href="#什么是分布式事务？有哪些实现方案？" class="headerlink" title="什么是分布式事务？有哪些实现方案？"></a>什么是分布式事务？有哪些实现方案？</h2><ol><li>本地消息表：创建订单时，将减库存消息加入在本地事务中，一起提交到数据库存入本地消息表，然后调用库存系统，如果调用成功则修改本地消息状态为成功，如果调用库存系统失败，则由后台定时任务从本地消息表中取出未成功的消息，重试调用库存系统</li><li>消息队列：目前RocketMQ中支持事务消息，它的工作原理是：<ol><li>生产者订单系统先发送一条half消息到Broker，half消息对消费者而言是不可见的</li><li>再创建订单，根据创建订单成功与否，向Broker发送commit或rollback</li><li>并且生产者订单系统还可以提供Broker回调接口，当Broker发现一段时间half消息没有收到任何操作命令，则会主动调此接口来查询订单是否创建成功</li><li>一旦half消息commit了，消费者库存系统就会来消费，如果消费成功，则消息销毁，分布式事务成功结束</li><li>如果消费失败，则根据重试策略进行重试，最后还失败则进入死信队列，等待进一步处理</li></ol></li></ol><h2 id="负载均衡算法有哪些"><a href="#负载均衡算法有哪些" class="headerlink" title="负载均衡算法有哪些"></a>负载均衡算法有哪些</h2><ol><li>轮询法： 将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。</li><li>随机法： 通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务端的次数增多，其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。</li><li>源地址哈希法： 源地址哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。</li><li>加权轮询法： 不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</li><li>加权随机法： 与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。</li><li>最小连接数法： 最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。</li></ol><h2 id="分布式架构下，Session-共享有什么方案"><a href="#分布式架构下，Session-共享有什么方案" class="headerlink" title="分布式架构下，Session 共享有什么方案"></a>分布式架构下，Session 共享有什么方案</h2><ol><li>采用无状态服务，抛弃session</li><li>存入cookie（有安全风险）</li><li>服务器之间进行 Session 同步，这样可以保证每个服务器上都有全部的 Session 信息，不过当服务器数量比较多的时候，同步是会有延迟甚至同步失败；</li><li>IP 绑定策略：使用 Nginx （或其他复杂均衡软硬件）中的 IP 绑定策略，同一个 IP 只能在指定的同一个机器访问，但是这样做失去了负载均衡的意义，当挂掉一台服务器的时候，会影响一批用户的使用，风险很大；</li><li>使用 Redis 存储：把 Session 放到 Redis 中存储，虽然架构上变得复杂，并且需要多访问一次 Redis ，但是这种方案带来的好处也是很大的：<ul><li>实现了 Session 共享；</li><li>可以水平扩展（增加 Redis 服务器）；</li><li>服务器重启 Session 不丢失（不过也要注意 Session 在 Redis 中的刷新&#x2F;失效机制）；</li><li>不仅可以跨服务器 Session 共享，甚至可以跨平台（例如网页端和 APP 端）。</li></ul></li></ol><h2 id="如何实现接口的幂等性"><a href="#如何实现接口的幂等性" class="headerlink" title="如何实现接口的幂等性"></a>如何实现接口的幂等性</h2><ul><li>唯一id。每次操作，都根据操作和内容生成唯一的id，在执行之前先判断id是否存在，如果不存在则执行后续操作，并且保存到数据库或者redis等。</li><li>服务端提供发送token的接口，业务调用接口前先获取token,然后调用业务接口请求时，把token携带过去,务器判断token是否存在redis中，存在表示第一次请求，可以继续执行业务，执行业务完成后，最后需要把redis中的token删除</li><li>建去重表。将业务中有唯一标识的字段保存到去重表，如果表中存在，则表示已经处理过了<br>版本控制。增加版本号，当版本号符合时，才能更新数据</li><li>状态控制。例如订单有状态已支付 未支付 支付中 支付失败，当处于未支付的时候才允许修改为支付中等</li></ul><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><ul><li>eureka：AP设计（高可用），目标是一个服务注册发现系统，专门用于微服务的服务发现注册。</li></ul><h2 id="存储拆分后如何解决唯一主键问题"><a href="#存储拆分后如何解决唯一主键问题" class="headerlink" title="存储拆分后如何解决唯一主键问题"></a>存储拆分后如何解决唯一主键问题</h2><ul><li>UUID：简单、性能好，没有顺序，没有业务含义，存在泄漏mac地址的风险</li><li>数据库主键：实现简单，单调递增，具有一定的业务可读性，强依赖db、存在性能瓶颈，存在暴露业务 信息的风险</li><li>redis，mongodb，zk等中间件：增加了系统的复杂度和稳定性</li><li>雪花算法</li></ul><h2 id="雪花算法原理"><a href="#雪花算法原理" class="headerlink" title="雪花算法原理"></a>雪花算法原理</h2><ul><li>优点：每个毫秒值包含的ID值很多，不够可以变动位数来增加，性能佳（依赖workId的实现）。时间戳值在高位，中间是固定的机器码，自增的序列在低位，整个ID是趋势递增的。能够根据业务场景数据库节点布置灵活调整bit位划分，灵活度高。</li><li>缺点：强依赖于机器时钟，如果时钟回拨，会导致重复的ID生成，所以一般基于此的算法发现时钟回 拨，都会抛异常处理，阻止ID生成，这可能导致服务不可用。</li></ul><h2 id="如何解决不使用分区键的查询问题"><a href="#如何解决不使用分区键的查询问题" class="headerlink" title="如何解决不使用分区键的查询问题"></a>如何解决不使用分区键的查询问题</h2><ul><li>映射：将查询条件的字段与分区键进行映射，建一张单独的表维护(使用覆盖索引)或者在缓存中维 护</li><li>基因法：分区键的后x个bit位由查询字段进行hash后占用，分区键直接取x个bit位获取分区，查询字段进行hash获取分区，适合非分区键查询字段只有一个的情况</li><li>冗余：查询字段冗余存储</li></ul><h2 id="Spring-Cloud有哪些常用组件，作用是什么？"><a href="#Spring-Cloud有哪些常用组件，作用是什么？" class="headerlink" title="Spring Cloud有哪些常用组件，作用是什么？"></a>Spring Cloud有哪些常用组件，作用是什么？</h2><ol><li>Eureka：注册中心</li><li>Nacos：注册中心、配置中心</li><li>Consul：注册中心、配置中心</li><li>Spring Cloud Config：配置中心</li><li>Feign&#x2F;OpenFeign：RPC调用</li><li>Kong：服务网关</li><li>Zuul：服务网关</li><li>Spring Cloud Gateway：服务网关</li><li>Ribbon：负载均衡</li><li>Spring CLoud Sleuth：链路追踪</li><li>Zipkin：链路追踪</li><li>Seata：分布式事务</li><li>Dubbo：RPC调用</li><li>Sentinel：服务熔断</li><li>Hystrix：服务熔断</li></ol><h2 id="如何避免缓存穿透、缓存击穿、缓存雪崩？"><a href="#如何避免缓存穿透、缓存击穿、缓存雪崩？" class="headerlink" title="如何避免缓存穿透、缓存击穿、缓存雪崩？"></a>如何避免缓存穿透、缓存击穿、缓存雪崩？</h2><ul><li>缓存雪崩：是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。解决方案：<ul><li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li><li>给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓存。</li><li>缓存预热互斥锁</li></ul></li><li>缓存穿透：是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承 受大量请求而崩掉。解决方案：<ul><li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;&#x3D;0的直接拦截；</li><li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有 效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户 反复用同一个id暴力攻击</li><li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力</li></ul></li><li>缓存击穿：是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪 崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。解决方案：<ul><li>设置热点数据永远不过期。加互斥锁</li></ul></li></ul><h2 id="分布式系统中常用的缓存方案有哪些"><a href="#分布式系统中常用的缓存方案有哪些" class="headerlink" title="分布式系统中常用的缓存方案有哪些"></a>分布式系统中常用的缓存方案有哪些</h2><ul><li>客户端缓存：页面和浏览器缓存，APP缓存，H5缓存，localStorage 和 sessionStorage CDN缓存：内容存储：数据的缓存，内容分发：负载均衡</li><li>nginx缓存：静态资源</li><li>服务端缓存：本地缓存，外部缓存</li><li>数据库缓存：持久层缓存（mybatis，hibernate多级缓存），mysql查询缓存 操作系统缓存：PageCache、BufferCache</li></ul><h2 id="缓存过期都有哪些策略？"><a href="#缓存过期都有哪些策略？" class="headerlink" title="缓存过期都有哪些策略？"></a>缓存过期都有哪些策略？</h2><ul><li>定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立 即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量</li><li>惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，但是很消耗内存、许多的过期数据都还存在内存中。极端情况可能出现大量的过期key没有 再次被访问，从而不会被清除，占用大量内存。</li><li>定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key（是随机的）， 并清除其中已过期的key。该策略是定时过期和惰性过期的折中方案。通过调整定时扫描的时间间隔和 每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。</li><li>分桶策略：定期过期的优化，将过期时间点相近的key放在一起，按时间扫描分桶。</li></ul><h2 id="常见的缓存淘汰算法"><a href="#常见的缓存淘汰算法" class="headerlink" title="常见的缓存淘汰算法"></a>常见的缓存淘汰算法</h2><ul><li>FIFO（First In First Out，先进先出），根据缓存被存储的时间，离当前最远的数据优先被淘汰；</li><li>LRU（LeastRecentlyUsed，最近最少使用），根据最近被使用的时间，离当前最远的数据优先被淘汰；</li><li>LFU（LeastFrequentlyUsed，最不经常使用），在一段时间内，缓存数据被使用次数最少的会被淘汰。</li></ul><h2 id="布隆过滤器原理，优缺点"><a href="#布隆过滤器原理，优缺点" class="headerlink" title="布隆过滤器原理，优缺点"></a>布隆过滤器原理，优缺点</h2><ul><li>位图：int[10]，每个int类型的整数是4*8&#x3D;32个bit，则int[10]一共有320 bit，每个bit非0即1，初始化时都是0</li><li>添加数据时：将数据进行hash得到hash值，对应到bit位，将该bit改为1，hash函数可以定义多个，则 一个数据添加会将多个（hash函数个数）bit改为1，多个hash函数的目的是减少hash碰撞的概率</li><li>查询数据：hash函数计算得到hash值，对应到bit中，如果有一个为0，则说明数据不在bit中，如果都为1，则该数据可能在bit中</li><li>优点：<ul><li>占用内存小</li><li>增加和查询元素的时间复杂度为：O(K), (K为哈希函数的个数，一般比较小)，与数据量大小无关哈希函数相互之间没有关系，方便硬件并行运算</li><li>布隆过滤器不需要存储元素本身，在某些对保密要求比较严格的场合有很大优势 数据量很大时，布隆过滤器可以表示全集</li><li>使用同一组散列函数的布隆过滤器可以进行交、并、差运算</li></ul></li><li>缺点：<ul><li>误判率，即存在假阳性(False Position)，不能准确判断元素是否在集合中不能获取元素本身</li><li>一般情况下不能从布隆过滤器中删除元素</li></ul></li></ul><h2 id="分布式缓存寻址算法"><a href="#分布式缓存寻址算法" class="headerlink" title="分布式缓存寻址算法"></a>分布式缓存寻址算法</h2><ul><li>hash算法：根据key进行hash函数运算、结果对分片数取模，确定分片 适合固定分片数的场景，扩展分片或者减少分片时，所有数据都需要重新计算分片、存储</li><li>一致性hash：将整个hash值得区间组织成一个闭合的圆环，计算每台服务器的hash值、映射到圆环中。使用相同的hash算法计算数据的hash值，映射到圆环，顺时针寻找，找到的第一个服务器就是数据存储的服务器。新增及减少节点时只会影响节点到他逆时针最近的一个服务器之间的值 存在hash环倾斜的问题，即服务器分布不均匀，可以通过虚拟节点解决</li><li>hash slot：将数据与服务器隔离开，数据与slot映射，slot与服务器映射，数据进行hash决定存放的slot，新增及删除节点时，将slot进行迁移即可</li></ul><h2 id="Spring-Cloud？"><a href="#Spring-Cloud？" class="headerlink" title="Spring Cloud？"></a>Spring Cloud？</h2><ul><li>Spring Cloud是一个微服务框架，提供了微服务领域中的很多功能组件，Dubbo一开始是一个RPC调用框架，核心是解决服务调用间的问题，Spring Cloud是一个大而全的框架</li></ul><h2 id="什么是服务雪崩？什么是服务限流？"><a href="#什么是服务雪崩？什么是服务限流？" class="headerlink" title="什么是服务雪崩？什么是服务限流？"></a>什么是服务雪崩？什么是服务限流？</h2><ol><li>当服务A调用服务B，服务B调用C，此时大量请求突然请求服务A，假如服务A本身能抗住这些请求，但是如果服务C抗不住，导致服务C请求堆积，从而服务B请求堆积，从而服务A不可用，这就是服务雪崩，解决方式就是服务降级和服务熔断。</li><li>服务限流是指在高并发请求下，为了保护系统，可以对访问服务的请求进行数量上的限制，从而防止系统不被大量请求压垮，在秒杀中，限流是非常重要的。</li></ol><h2 id="什么是服务熔断？什么是服务降级？区别是什么？"><a href="#什么是服务熔断？什么是服务降级？区别是什么？" class="headerlink" title="什么是服务熔断？什么是服务降级？区别是什么？"></a>什么是服务熔断？什么是服务降级？区别是什么？</h2><ul><li>服务熔断是指，当服务A调用的某个服务B不可用时，上游服务A为了保证自己不受影响，从而不再调用服务B，直接返回一个结果，减轻服务A和服务B的压力，直到服务B恢复。</li><li>服务降级是指，当发现系统压力过载时，可以通过关闭某个服务，或限流某个服务来减轻系统压力，这就是服务降级。</li><li>相同点：<ol><li>都是为了防止系统崩溃</li><li>都让用户体验到某些功能暂时不可用</li></ol></li><li>不同点：熔断是下游服务故障触发的，降级是为了降低系统负载</li></ul><h2 id="SOA、分布式、微服务之间有什么关系和区别？"><a href="#SOA、分布式、微服务之间有什么关系和区别？" class="headerlink" title="SOA、分布式、微服务之间有什么关系和区别？"></a>SOA、分布式、微服务之间有什么关系和区别？</h2><ol><li>分布式架构是指将单体架构中的各个部分拆分，然后部署不同的机器或进程中去，SOA和微服务基本上都是分布式架构的</li><li>SOA是一种面向服务的架构，系统的所有服务都注册在总线上，当调用服务时，从总线上查找服务信息，然后调用</li><li>微服务是一种更彻底的面向服务的架构，将系统中各个功能个体抽成一个个小的应用程序，基本保持一个应用对应的一个服务的架构</li></ol><h2 id="怎么拆分微服务？"><a href="#怎么拆分微服务？" class="headerlink" title="怎么拆分微服务？"></a>怎么拆分微服务？</h2><ol><li>微服务之间尽量不要有业务交叉。</li><li>微服务之前只能通过接口进行服务调用，而不能绕过接口直接访问对方的数据。</li><li>高内聚，低耦合。</li></ol><h2 id="怎样设计出高内聚、低耦合的微服务？"><a href="#怎样设计出高内聚、低耦合的微服务？" class="headerlink" title="怎样设计出高内聚、低耦合的微服务？"></a>怎样设计出高内聚、低耦合的微服务？</h2><ul><li>高内聚低耦合，是一种从上而下指导微服务设计的方法。实现高内聚低耦合的工具主要有 同步的接口调用和异步的事件驱动 两种方式。</li></ul><h2 id="有没有了解过DDD领域驱动设计？"><a href="#有没有了解过DDD领域驱动设计？" class="headerlink" title="有没有了解过DDD领域驱动设计？"></a>有没有了解过DDD领域驱动设计？</h2><ul><li>什么是DDD： 在2004年，由Eric Evans提出了， DDD是面对软件复杂之道。Domain-Driven- Design –Tackling Complexity in the Heart of Software</li><li>大泥团： 不利于微服务的拆分。大泥团结构拆分出来的微服务依然是泥团机构，当服务业务逐渐复杂，这个泥团又会膨胀成为大泥团。</li><li>DDD只是一种方法论，没有一个稳定的技术框架。DDD要求领域是跟技术无关、跟存储无关、跟通信无关。</li></ul><h2 id="什么是中台？"><a href="#什么是中台？" class="headerlink" title="什么是中台？"></a>什么是中台？</h2><ul><li>所谓中台，就是将各个业务线中可以复用的一些功能抽取出来，剥离个性，提取共性，形成一些可复用的组件。</li><li>大体上，中台可以分为三类 业务中台、数据中台和技术中台。大数据杀熟-数据中台</li><li>中台跟DDD结合： DDD会通过限界上下文将系统拆分成一个一个的领域， 而这种限界上下文，天生就成了中台之间的逻辑屏障。</li><li>DDD在技术与资源调度方面都能够给中台建设提供不错的指导。</li><li>DDD分为战略设计和战术设计。 上层的战略设计能够很好的指导中台划分，下层的战术设计能够很好的指导微服务搭建。</li></ul><h2 id="你的项目中是怎么保证微服务敏捷开发的？"><a href="#你的项目中是怎么保证微服务敏捷开发的？" class="headerlink" title="你的项目中是怎么保证微服务敏捷开发的？"></a>你的项目中是怎么保证微服务敏捷开发的？</h2><ul><li>开发运维一体化。</li><li>敏捷开发： 目的就是为了提高团队的交付效率，快速迭代，快速试错</li><li>每个月固定发布新版本，以分支的形式保存到代码仓库中。快速入职。任务面板、站立会议。团队人员灵活流动，同时形成各个专家代表</li><li>测试环境- 生产环境 -开发测试环境SIT-集成测试环境-压测环境STR-预投产环境-生产环境PRD</li><li>晨会、周会、需求拆分会</li></ul><h2 id="如何进行产品选型？"><a href="#如何进行产品选型？" class="headerlink" title="如何进行产品选型？"></a>如何进行产品选型？</h2><ul><li>Kafka：<ul><li>优点： 吞吐量非常大，性能非常好，集群高可用。</li><li>缺点：会丢数据，功能比较单一。</li><li>使用场景：日志分析、大数据采集</li></ul></li><li>RabbitMQ：<ul><li>优点： 消息可靠性高，功能全面。</li><li>缺点：吞吐量比较低，消息积累会严重影响性能。erlang语言不好定制。</li><li>使用场景：小规模场景。</li></ul></li><li>RocketMQ：<ul><li>优点：高吞吐、高性能、高可用，功能非常全面。</li><li>缺点：开源版功能不如云上商业版。官方文档和周边生态还不够成熟。客户端只支持java。</li><li>使用场景：几乎是全场景。</li></ul></li></ul><h2 id="简述RabbitMQ的架构设计"><a href="#简述RabbitMQ的架构设计" class="headerlink" title="简述RabbitMQ的架构设计"></a>简述RabbitMQ的架构设计</h2><ul><li>Broker ：rabbitmq的服务节</li><li>Queue ：队列，是RabbitMQ的内部对象，用于存储消息。RabbitMQ中消息只能存储在队列中。生产者投递消息到队列，消费者从队列中获取消息并消费。多个消费者可以订阅同一个队列，这时队列中的消息会被平均分摊(轮询)给多个消费者进行消费，而不是每个消费者都收到所有的消息进行消费。(注意：RabbitMQ不支持队列层面的广播消费，如果需要广播消费，可以采用一个交换器通过路由Key绑定多个队列，由多个消费者来订阅这些队列的方式。</li><li>Exchange ：交换器。生产者将消息发送到Exchange，由交换器将消息路由到一个或多个队列中。如果路由不到，或返回给生产者，或直接丢弃，或做其它处理。</li><li>RoutingKey ：路由Key。生产者将消息发送给交换器的时候，一般会指定一个RoutingKey，用来指定这个消息的路由规则。这个路由Key需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效。在交换器类型和绑定键固定的情况下，生产者可以在发送消息给交换器时通过指定RoutingKey来决定消息流向哪里。</li><li>Binding ：通过绑定将交换器和队列关联起来，在绑定的时候一般会指定一个绑定键，这样RabbitMQ就可以指定如何正确的路由到队列了。</li><li>交换器和队列实际上是多对多关系。就像关系数据库中的两张表。他们通过BindingKey做关联(多对多关系表)。在投递消息时，可以通过Exchange和RoutingKey(对应BindingKey)就可以找到相对应的队列。</li><li>信道 ：信道是建立在Connection 之上的虚拟连接。当应用程序与Rabbit Broker建立TCP连接的时候，客户端紧接着可以创建一个AMQP 信道(Channel) ，每个信道都会被指派一个唯一的D。RabbitMQ 处理的每条AMQP 指令都是通过信道完成的。信道就像电缆里的光纤束。一条电缆内含有许多光纤束，允许所有的连接通过多条光线束进行传输和接收。</li></ul><h2 id="Kafka是什么"><a href="#Kafka是什么" class="headerlink" title="Kafka是什么"></a>Kafka是什么</h2><ul><li>Kafka 是一种高吞吐量、分布式、基于发布&#x2F;订阅的消息系统，最初由 LinkedIn 公司开发，使用Scala 语言编写，目前是 Apache 的开源项目。broker：Kafka 服务器，负责消息存储和转发topic：消息类别， Kafka 按照 topic 来分类消息partition：topic 的分区，一个 topic 可以包含多个 partition， topic 消息保存在各个partition 上oﬀset：消息在日志中的位置，可以理解是消息在 partition 上的偏移量，也是代表该消息的唯一序号Producer：消息生产者Consumer：消息消费者Consumer Group：消费者分组，每个 Consumer 必须属于一个 groupZookeeper：保存着集群 broker、 topic、 partition 等 meta 数据；另外，还负责 broker 故障发现， partition leader 选举，负载均衡等功能</li></ul><h2 id="Kafka为什么吞吐量高"><a href="#Kafka为什么吞吐量高" class="headerlink" title="Kafka为什么吞吐量高"></a>Kafka为什么吞吐量高</h2><ul><li>Kafka的生产者采用的是异步发送消息机制，当发送一条消息时，消息并没有发送到Broker而是缓存起来，然后直接向业务返回成功，当缓存的消息达到一定数量时再批量发送给Broker。这种做法减少了网络io，从而提高了消息发送的吞吐量，但是如果消息生产者宕机，会导致消息丢失，业务出错，所以理论上kafka利用此机制提高了性能却降低了可靠性。</li></ul><h2 id="Kafka的Pull和Push分别有什么优缺点"><a href="#Kafka的Pull和Push分别有什么优缺点" class="headerlink" title="Kafka的Pull和Push分别有什么优缺点"></a>Kafka的Pull和Push分别有什么优缺点</h2><ol><li>pull表示消费者主动拉取，可以批量拉取，也可以单条拉取，所以pull可以由消费者自己控制，根据自己的消息处理能力来进行控制，但是消费者不能及时知道是否有消息，可能会拉到的消息为空</li><li>push表示Broker主动给消费者推送消息，所以肯定是有消息时才会推送，但是消费者不能按自己的能力来消费消息，推过来多少消息，消费者就得消费多少消息，所以可能会造成网络堵塞，消费者压力大等问题</li></ol><h2 id="为什么要使用-kafka，为什么要使用消息队列"><a href="#为什么要使用-kafka，为什么要使用消息队列" class="headerlink" title="为什么要使用 kafka，为什么要使用消息队列?"></a>为什么要使用 kafka，为什么要使用消息队列?</h2><ul><li>缓冲和削峰：上游数据时有突发流量，下游可能扛不住，或者下游没有足够多的机器来保证冗余，kafka在中间可以起到一个缓冲的作用，把消息暂存在kafka中，下游服务就可以按照自己的节奏进行慢慢处理。</li><li>解耦和扩展性 ：项目开始的时候，并不能确定具体需求。消息队列可以作为一个接口层，解耦重要的业务流程。只需要遵守约定，针对数据编程即可获取扩展能力。</li><li>冗余：可以采用一对多的方式，一个生产者发布消息，可以被多个订阅topic的服务消费到，供多个毫无关联的业务使用。</li><li>健壮性：消息队列可以堆积请求，所以消费端业务即使短时间死掉，也不会影响主要业务的正常进行。</li><li>异步通信：很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</li></ul><h2 id="Kafka中的ISR、AR又代表什么？ISR的伸缩又指什么"><a href="#Kafka中的ISR、AR又代表什么？ISR的伸缩又指什么" class="headerlink" title="Kafka中的ISR、AR又代表什么？ISR的伸缩又指什么"></a>Kafka中的ISR、AR又代表什么？ISR的伸缩又指什么</h2><ul><li>ISR:In-Sync Replicas副本同步队列</li><li>AR:Assigned Replicas所有副本ISR是由leader维护，follower从leader同步数据有一些延迟（包括延迟时间replica.lag.time.max.ms和延迟条数replica.lag.max.messages两个维度, 当前最新的版本0.10.x中只支持replica.lag.time.max.ms这个维度），任意一个超过阈值都会把follower剔除出ISR, 存入OSR（Outof-Sync Replicas）列表，新加入的follower也会先存放在OSR中</li><li>AR&#x3D;ISR+OSR</li></ul><h2 id="Kafka高效文件存储设计特点："><a href="#Kafka高效文件存储设计特点：" class="headerlink" title="Kafka高效文件存储设计特点："></a>Kafka高效文件存储设计特点：</h2><ol><li>Kafka 把 topic 中一个 parition 大文件分成多个小文件段，通过多个小文件段，就容易定期清除或删除已经消费完文件，减少磁盘占用。</li><li>通过索引信息可以快速定位 message 和确定 response 的最大大小。</li><li>通过 index 元数据全部映射到 memory，可以避免 segment file 的 IO 磁盘操作。</li><li>通过索引文件稀疏存储，可以大幅降低 index 文件元数据占用空间大小。</li></ol><h2 id="Kafka与传统消息系统之间有三个关键区别"><a href="#Kafka与传统消息系统之间有三个关键区别" class="headerlink" title="Kafka与传统消息系统之间有三个关键区别"></a>Kafka与传统消息系统之间有三个关键区别</h2><ol><li>Kafka 持久化日志，这些日志可以被重复读取和无限期保留</li><li>Kafka 是一个分布式系统：它以集群的方式运行，可以灵活伸缩，在内部通过复制数据提升容错能力和高可用性</li><li>Kafka 支持实时的流式处理</li></ol><h2 id="Kafka创建-Topic-时如何将分区放置到不同的-Broker-中"><a href="#Kafka创建-Topic-时如何将分区放置到不同的-Broker-中" class="headerlink" title="Kafka创建 Topic 时如何将分区放置到不同的 Broker 中"></a>Kafka创建 Topic 时如何将分区放置到不同的 Broker 中</h2><ol><li>​副本因子不能大于 Broker 的个数；</li><li>​第一个分区（编号为 0）的第一个副本放置位置是随机从 brokerList 选择的；</li><li>​其他分区的第一个副本放置位置相对于第 0 个分区依次往后移。也就是如果我们有 5 个Broker， 5 个分区，假设第一个分区放在第四个 Broker 上，那么第二个分区将会放在第五个 Broker 上；第三个分区将会放在第一个 Broker 上；第四个分区将会放在第二个Broker 上，依次类推；</li><li>​剩余的副本相对于第一个副本放置位置其实是由 nextReplicaShift 决定的，而这个数也是随机产生的</li></ol><h2 id="Kafka的消费者如何消费数据"><a href="#Kafka的消费者如何消费数据" class="headerlink" title="Kafka的消费者如何消费数据"></a>Kafka的消费者如何消费数据</h2><ul><li>消费者每次消费数据的时候，消费者都会记录消费的物理偏移量（ offset）的位置等到下次消费时，他会接着上次位置继续消费</li></ul><h2 id="Kafka消费者负载均衡策略"><a href="#Kafka消费者负载均衡策略" class="headerlink" title="Kafka消费者负载均衡策略"></a>Kafka消费者负载均衡策略</h2><ul><li>一个消费者组中的一个分片对应一个消费者成员，他能保证每个消费者成员都能访问，如果组中成员太多会有空闲的成员</li></ul><h2 id="kafaka生产数据时数据的分组策略"><a href="#kafaka生产数据时数据的分组策略" class="headerlink" title="kafaka生产数据时数据的分组策略"></a>kafaka生产数据时数据的分组策略</h2><ul><li>生产者决定数据产生到集群的哪个 partition 中每一条消息都是以（ key， value）格式 Key是由生产者发送数据传入所以生产者（ key）决定了数据产生到集群的哪个 partition</li></ul><h2 id="Kafka中是怎么体现消息顺序性的？"><a href="#Kafka中是怎么体现消息顺序性的？" class="headerlink" title="Kafka中是怎么体现消息顺序性的？"></a>Kafka中是怎么体现消息顺序性的？</h2><ul><li>kafka每个partition中的消息在写入时都是有序的，消费时，每个partition只能被每一个group中的一个消费者消费，保证了消费时也是有序的。整个topic不保证有序。如果为了保证topic整个有序，那么将partition调整为1.</li></ul><h2 id="Kafka如何实现延迟队列？"><a href="#Kafka如何实现延迟队列？" class="headerlink" title="Kafka如何实现延迟队列？"></a>Kafka如何实现延迟队列？</h2><ul><li>Kafka并没有使用JDK自带的Timer或者DelayQueue来实现延迟的功能，而是基于时间轮自定义了一个用于实现延迟功能的定时器（SystemTimer）。JDK的Timer和DelayQueue插入和删除操作的平均时间复杂度为O(nlog(n))，并不能满足Kafka的高性能要求，而基于时间轮可以将插入和删除操作的时间复杂度都降为O(1)。时间轮的应用并非Kafka独有，其应用场景还有很多，在Netty、Akka、Quartz、Zookeeper等组件中都存在时间轮的踪影。底层使用数组实现，数组中的每个元素可以存放一个TimerTaskList对象。TimerTaskList是一个环形双向链表，在其中的链表项TimerTaskEntry中封装了真正的定时任务TimerTask.Kafka中到底是怎么推进时间的呢？Kafka中的定时器借助了JDK中的DelayQueue来协助推进时间轮。具体做法是对于每个使用到的TimerTaskList都会加入到DelayQueue中。Kafka中的TimingWheel专门用来执行插入和删除TimerTaskEntry的操作，而DelayQueue专门负责时间推进的任务。再试想一下，DelayQueue中的第一个超时任务列表的expiration为200ms，第二个超时任务为840ms，这里获取DelayQueue的队头只需要O(1)的时间复杂度。如果采用每秒定时推进，那么获取到第一个超时的任务列表时执行的200次推进中有199次属于“空推进”，而获取到第二个超时任务时有需要执行639次“空推进”，这样会无故空耗机器的性能资源，这里采用DelayQueue来辅助以少量空间换时间，从而做到了“精准推进”。Kafka中的定时器真可谓是“知人善用”，用TimingWheel做最擅长的任务添加和删除操作，而用DelayQueue做最擅长的时间推进工作，相辅相成。</li></ul><h2 id="RocketMQ的事务消息是如何实现的"><a href="#RocketMQ的事务消息是如何实现的" class="headerlink" title="RocketMQ的事务消息是如何实现的"></a>RocketMQ的事务消息是如何实现的</h2><ol><li>生产者订单系统先发送一条half消息到Broker，half消息对消费者而言是不可见的</li><li>再创建订单，根据创建订单成功与否，向Broker发送commit或rollback</li><li>并且生产者订单系统还可以提供Broker回调接口，当Broker发现一段时间half消息没有收到任何操作命令，则会主动调此接口来查询订单是否创建成功</li><li>一旦half消息commit了，消费者库存系统就会来消费，如果消费成功，则消息销毁，分布式事务成功结束</li><li>如果消费失败，则根据重试策略进行重试，最后还失败则进入死信队列，等待进一步处理</li></ol><h2 id="为什么RocketMQ不使用Zookeeper作为注册中心呢？"><a href="#为什么RocketMQ不使用Zookeeper作为注册中心呢？" class="headerlink" title="为什么RocketMQ不使用Zookeeper作为注册中心呢？"></a>为什么RocketMQ不使用Zookeeper作为注册中心呢？</h2><ul><li>根据CAP理论，同时最多只能满足两个点，而zookeeper满足的是CP，也就是说zookeeper并不能保证服务的可用性，zookeeper在进行选举的时候，整个选举的时间太长，期间整个集群都处于不可用的状态，而这对于一个注册中心来说肯定是不能接受的，作为服务发现来说就应该是为可用性而设计。</li><li>基于性能的考虑，NameServer本身的实现非常轻量，而且可以通过增加机器的方式水平扩展，增加集群的抗压能力，而zookeeper的写是不可扩展的，而zookeeper要解决这个问题只能通过划分领域，划分多个zookeeper集群来解决，首先操作起来太复杂，其次这样还是又违反了CAP中的A的设计，导致服务之间是不连通的。</li><li>持久化的机制来带的问题，ZooKeeper 的 ZAB 协议对每一个写请求，会在每个 ZooKeeper 节点上保持写一个事务日志，同时再加上定期的将内存数据镜像（Snapshot）到磁盘来保证数据的一致性和持久性，而对于一个简单的服务发现的场景来说，这其实没有太大的必要，这个实现方案太重了。而且本身存储的数据应该是高度定制化的。</li><li>消息发送应该弱依赖注册中心，而RocketMQ的设计理念也正是基于此，生产者在第一次发送消息的时候从NameServer获取到Broker地址后缓存到本地，如果NameServer整个集群不可用，短时间内对于生产者和消费者并不会产生太大影响。</li></ul><h2 id="RocketMQ的实现原理"><a href="#RocketMQ的实现原理" class="headerlink" title="RocketMQ的实现原理"></a>RocketMQ的实现原理</h2><ul><li>RocketMQ由NameServer注册中心集群、Producer生产者集群、Consumer消费者集群和若干Broker（RocketMQ进程）组成，它的架构原理是这样的：</li><li>Broker在启动的时候去向所有的NameServer注册，并保持长连接，每30s发送一次心跳</li><li>Producer在发送消息的时候从NameServer获取Broker服务器地址，根据负载均衡算法选择一台服务器来发送消息</li><li>Conusmer消费消息的时候同样从NameServer获取Broker地址，然后主动拉取消息来消费</li></ul><h2 id="RocketMQ为什么速度快"><a href="#RocketMQ为什么速度快" class="headerlink" title="RocketMQ为什么速度快"></a>RocketMQ为什么速度快</h2><ul><li>因为使用了顺序存储、Page Cache和异步刷盘。我们在写入commitlog的时候是顺序写入的，这样比随机写入的性能就会提高很多，写入commitlog的时候并不是直接写入磁盘，而是先写入操作系统的PageCache，最后由操作系统异步将缓存中的数据刷到磁盘</li></ul><h2 id="消息队列如何保证消息可靠传输"><a href="#消息队列如何保证消息可靠传输" class="headerlink" title="消息队列如何保证消息可靠传输"></a>消息队列如何保证消息可靠传输</h2><ol><li>为了保证消息不多，也就是消息不能重复，也就是生产者不能重复生产消息，或者消费者不能重复消费消息</li><li>首先要确保消息不多发，这个不常出现，也比较难控制，因为如果出现了多发，很大的原因是生产者自己的原因，如果要避免出现问题，就需要在消费端做控制</li><li>要避免不重复消费，最保险的机制就是消费者实现幂等性，保证就算重复消费，也不会有问题，通过幂等性，也能解决生产者重复发送消息的问题</li><li>消息不能少，意思就是消息不能丢失，生产者发送的消息，消费者一定要能消费到，对于这个问题，就要考虑两个方面</li><li>生产者发送消息时，要确认broker确实收到并持久化了这条消息，比如RabbitMQ的confirm机制，Kafka的ack机制都可以保证生产者能正确的将消息发送给broker</li><li>broker要等待消费者真正确认消费到了消息时才删除掉消息，这里通常就是消费端ack机制，消费者接收到一条消息后，如果确认没问题了，就可以给broker发送一个ack，broker接收到ack后才会删除消息</li></ol><h2 id="消息队列有哪些作用"><a href="#消息队列有哪些作用" class="headerlink" title="消息队列有哪些作用"></a>消息队列有哪些作用</h2><ol><li>解耦：使用消息队列来作为两个系统之间的通讯方式，两个系统不需要相互依赖了</li><li>异步：系统A给消息队列发送完消息之后，就可以继续做其他事情了</li><li>流量削峰：如果使用消息队列的方式来调用某个系统，那么消息将在队列中排队，由消费者自己控制消费速度</li></ol><h2 id="死信队列是什么？延时队列是什么？"><a href="#死信队列是什么？延时队列是什么？" class="headerlink" title="死信队列是什么？延时队列是什么？"></a>死信队列是什么？延时队列是什么？</h2><ol><li>死信队列也是一个消息队列，它是用来存放那些没有成功消费的消息的，通常可以用来作为消息重试</li><li>延时队列就是用来存放需要在指定时间被处理的元素的队列，通常可以用来处理一些具有过期性操作的业务，比如十分钟内未支付则取消订单</li></ol><h2 id="如何保证消息的高效读写？"><a href="#如何保证消息的高效读写？" class="headerlink" title="如何保证消息的高效读写？"></a>如何保证消息的高效读写？</h2><ul><li>零拷贝： kafka和RocketMQ都是通过零拷贝技术来优化文件读写。</li><li>传统文件复制方式： 需要对文件在内存中进行四次拷贝。</li><li>零拷贝有两种方式：mmap和transfile，Java当中对零拷贝进行了封装， Mmap方式通过MappedByteBuffer对象进行操作，而transfile通过FileChannel来进行操作。Mmap 适合比较小的文件，通常文件大小不要超过1.5G ~2G 之间。Transfile没有文件大小限制。RocketMQ当中使用Mmap方式来对他的文件进行读写。</li><li>在kafka当中，他的index日志文件也是通过mmap的方式来读写的。在其他日志文件当中，并没有使用零拷贝的方式。Kafka使用transfile方式将硬盘数据加载到网卡。</li></ul><h2 id="让你设计一个MQ，你会如何设计？"><a href="#让你设计一个MQ，你会如何设计？" class="headerlink" title="让你设计一个MQ，你会如何设计？"></a>让你设计一个MQ，你会如何设计？</h2><ul><li>两个误区：<ol><li>放飞自我，漫无边际。</li><li>纠结技术细节。</li></ol></li><li>好的方式：<ol><li>从整体到细节，从业务场景到技术实现。</li><li>以现有产品为基础。</li></ol></li><li>答题思路： MQ作用、项目大概的样子。<ol><li>实现一个单机的队列数据结构。 高效、可扩展。</li><li>将单机队列扩展成为分布式队列。- 分布式集群管理</li><li>基于Topic定制消息路由策略。- 发送者路由策略，消费者与队列对应关系，消费者路由策略</li><li>实现高效的网络通信。- Netty Http</li><li>规划日志文件，实现文件高效读写。- 零拷贝，顺序写。 服务重启后，快速还原运行现场。</li><li>定制高级功能，死信队列、延迟队列、事务消息等等。 - 贴合实际，随意发挥。</li></ol></li></ul><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="什么是认证和授权？如何设计一个权限认证框架？"><a href="#什么是认证和授权？如何设计一个权限认证框架？" class="headerlink" title="什么是认证和授权？如何设计一个权限认证框架？"></a>什么是认证和授权？如何设计一个权限认证框架？</h2><ul><li>认证： 就是对系统访问者的身份进行确认。</li><li>授权：就是对系统访问者的行为进行控制。授权通常是在认证之后，对系统内的用户隐私数据进行保护。后台接口访问权限、前台控件的访问权限。</li><li>RBAC模型： 主体 -&gt; 角色 -&gt; 资源 -&gt; 访问系统的行为。</li><li>认证和授权也是对一个权限认证框架进行扩展的两个主要的方面。</li></ul><h2 id="如果没有Cookie-Session还能进行身份验证吗？"><a href="#如果没有Cookie-Session还能进行身份验证吗？" class="headerlink" title="如果没有Cookie,Session还能进行身份验证吗？"></a>如果没有Cookie,Session还能进行身份验证吗？</h2><ul><li>当服务器tomcat第一次接收到客户端的请求时，会开辟一块独立的session空间，建立一个session对象，同时会生成一个session id，通过响应头的方式保存到客户端浏览器的cookie当中。以后客户端的每次请求，都会在请求头部带上这个session id，这样就可以对应上服务端的一些会话的相关信息，比如用户的登录状态。</li><li>如果没有客户端的Cookie，Session是无法进行身份验证的。</li><li>当服务端从单体应用升级为分布式之后，cookie+session这种机制要怎么扩展？<ol><li>session黏贴： 在负载均衡中，通过一个机制保证同一个客户端的所有请求都会转发到同一个tomcat实例当中。问题： 当这个tomcat实例出现问题之后，请求就会被转发到其他实例，这时候用户的session信息就丢了。</li><li>session复制： 当一个tomcat实例上保存了session信息后，主动将session 复制到集群中的其他实例。问题： 复制是需要时间的，在复制过程中，容易产生session信息丢失。</li><li>session共享： 就是将服务端的session信息保存到一个第三方中，比如Redis。</li></ol></li></ul><h2 id="什么是CSRF攻击？如何防止？"><a href="#什么是CSRF攻击？如何防止？" class="headerlink" title="什么是CSRF攻击？如何防止？"></a>什么是CSRF攻击？如何防止？</h2><ul><li>CSRF： Cross Site Requst Forgery 跨站请求伪造，一个正常的请求会将合法用户的session id保存到浏览器的cookie。这时候，如果用户在浏览器中打来另一个tab页， 那这个tab页也是可以获得浏览器的cookie。黑客就可以利用这个cookie信息进行攻击。<br>攻击过程：<ol><li>某银行网站A可以以GET请求的方式发起转账操作。 <a href="http://www.xxx.com/transfor.do?accountNum=100&amp;money=1000">www.xxx.com/transfor.do?accountNum=100&amp;money=1000</a> accountNum表示目标账户。这个请求肯定是需要登录才可以正常访问的。</li><li>攻击者在某个论坛或者网站上，上传一个图片，链接地址是 <a href="http://www.xxx.com/transfer.do?accountNum=888&amp;money=10000">www.xxx.com/transfer.do?accountNum=888&amp;money=10000</a> 其中这个accountNum就是攻击者自己的银行账户。</li><li>如果有一个用户，登录了银行网站，然后又打开浏览器的另一个tab页，点击了这个图片。这时，银行就会受理到一个带了正确cookie的请求，就会完成转账。用户的钱就被盗了。</li></ol></li><li>CSRF防止方式：<ol><li>尽量使用POST请求，限制GET请求。POST请求可以带请求体，攻击者就不容易伪造出请求。</li><li>将cookie设置为HttpOnly : respose.setHeader(&quot;Set-Cookie&quot;,&quot;cookiename&#x3D;cookievalue;HttpOnly&quot;)。</li><li>增加token；</li><li>在请求中放入一个攻击者无法伪造的信息，并且该信息不存在于cookie当中。这也是Spring Security框架中采用的防范方式。</li></ol></li></ul><h2 id="什么是OAuth2-0协议？有哪几种认证方式？"><a href="#什么是OAuth2-0协议？有哪几种认证方式？" class="headerlink" title="什么是OAuth2.0协议？有哪几种认证方式？"></a>什么是OAuth2.0协议？有哪几种认证方式？</h2><ul><li>OAuth2.0是一个开放标准，允许用户授权第三方应用程序访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方应用或分享他们数据的所有内容。OAuth2.0协议的认证流程，简单理解，就是允许我们将之前的授权和认证过程交给一个独立的第三方进行担保。</li><li>OAuth2.0协议有四种认证方式：<ol><li>授权码模式</li><li>简化模式</li><li>密码模式</li><li>客户端模式</li></ol></li></ul><h2 id="什么是SSO？与OAuth2-0有什么关系？"><a href="#什么是SSO？与OAuth2-0有什么关系？" class="headerlink" title="什么是SSO？与OAuth2.0有什么关系？"></a>什么是SSO？与OAuth2.0有什么关系？</h2><ul><li>OAuth2.0的使用场景通常称为联合登录， 一处注册，多处使用</li><li>SSO Single Sign On 单点登录。 一处登录，多处同时登录</li><li>SSO的实现关键是将Session信息集中存储</li></ul><h2 id="如何设计一个开放授权平台？"><a href="#如何设计一个开放授权平台？" class="headerlink" title="如何设计一个开放授权平台？"></a>如何设计一个开放授权平台？</h2><ol><li>认证： 就可以按照OAuth2.0协议来规划认证的过程。</li><li>授权：<ol><li>首先需要待接入的第三方应用在开放授权平台进行注册，注册需要提供几个必要的信息 clintID, 消息推送地址，密钥(一对公私钥，私钥由授权平台自己保存，公钥分发给第三方应用)。</li><li>然后，第三方应用引导客户发起请求时，采用公钥进行参数加密，授权开放平台使用对应的私钥解密。</li><li>接下来：授权开放平台同步响应第三方应用的只是消息是否处理成功的结果。而真正的业务数据由授权开放平台异步推动给第三方应用预留的推送地址。</li></ol></li></ol><h2 id="epoll和poll的区别"><a href="#epoll和poll的区别" class="headerlink" title="epoll和poll的区别"></a>epoll和poll的区别</h2><ol><li>select模型，使用的是数组来存储Socket连接文件描述符，容量是固定的，需要通过轮询来判断是否发生了IO事件</li><li>poll模型，使用的是链表来存储Socket连接文件描述符，容量是不固定的，同样需要通过轮询来判断是否发生了IO事件</li><li>epoll模型，epoll和poll是完全不同的，epoll是一种事件通知模型，当发生了IO事件时，应用程序才进行IO操作，不需要像poll模型那样主动去轮询</li></ol><h2 id="TCP的三次握手和四次挥手"><a href="#TCP的三次握手和四次挥手" class="headerlink" title="TCP的三次握手和四次挥手"></a>TCP的三次握手和四次挥手</h2><ul><li>在建立TCP连接时，需要通过三次握手来建立，过程是：<ol><li>客户端向服务端发送一个SYN</li><li>服务端接收到SYN后，给客户端发送一个SYN_ACK</li><li>客户端接收到SYN_ACK后，再给服务端发送一个ACK</li></ol></li><li>在断开TCP连接时，需要通过四次挥手来断开，过程是：<ol><li>客户端向服务端发送FIN</li><li>服务端接收FIN后，向客户端发送ACK，表示我接收到了断开连接的请求，客户端你可以不发数据了，不过服务端这边可能还有数据正在处理</li><li>服务端处理完所有数据后，向客户端发送FIN，表示服务端现在可以断开连接</li><li>客户端收到服务端的FIN，向服务端发送ACK，表示客户端也会断开连接了</li></ol></li></ul><h2 id="浏览器发出一个请求到收到响应经历了哪些步骤？"><a href="#浏览器发出一个请求到收到响应经历了哪些步骤？" class="headerlink" title="浏览器发出一个请求到收到响应经历了哪些步骤？"></a>浏览器发出一个请求到收到响应经历了哪些步骤？</h2><ol><li>浏览器解析用户输入的URL，生成一个HTTP格式的请求</li><li>先根据URL域名从本地hosts文件查找是否有映射IP，如果没有就将域名发送给电脑所配置的DNS进行域名解析，得到IP地址</li><li>浏览器通过操作系统将请求通过四层网络协议发送出去</li><li>途中可能会经过各种路由器、交换机，最终到达服务器</li><li>服务器收到请求后，根据请求所指定的端口，将请求传递给绑定了该端口的应用程序，比如8080被tomcat占用了</li><li>tomcat接收到请求数据后，按照http协议的格式进行解析，解析得到所要访问的servlet</li><li>然后servlet来处理这个请求，如果是SpringMVC中的DispatcherServlet，那么则会找到对应的Controller中的方法，并执行该方法得到结果</li><li>Tomcat得到响应结果后封装成HTTP响应的格式，并再次通过网络发送给浏览器所在的服务器</li><li>浏览器所在的服务器拿到结果后再传递给浏览器，浏览器则负责解析并渲染</li></ol><h2 id="跨域请求是什么？有什么问题？怎么解决？"><a href="#跨域请求是什么？有什么问题？怎么解决？" class="headerlink" title="跨域请求是什么？有什么问题？怎么解决？"></a>跨域请求是什么？有什么问题？怎么解决？</h2><ol><li>response添加header，比如resp.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);表示可以访问所有网站，不受是否同源的限制</li><li>jsonp的方式，该技术底层就是基于script标签来实现的，因为script标签是可以跨域的</li><li>后台自己控制，先访问同域名下的接口，然后在接口中再去使用HTTPClient等工具去调用目标接口</li><li>网关，和第三种方式类似，都是交给后台服务来进行跨域访问</li></ol><h2 id="零拷贝是什么"><a href="#零拷贝是什么" class="headerlink" title="零拷贝是什么"></a>零拷贝是什么</h2><ul><li>零拷贝指的是，应用程序在需要把内核中的一块区域数据转移到另外一块内核区域去时，不需要经过先复制到用户空间，再转移到目标内核区域去了，而直接实现转移。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven</title>
      <link href="/2022/10/07/maven/"/>
      <url>/2022/10/07/maven/</url>
      
        <content type="html"><![CDATA[<h1 id="配置阿里云仓库地址"><a href="#配置阿里云仓库地址" class="headerlink" title="配置阿里云仓库地址"></a>配置阿里云仓库地址</h1><p>自行替换{path} 地址</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!--</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">Licensed to the Apache Software Foundation (ASF) under one</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">or more contributor license agreements.  See the NOTICE file</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">distributed with this work for additional information</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">regarding copyright ownership.  The ASF licenses this file</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">to you under the Apache License, Version 2.0 (the</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">&quot;License&quot;); you may not use this file except in compliance</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">with the License.  You may obtain a copy of the License at</span></span></span><br><span class="line"><span class="comment"><span class="language-xml"></span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    http://www.apache.org/licenses/LICENSE-2.0</span></span></span><br><span class="line"><span class="comment"><span class="language-xml"></span></span></span><br><span class="line"><span class="comment"><span class="language-xml">Unless required by applicable law or agreed to in writing,</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">software distributed under the License is distributed on an</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">KIND, either express or implied.  See the License for the</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">specific language governing permissions and limitations</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">under the License.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">--&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!--</span></span></span><br><span class="line"><span class="comment"><span class="language-xml"> | This is the configuration file for Maven. It can be specified at two levels:</span></span></span><br><span class="line"><span class="comment"><span class="language-xml"> |</span></span></span><br><span class="line"><span class="comment"><span class="language-xml"> |  1. User Level. This settings.xml file provides configuration for a single user, </span></span></span><br><span class="line"><span class="comment"><span class="language-xml"> |                 and is normally provided in $</span></span><span class="template-variable">&#123;user.home&#125;</span><span class="language-xml"><span class="comment">/.m2/settings.xml.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml"> |</span></span></span><br><span class="line"><span class="comment"><span class="language-xml"> |                 <span class="doctag">NOTE:</span> This location can be overridden with the CLI option:</span></span></span><br><span class="line"><span class="comment"><span class="language-xml"> |</span></span></span><br><span class="line"><span class="comment"><span class="language-xml"> |                 -s /path/to/user/settings.xml</span></span></span><br><span class="line"><span class="comment"><span class="language-xml"> |</span></span></span><br><span class="line"><span class="comment"><span class="language-xml"> |  2. Global Level. This settings.xml file provides configuration for all Maven</span></span></span><br><span class="line"><span class="comment"><span class="language-xml"> |                 users on a machine (assuming they&#x27;re all using the same Maven</span></span></span><br><span class="line"><span class="comment"><span class="language-xml"> |                 installation). It&#x27;s normally provided in </span></span></span><br><span class="line"><span class="comment"><span class="language-xml"> |                 $</span></span><span class="template-variable">&#123;maven.home&#125;</span><span class="language-xml"><span class="comment">/conf/settings.xml.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml"> |</span></span></span><br><span class="line"><span class="comment"><span class="language-xml"> |                 <span class="doctag">NOTE:</span> This location can be overridden with the CLI option:</span></span></span><br><span class="line"><span class="comment"><span class="language-xml"> |</span></span></span><br><span class="line"><span class="comment"><span class="language-xml"> |                 -gs /path/to/global/settings.xml</span></span></span><br><span class="line"><span class="comment"><span class="language-xml"> |</span></span></span><br><span class="line"><span class="comment"><span class="language-xml"> | The sections in this sample file are intended to give you a running start at</span></span></span><br><span class="line"><span class="comment"><span class="language-xml"> | getting the most out of your Maven installation. Where appropriate, the default</span></span></span><br><span class="line"><span class="comment"><span class="language-xml"> | values (values used when the setting is not specified) are provided.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml"> |</span></span></span><br><span class="line"><span class="comment"><span class="language-xml"> |--&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="comment">&lt;!-- localRepository</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | The path to the local repository maven will use to store artifacts.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   |</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | Default: $</span></span><span class="template-variable">&#123;user.home&#125;</span><span class="language-xml"><span class="comment">/.m2/repository</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">  &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">  --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span></span><span class="template-variable">&#123;path&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="comment">&lt;!-- interactiveMode</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | This will determine whether maven prompts you when it needs input. If set to false,</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | maven will use a sensible default value, perhaps based on some other setting, for</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | the parameter in question.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   |</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | Default: true</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">  &lt;interactiveMode&gt;true&lt;/interactiveMode&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">  --&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="comment">&lt;!-- offline</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | Determines whether maven should attempt to connect to the network when executing a build.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | This will have an effect on artifact downloads, artifact deployment, and others.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   |</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | Default: false</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">  &lt;offline&gt;false&lt;/offline&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">  --&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="comment">&lt;!-- pluginGroups</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | This is a list of additional group identifiers that will be searched when resolving plugins by their prefix, i.e.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | when invoking a command line like &quot;mvn prefix:goal&quot;. Maven will automatically add the group identifiers</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | &quot;org.apache.maven.plugins&quot; and &quot;org.codehaus.mojo&quot; if these are not already contained in the list.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   |--&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">pluginGroups</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- pluginGroup</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     | Specifies a further group identifier to use for plugin lookup.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    &lt;pluginGroup&gt;com.your.plugins&lt;/pluginGroup&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">pluginGroup</span>&gt;</span>org.mortbay.jetty<span class="tag">&lt;/<span class="name">pluginGroup</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">pluginGroups</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="comment">&lt;!-- proxies</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | This is a list of proxies which can be used on this machine to connect to the network.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | Unless otherwise specified (by system property or command-line switch), the first proxy</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | specification in this list marked as active will be used.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   |--&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">proxies</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- proxy</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     | Specification for one proxy, to be used in connecting to the network.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     |</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    &lt;proxy&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">      &lt;id&gt;optional&lt;/id&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">      &lt;active&gt;true&lt;/active&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">      &lt;protocol&gt;http&lt;/protocol&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">      &lt;username&gt;proxyuser&lt;/username&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">      &lt;password&gt;proxypass&lt;/password&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">      &lt;host&gt;proxy.host.net&lt;/host&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">      &lt;port&gt;80&lt;/port&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">      &lt;nonProxyHosts&gt;local.net|some.host.com&lt;/nonProxyHosts&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    &lt;/proxy&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    --&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">proxies</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="comment">&lt;!-- servers</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | This is a list of authentication profiles, keyed by the server-id used within the system.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | Authentication profiles can be used whenever maven must make a connection to a remote server.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   |--&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- server</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     | Specifies the authentication information to use when connecting to a particular server, identified by</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     | a unique name within the system (referred to by the &#x27;id&#x27; attribute below).</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     | </span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     | <span class="doctag">NOTE:</span> You should either specify username/password OR privateKey/passphrase, since these pairings are </span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     |       used together.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     |</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    &lt;server&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">      &lt;id&gt;deploymentRepo&lt;/id&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">      &lt;username&gt;repouser&lt;/username&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">      &lt;password&gt;repopwd&lt;/password&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    &lt;/server&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    --&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- Another sample, using keys to authenticate.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    &lt;server&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">      &lt;id&gt;siteServer&lt;/id&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">      &lt;privateKey&gt;/path/to/private/key&lt;/privateKey&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">      &lt;passphrase&gt;optional; leave empty if not used.&lt;/passphrase&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    &lt;/server&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    --&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="comment">&lt;!-- mirrors</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | This is a list of mirrors to be used in downloading artifacts from remote repositories.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | </span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | It works like this: a POM may declare a repository to use in resolving certain artifacts.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | However, this repository may have problems with heavy traffic at times, so people have mirrored</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | it to several places.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   |</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | That repository definition will have a unique id, so we can create a mirror reference for that</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | repository, to be used as an alternate download site. The mirror site will be the preferred </span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | server for that repository.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   |--&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- mirror</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     | Specifies a repository mirror site to use instead of a given repository. The repository that</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     |</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    &lt;mirror&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">      &lt;id&gt;mirrorId&lt;/id&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">      &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">      &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">      &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    &lt;/mirror&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span></span><br><span class="line"><span class="language-xml">  <span class="comment">&lt;!-- profiles</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | This is a list of profiles which can be activated in a variety of ways, and which can modify</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | the build process. Profiles provided in the settings.xml are intended to provide local machine-</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | specific paths and repository locations which allow the build to work in the local environment.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   |</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | For example, if you have an integration testing plugin - like cactus - that needs to know where</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | your Tomcat instance is installed, you can provide a variable here such that the variable is </span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | dereferenced during the build process to configure the cactus plugin.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   |</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | As noted above, profiles can be activated in a variety of ways. One way - the activeProfiles</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | section of this document (settings.xml) - will be discussed later. Another way essentially</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | relies on the detection of a system property, either matching a particular value for the property,</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | or merely testing its existence. Profiles can also be activated by JDK version prefix, where a </span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | value of &#x27;1.4&#x27; might activate a profile when the build is executed on a JDK version of &#x27;1.4.2_07&#x27;.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | Finally, the list of active profiles can be specified directly from the command line.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   |</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | <span class="doctag">NOTE:</span> For profiles defined in the settings.xml, you are restricted to specifying only artifact</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   |       repositories, plugin repositories, and free-form properties to be used as configuration</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   |       variables for plugins in the POM.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   |</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   |--&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- profile</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     | Specifies a set of introductions to the build process, to be activated using one or more of the</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     | mechanisms described above. For inheritance purposes, and to activate profiles via &lt;activatedProfiles/&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     | or the command line, profiles have to have an ID that is unique.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     |</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     | An encouraged best practice for profile identification is to use a consistent naming convention</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     | for profiles, such as &#x27;env-dev&#x27;, &#x27;env-test&#x27;, &#x27;env-production&#x27;, &#x27;user-jdcasey&#x27;, &#x27;user-brett&#x27;, etc.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     | This will make it more intuitive to understand what the set of introduced profiles is attempting</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     | to accomplish, particularly when you only have a list of profile id&#x27;s for debug.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     |</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     | This profile example uses the JDK version to trigger activation, and provides a JDK-specific repo.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    &lt;profile&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">      &lt;id&gt;jdk-1.4&lt;/id&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml"></span></span></span><br><span class="line"><span class="comment"><span class="language-xml">      &lt;activation&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">        &lt;jdk&gt;1.4&lt;/jdk&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">      &lt;/activation&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml"></span></span></span><br><span class="line"><span class="comment"><span class="language-xml">      &lt;repositories&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">        &lt;repository&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">          &lt;id&gt;jdk14&lt;/id&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">          &lt;name&gt;Repository for JDK 1.4 builds&lt;/name&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">          &lt;url&gt;http://www.myhost.com/maven/jdk14&lt;/url&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">          &lt;layout&gt;default&lt;/layout&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">          &lt;snapshotPolicy&gt;always&lt;/snapshotPolicy&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">        &lt;/repository&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">      &lt;/repositories&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    &lt;/profile&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    --&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!--</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     | Here is another profile, activated by the system property &#x27;target-env&#x27; with a value of &#x27;dev&#x27;,</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     | which provides a specific path to the Tomcat instance. To use this, your plugin configuration</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     | might hypothetically look like:</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     |</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     | ...</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     | &lt;plugin&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     |   &lt;groupId&gt;org.myco.myplugins&lt;/groupId&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     |   &lt;artifactId&gt;myplugin&lt;/artifactId&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     |   </span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     |   &lt;configuration&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     |     &lt;tomcatLocation&gt;$</span></span><span class="template-variable">&#123;tomcatPath&#125;</span><span class="language-xml"><span class="comment">&lt;/tomcatLocation&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     |   &lt;/configuration&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     | &lt;/plugin&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     | ...</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     |</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     | <span class="doctag">NOTE:</span> If you just wanted to inject this configuration whenever someone set &#x27;target-env&#x27; to</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     |       anything, you could just leave off the &lt;value/&gt; inside the activation-property.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">     |</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    &lt;profile&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">      &lt;id&gt;env-dev&lt;/id&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml"></span></span></span><br><span class="line"><span class="comment"><span class="language-xml">      &lt;activation&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">        &lt;property&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">          &lt;name&gt;target-env&lt;/name&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">          &lt;value&gt;dev&lt;/value&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">        &lt;/property&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">      &lt;/activation&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml"></span></span></span><br><span class="line"><span class="comment"><span class="language-xml">      &lt;properties&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">        &lt;tomcatPath&gt;/path/to/tomcat/instance&lt;/tomcatPath&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">      &lt;/properties&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    &lt;/profile&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    --&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>ali<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Proxy Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>ali<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Proxy Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!--make the profile active all the time --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>ali<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="comment">&lt;!-- activeProfiles</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   | List of profiles that are active for all builds.</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">   |</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">  &lt;activeProfiles&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    &lt;activeProfile&gt;ali&lt;/activeProfile&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    &lt;activeProfile&gt;anotherAlwaysActiveProfile&lt;/activeProfile&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">  &lt;/activeProfiles&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">  --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2022/09/30/Spring/"/>
      <url>/2022/09/30/Spring/</url>
      
        <content type="html"><![CDATA[<h1 id="restTemplate-跳过ssl验证"><a href="#restTemplate-跳过ssl验证" class="headerlink" title="restTemplate 跳过ssl验证"></a>restTemplate 跳过ssl验证</h1><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">TrustStrategy acceptingTrustStrategy = (X509Certificate<span class="literal">[]</span> chain, String authType) -&gt; <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">       SSLContext sslContext = org.apache.http.ssl.<span class="module-access"><span class="module"><span class="identifier">SSLContexts</span>.</span></span>custom<span class="literal">()</span></span><br><span class="line">               .load<span class="constructor">TrustMaterial(<span class="params">null</span>, <span class="params">acceptingTrustStrategy</span>)</span></span><br><span class="line">               .build<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">       SSLConnectionSocketFactory csf = <span class="keyword">new</span> <span class="constructor">SSLConnectionSocketFactory(<span class="params">sslContext</span>)</span>;</span><br><span class="line"></span><br><span class="line">       CloseableHttpClient httpClient = <span class="module-access"><span class="module"><span class="identifier">HttpClients</span>.</span></span>custom<span class="literal">()</span></span><br><span class="line">               .set<span class="constructor">SSLSocketFactory(<span class="params">csf</span>)</span></span><br><span class="line">               .build<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">       HttpComponentsClientHttpRequestFactory requestFactory =</span><br><span class="line">               <span class="keyword">new</span> <span class="constructor">HttpComponentsClientHttpRequestFactory()</span>;</span><br><span class="line">       requestFactory.set<span class="constructor">ConnectTimeout(1000L)</span>;</span><br><span class="line">       requestFactory.set<span class="constructor">ConnectionRequestTimeout(1000L)</span>;</span><br><span class="line">       requestFactory.set<span class="constructor">ReadTimeout(1000L)</span>;</span><br><span class="line">       requestFactory.set<span class="constructor">HttpClient(<span class="params">httpClient</span>)</span>;</span><br><span class="line">       RestTemplate restTemplate = <span class="keyword">new</span> <span class="constructor">RestTemplate(<span class="params">requestFactory</span>)</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java</title>
      <link href="/2022/09/30/Java/"/>
      <url>/2022/09/30/Java/</url>
      
        <content type="html"><![CDATA[<h1 id="list-toMap"><a href="#list-toMap" class="headerlink" title="list toMap"></a>list toMap</h1><p>环境是jdk8以上 使用lamdba表达式 </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListToMap</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line"><span class="title class_">List</span>&lt;<span class="title class_">Book</span>&gt; bookList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">bookList.<span class="title function_">add</span>(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;The Fellowship of the Ring&quot;</span>, <span class="number">1954</span>, <span class="string">&quot;0395489318&quot;</span>));</span><br><span class="line">bookList.<span class="title function_">add</span>(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;The Two Towers&quot;</span>, <span class="number">1954</span>, <span class="string">&quot;0345339711&quot;</span>));</span><br><span class="line">bookList.<span class="title function_">add</span>(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;The Return of the King&quot;</span>, <span class="number">1955</span>, <span class="string">&quot;0618129111&quot;</span>));</span><br><span class="line"><span class="title class_">Map</span>&lt;<span class="title class_">String</span>,<span class="title class_">Book</span>&gt; bookMap=bookList.<span class="title function_">stream</span>()</span><br><span class="line">.<span class="title function_">collect</span>(<span class="title class_">Collectors</span>.<span class="title function_">toMap</span>(<span class="title class_">Book</span>::getName, <span class="title class_">Function</span>.<span class="title function_">identity</span>()));</span><br><span class="line"><span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(bookMap);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="title class_">String</span> name;</span><br><span class="line"><span class="keyword">private</span> int releaseYear;</span><br><span class="line"><span class="keyword">private</span> <span class="title class_">String</span> isbn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">setName</span>(<span class="params"><span class="built_in">String</span> name</span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> int <span class="title function_">getReleaseYear</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> releaseYear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">setReleaseYear</span>(<span class="params">int releaseYear</span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">releaseYear</span> = releaseYear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">getIsbn</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> isbn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">setIsbn</span>(<span class="params"><span class="built_in">String</span> isbn</span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">isbn</span> = isbn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title class_">Book</span>(<span class="title class_">String</span> name, int releaseYear, <span class="title class_">String</span> isbn) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">releaseYear</span> = releaseYear;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">isbn</span> = isbn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Book&#123;&quot;</span> +</span><br><span class="line"><span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line"><span class="string">&quot;, releaseYear=&quot;</span> + releaseYear +</span><br><span class="line"><span class="string">&quot;, isbn=&#x27;&quot;</span> + isbn + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line"><span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;The Return of the <span class="attribute">King</span>=Book&#123;<span class="attribute">name</span>=<span class="string">&#x27;The Return of the King&#x27;</span>, <span class="attribute">releaseYear</span>=1955, <span class="attribute">isbn</span>=<span class="string">&#x27;0618129111&#x27;</span>&#125;, The Fellowship of the <span class="attribute">Ring</span>=Book&#123;<span class="attribute">name</span>=<span class="string">&#x27;The Fellowship of the Ring&#x27;</span>, <span class="attribute">releaseYear</span>=1954, <span class="attribute">isbn</span>=<span class="string">&#x27;0395489318&#x27;</span>&#125;, The Two <span class="attribute">Towers</span>=Book&#123;<span class="attribute">name</span>=<span class="string">&#x27;The Two Towers&#x27;</span>, <span class="attribute">releaseYear</span>=1954, <span class="attribute">isbn</span>=<span class="string">&#x27;0345339711&#x27;</span>&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解决key冲突"><a href="#解决key冲突" class="headerlink" title="解决key冲突"></a>解决key冲突</h2><p>上面的例子运行得很好，但是如果有一个重复的key会发生什么呢?<br>抛出异常</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.IllegalStateException: Duplicate key Book&#123;<span class="attribute">name</span>=<span class="string">&#x27;The Return of the King&#x27;</span>, <span class="attribute">releaseYear</span>=1955, <span class="attribute">isbn</span>=<span class="string">&#x27;0618129111&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>要解决这个问题，我们需要使用另一种toMap()方法，附加一个参数，mergeFunction:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, U&gt;</span><br><span class="line"><span class="title class_">Collector</span>&lt;T, ?, <span class="title class_">Map</span>&lt;K,U&gt;&gt; <span class="title function_">toMap</span>(<span class="params"><span class="built_in">Function</span>&lt;? <span class="variable language_">super</span> T, ? <span class="keyword">extends</span> K&gt; keyMapper,</span></span><br><span class="line"><span class="params">                                <span class="built_in">Function</span>&lt;? <span class="variable language_">super</span> T, ? <span class="keyword">extends</span> U&gt; valueMapper,</span></span><br><span class="line"><span class="params">                                BinaryOperator&lt;U&gt; mergeFunction</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">toMap</span>(keyMapper, valueMapper, mergeFunction, <span class="title class_">HashMap</span>::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码如下</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>,Book&gt; bookMap=bookList.stream()</span><br><span class="line">.collect<span class="function"><span class="params">(Collectors.toMap(Book::getName, <span class="built_in">Function</span>.identity(),(k,v)-&gt;k))</span>;</span></span><br></pre></td></tr></table></figure><h1 id="java自定义排序"><a href="#java自定义排序" class="headerlink" title="java自定义排序"></a>java自定义排序</h1><p>List 接口sort方法 实现Comparator 接口进行排序</p><p>需要注意有可能抛出：Comparison method violates its general contract异常</p><p>保证实现接口 返回0 -1 1.<br>需要实现升序返回：-1 0 1<br>实现降序返回：1 0 -1</p><h2 id="timesort"><a href="#timesort" class="headerlink" title="timesort"></a>timesort</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql</title>
      <link href="/2022/09/09/Mysql/"/>
      <url>/2022/09/09/Mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="获取MySQL-Workbench本地保存密码"><a href="#获取MySQL-Workbench本地保存密码" class="headerlink" title="获取MySQL-Workbench本地保存密码"></a>获取MySQL-Workbench本地保存密码</h1><ul><li>workbench 存储密码, workbench_user_data.data,</li><li>下载<a href="/download/CryptUnprotect.zip">CryptUnprotect.zip</a></li><li>解压后直接cmd运行Release&#x2F;CryptUnprotect.exe就能查看本机workbench 存储密码</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos Linux</title>
      <link href="/2022/09/09/Linux/"/>
      <url>/2022/09/09/Linux/</url>
      
        <content type="html"><![CDATA[<h1 id="查看java的安装路径"><a href="#查看java的安装路径" class="headerlink" title="查看java的安装路径"></a>查看java的安装路径</h1><ul><li>查看java的安装路径<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost local]# which java</span><br><span class="line"><span class="regexp">/usr/</span>bin/java</span><br><span class="line"></span><br><span class="line">[root@localhost local]# ls -lrt <span class="regexp">/usr/</span>bin/java</span><br><span class="line">lrwxrwxrwx. <span class="number">1</span> root root <span class="number">22</span> Mar <span class="number">7</span> <span class="number">19</span>:<span class="number">12</span> <span class="regexp">/usr/</span>bin<span class="regexp">/java -&gt; /</span>etc<span class="regexp">/alternatives/</span>java</span><br><span class="line"></span><br><span class="line">[root@localhost local]# ls -lrt <span class="regexp">/etc/</span>alternatives/java</span><br><span class="line">lrwxrwxrwx. <span class="number">1</span> root root <span class="number">70</span> Mar <span class="number">7</span> <span class="number">19</span>:<span class="number">12</span> <span class="regexp">/etc/</span>alternatives<span class="regexp">/java -&gt; /u</span>sr<span class="regexp">/lib/</span>jvm<span class="regexp">/java-1.8.0-openjdk-1.8.0.65-3.b17.el7.x86_64/</span>jre<span class="regexp">/bin/</span>java</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h1 id="Linux给用户赋予对某个文件夹的操作权限"><a href="#Linux给用户赋予对某个文件夹的操作权限" class="headerlink" title="Linux给用户赋予对某个文件夹的操作权限"></a>Linux给用户赋予对某个文件夹的操作权限</h1><ul><li>更改文件夹的用户为user1<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> -R user1:user1 /local</span><br></pre></td></tr></table></figure></li><li>修改user1对文件夹的权限<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 /local</span><br></pre></td></tr></table></figure></li></ul><h1 id="copy-命令"><a href="#copy-命令" class="headerlink" title="copy 命令"></a>copy 命令</h1><ul><li>复制文件夹<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp dockerfiles<span class="regexp">/ -a /</span>xz/</span><br></pre></td></tr></table></figure></li></ul><h1 id="设置静态ip"><a href="#设置静态ip" class="headerlink" title="设置静态ip"></a>设置静态ip</h1><ul><li>cd &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;</li><li>然后在输入ls可以看到下面有许多文件，找到以ifcfg-en开头的，例如：</li></ul><p><img src="/2022/08/26/Linu/pasted-0.png" alt="ifcfg-en"></p><ul><li>设置静态ip</li></ul><p><img src="/2022/08/26/Linu/pasted-1.png" alt="设置静态ip"></p><ul><li>设置IPADDR、NETMASK、GATEWAY<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">IPADDR</span><span class="operator">=</span><span class="string">&quot;192.168.220.137&quot;</span></span><br><span class="line"><span class="attribute">NETMASK</span><span class="operator">=</span><span class="string">&quot;255.255.255.0&quot;</span></span><br><span class="line"><span class="attribute">GATEWAY</span><span class="operator">=</span><span class="string">&quot;192.168.220.2&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="virtualBox虚拟机实现win10和centos7挂载目录共享"><a href="#virtualBox虚拟机实现win10和centos7挂载目录共享" class="headerlink" title="virtualBox虚拟机实现win10和centos7挂载目录共享"></a>virtualBox虚拟机实现win10和centos7挂载目录共享</h1><ul><li>在虚拟机中的&#x2F;media文件夹下新建cdrom文件夹<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="regexp">/media/</span>cdrom</span><br></pre></td></tr></table></figure></li><li>查看当前虚拟机中所有连接的虚拟设备<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lsscsi</span></span><br></pre></td></tr></table></figure><img src="/2022/08/26/Linu/pasted-2.png" alt="lsscsi"></li><li>把sr0挂载到&#x2F;media&#x2F;cdrom<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount <span class="regexp">/dev/</span>sr0 <span class="regexp">/media/</span>cdrom</span><br></pre></td></tr></table></figure></li><li>切换到&#x2F;media&#x2F;cdrom，执行以下命令<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">/media/cdrom</span></span><br><span class="line">yum install -y bzip2</span><br><span class="line">yum update kernel -y</span><br><span class="line">sudo <span class="string">./VBoxLinuxAdditions.run</span></span><br></pre></td></tr></table></figure></li><li>在虚拟机，点击设置，共享文件夹，选择刚刚共享的文件夹，选择“自动挂载”和“固定分配”</li></ul><p><img src="/2022/08/26/Linu/pasted-3.png" alt="设置共享文件夹"></p><ul><li>挂载文件夹<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p <span class="regexp">/mnt/</span>share/shared</span><br><span class="line">mount -t vboxsf www <span class="regexp">/mnt/</span>share/shared</span><br></pre></td></tr></table></figure></li></ul><h1 id="查看文件夹的大小"><a href="#查看文件夹的大小" class="headerlink" title="查看文件夹的大小"></a>查看文件夹的大小</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -sh *</span><br></pre></td></tr></table></figure><h1 id="查看linux版本"><a href="#查看linux版本" class="headerlink" title="查看linux版本"></a>查看linux版本</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Centos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Centos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Junittest</title>
      <link href="/2022/09/09/Junittest/"/>
      <url>/2022/09/09/Junittest/</url>
      
        <content type="html"><![CDATA[<h1 id="JUnit-5中的测试执行顺序"><a href="#JUnit-5中的测试执行顺序" class="headerlink" title="JUnit 5中的测试执行顺序"></a>JUnit 5中的测试执行顺序</h1><p>一般实践认为，自动化测试应能够独立运行且无特定顺序，并且测试结果不应依赖于先前测试的结果。 但是在某些情况下，可以证明特定的测试执行顺序是正确的，尤其是在集成或端到端测试中。</p><p>默认情况下，在JUnit 5中，测试方法的执行在构建之间是可重复的，因此具有确定性，但是该算法是故意不明显的（作为库状态的作者）。 幸运的是，可以使用内置方法定购器或通过创建自定义定购器来调整执行顺序以满足我们的需求。</p><p>org.junit.jupiter.api.TestMethodOrder</p><p>为了更改测试执行顺序，我们需要使用org.junit.jupiter.api.TestMethodOrder注释测试类，并将方法排序器的类型作为参数传递。 从JUnit 5.4开始，有三个内置的方法排序器： OrderAnnotation ， Alphanumeric和Random 。 通过实现org.junit.jupiter.api.MethodOrderer接口，我们还可以轻松创建自己的自定义方法org.junit.jupiter.api.MethodOrderer器。</p><h2 id="MethodOrderer-OrderAnnotation使用"><a href="#MethodOrderer-OrderAnnotation使用" class="headerlink" title="MethodOrderer.OrderAnnotation使用"></a>MethodOrderer.OrderAnnotation使用</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">package</span> <span class="selector-tag">pl</span><span class="selector-class">.codeleak</span><span class="selector-class">.samples</span><span class="selector-class">.junit5</span><span class="selector-class">.basics</span>;  </span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">org</span><span class="selector-class">.junit</span><span class="selector-class">.jupiter</span><span class="selector-class">.api</span><span class="selector-class">.MethodOrderer</span>;  </span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">org</span><span class="selector-class">.junit</span><span class="selector-class">.jupiter</span><span class="selector-class">.api</span><span class="selector-class">.Order</span>;  </span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">org</span><span class="selector-class">.junit</span><span class="selector-class">.jupiter</span><span class="selector-class">.api</span><span class="selector-class">.Test</span>;  </span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">org</span><span class="selector-class">.junit</span><span class="selector-class">.jupiter</span><span class="selector-class">.api</span><span class="selector-class">.TestMethodOrder</span>;  @<span class="selector-tag">TestMethodOrder</span> (MethodOrderer.OrderAnnotation. class )  </span><br><span class="line"><span class="selector-tag">class</span> <span class="selector-tag">TestExecutionOrderWithOrderAnnotation</span> &#123; </span><br><span class="line">     <span class="variable">@Order</span> ( <span class="number">1</span> ) </span><br><span class="line">     <span class="variable">@Test</span> </span><br><span class="line">     void <span class="built_in">aTest</span>() &#123;&#125; </span><br><span class="line">     <span class="variable">@Order</span> ( <span class="number">2</span> ) </span><br><span class="line">     <span class="variable">@Test</span> </span><br><span class="line">     void <span class="built_in">bTest</span>() &#123;&#125; </span><br><span class="line">     <span class="variable">@Order</span> ( <span class="number">3</span> ) </span><br><span class="line">     <span class="variable">@Test</span> </span><br><span class="line">     void <span class="built_in">cTest</span>() &#123;&#125;  &#125; </span><br></pre></td></tr></table></figure><h2 id="MethodOrderer-Alphanumeric"><a href="#MethodOrderer-Alphanumeric" class="headerlink" title="MethodOrderer.Alphanumeric"></a>MethodOrderer.Alphanumeric</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@TestMethodOrder</span> (MethodOrderer.Alphanumeric. class )  </span><br><span class="line">class AlphanumericTestExecutionOrder &#123; </span><br><span class="line">     <span class="variable">@Test</span> </span><br><span class="line">     void <span class="built_in">aTest</span>() &#123;&#125; </span><br><span class="line">     <span class="variable">@Test</span> </span><br><span class="line">     void <span class="built_in">bTest</span>() &#123;&#125; </span><br><span class="line">     <span class="variable">@Test</span> </span><br><span class="line">     void <span class="built_in">cTest</span>() &#123;&#125;  &#125; </span><br></pre></td></tr></table></figure><h2 id="MethodOrderer-Random"><a href="#MethodOrderer-Random" class="headerlink" title="MethodOrderer.Random"></a>MethodOrderer.Random</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@TestMethodOrder</span> (MethodOrderer.Random. class )  class AlphanumericTestExecutionOrder &#123; </span><br><span class="line">     <span class="variable">@Test</span> </span><br><span class="line">     void <span class="built_in">aTest</span>() &#123;&#125; </span><br><span class="line">     <span class="variable">@Test</span> </span><br><span class="line">     void <span class="built_in">bTest</span>() &#123;&#125; </span><br><span class="line">     <span class="variable">@Test</span> </span><br><span class="line">     void <span class="built_in">cTest</span>() &#123;&#125;  &#125; </span><br></pre></td></tr></table></figure><h1 id="Mokito-RestTemplate的exchange-例子"><a href="#Mokito-RestTemplate的exchange-例子" class="headerlink" title="Mokito RestTemplate的exchange 例子"></a>Mokito RestTemplate的exchange 例子</h1><ul><li>RestTemplate 的exchange 方法<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; ResponseEntity&lt;T&gt; exchange(String url, HttpMethod <span class="keyword">method</span>, @<span class="title function_">Nullable</span> <span class="title function_">HttpEntity</span>&lt;?&gt; <span class="title function_">requestEntity</span>, <span class="title function_">Class</span>&lt;<span class="title function_">T</span>&gt; <span class="title function_">responseType</span>, <span class="title function_">Object</span>... <span class="title function_">uriVariables</span>) <span class="title function_">throws</span> <span class="title function_">RestClientException</span> <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    </span></span><br></pre></td></tr></table></figure>若mokito 不对,因为RestTemplate 中exchange 上面方法重载有4个</li></ul><p><img src="/2022/09/09/Junittes/pasted-1.png" alt="RestTemplate 中exchange重载方法"><br>就会出现以下错误</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getting error like org<span class="selector-class">.mockito</span><span class="selector-class">.exceptions</span><span class="selector-class">.misusing</span><span class="selector-class">.InvalidUseOfMatchersException</span>: </span><br><span class="line">Invalid use of argument matchers!</span><br><span class="line"><span class="number">4</span> matchers expected, <span class="number">3</span> recorded:</span><br></pre></td></tr></table></figure><ul><li>Mokito 例子<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Mockito</span>.</span></span><span class="keyword">do</span><span class="constructor">Return(ResponseEntity.<span class="params">ok</span>(<span class="params">new</span> Object )</span>).<span class="keyword">when</span>(restTemplate)</span><br><span class="line">               .exchange(<span class="module-access"><span class="module"><span class="identifier">Mockito</span>.</span></span>any<span class="constructor">String()</span>,<span class="module-access"><span class="module"><span class="identifier">Mockito</span>.</span></span>eq(HttpMethod.GET),</span><br><span class="line">                       (org.springframework.http.HttpEntity&lt;?&gt;) <span class="module-access"><span class="module"><span class="identifier">Mockito</span>.</span></span>any<span class="literal">()</span>,</span><br><span class="line">                       (Class&lt;Object&gt;) <span class="module-access"><span class="module"><span class="identifier">Mockito</span>.</span></span>any<span class="literal">()</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h1 id="junit5-spring-boot"><a href="#junit5-spring-boot" class="headerlink" title="junit5 + spring boot"></a>junit5 + spring boot</h1><ul><li>代码<a href="https://github.com/peterTanBlog/SpringJunitTest5.git">SpringJunitTest5</a> 分支main,jdk11</li><li>unit test code<br>junit5与junit 4不同<br>spring boot整合junit5 test<br>junit5要使用@SpringJUnitConfig和@SpringBootTest 注解 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringJUnitConfig</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = SpringJunitTest5Application.class)</span></span><br><span class="line"><span class="meta">@TestInstance(TestInstance.Lifecycle.PER_CLASS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloControllerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext webApplicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Assert.notNull(webApplicationContext, <span class="string">&quot;&#x27;webApplicationContext&#x27; must not be null&quot;</span>);</span><br><span class="line">        MockitoAnnotations.openMocks(<span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">this</span>.mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">MockHttpServletRequestBuilder</span> <span class="variable">requestBuilder</span> <span class="operator">=</span> MockMvcRequestBuilders.get(<span class="string">&quot;/hello&quot;</span>)</span><br><span class="line">                .contentType(MediaType.APPLICATION_FORM_URLENCODED)</span><br><span class="line">                .param(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        <span class="type">ResultActions</span> <span class="variable">resultActions</span> <span class="operator">=</span> mockMvc.perform(requestBuilder);</span><br><span class="line">        resultActions.andDo(MockMvcResultHandlers.print());</span><br><span class="line">        resultActions.andExpect(status().is(<span class="number">200</span>));</span><br><span class="line">        resultActions.andExpect(content().string(<span class="string">&quot;hello world&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="关于TestInstance-Lifecycle-PER-CLASS"><a href="#关于TestInstance-Lifecycle-PER-CLASS" class="headerlink" title="关于TestInstance.Lifecycle.PER_CLASS"></a>关于TestInstance.Lifecycle.PER_CLASS</h2><p>为了允许隔离执行单个的测试方法，并避免由于可变测试实例状态而产生的意外副作用，JUnit在执行每个测试方法之前创建每个测试类的新实例 只需使用@TestInstance(Lifecycle.PER_CLASS)对您的测试类进行注解即可。当使用这种模式时，每个测试类将创建一个新的测试实例。因此，如果您的测试方法依赖于存储在实例变量中的状态，则可能需要在@BeforeEach或@AfterEach方法中重置该状态。</p><p>如果测试类或测试接口没有用@TestInstance注解，JUnit Jupiter将使用默认的生命周期模式。标准默认模式是PER_METHOD</p><h2 id="验证插入数据库的对象数据是否正确"><a href="#验证插入数据库的对象数据是否正确" class="headerlink" title="验证插入数据库的对象数据是否正确"></a>验证插入数据库的对象数据是否正确</h2><ul><li>测试的目的：<br>程序是否调用了一次HelloDaoImpl的hello 方法<br>并验证传入参数值是否是world?</li><li>dao 类<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">IHelloDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">hello</span>(<span class="params"><span class="built_in">String</span> name</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>service 类<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IHelloService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="title class_">IHelloDao</span> helloDao;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">hello</span>(<span class="params"><span class="built_in">String</span> name</span>) &#123;</span><br><span class="line">        helloDao.<span class="title function_">hello</span>(name);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>test verify data 类<br>实现VerificationMode类的verify 方法</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> HelloServiceVerification implements VerificationMode &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    final <span class="built_in">int</span> wantedCount;</span><br><span class="line">    public <span class="constructor">HelloServiceVerification(<span class="params">int</span> <span class="params">wantedNumberOfInvocations</span>,String <span class="params">name</span>)</span> &#123;</span><br><span class="line">      this.wantedCount=wantedNumberOfInvocations;</span><br><span class="line">        this.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void verify(VerificationData data) &#123;</span><br><span class="line">    <span class="comment">/** 程序是否没有调用HelloDaoImpl的hello 方法</span></span><br><span class="line"><span class="comment">    若</span></span><br><span class="line"><span class="comment">    没有调用则抛出异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="keyword">if</span> (wantedCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">MissingInvocationChecker</span>.</span></span>check<span class="constructor">MissingInvocation(<span class="params">data</span>.<span class="params">getAllInvocations</span>()</span>,data.get<span class="constructor">Target()</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Invocation&gt; invocations=data.get<span class="constructor">AllInvocations()</span>;</span><br><span class="line">        <span class="keyword">if</span>(invocations!=null) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Invocation invocation : invocations) &#123;</span><br><span class="line">                Object<span class="literal">[]</span> args = invocation.get<span class="constructor">Arguments()</span>;</span><br><span class="line">                <span class="keyword">if</span>(data.get<span class="constructor">Target()</span>.has<span class="constructor">SameMethod(<span class="params">invocation</span>)</span>) &#123;</span><br><span class="line">                    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;invocation.getMethod():&quot;</span>+invocation.get<span class="constructor">Method()</span>);</span><br><span class="line">                    <span class="keyword">if</span> (args != null) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (Object arg : args) &#123;</span><br><span class="line">                         <span class="comment">//验证传入参数</span></span><br><span class="line">                         this.verify<span class="constructor">Data(<span class="params">arg</span>)</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line"><span class="comment">//程序是否调用HelloDaoImpl的hello 方法 ，且    调用次数只有1次  NumberOfInvocationsChecker.checkNumberOfInvocations(data.getAllInvocations(),data.getTarget(),wantedCount);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证参数是否正确</span></span><br><span class="line">   public void verify<span class="constructor">Data(Object <span class="params">args</span>)</span> &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;args=&quot;</span>+args);</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Assert</span>.</span></span>not<span class="constructor">Null(<span class="params">args</span>, <span class="string">&quot;args must not be null&quot;</span>)</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Assertions</span>.</span></span><span class="keyword">assert</span><span class="constructor">Equals(<span class="params">name</span>,<span class="params">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>unit test类<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"> <span class="built_in">public</span> <span class="type">void</span> hello() throws <span class="keyword">Exception</span> &#123;</span><br><span class="line">     MockHttpServletRequestBuilder requestBuilder = MockMvcRequestBuilders.<span class="keyword">get</span>(&quot;/hello&quot;)</span><br><span class="line">             .contentType(MediaType.APPLICATION_FORM_URLENCODED)</span><br><span class="line">             .param(&quot;name&quot;,&quot;world&quot;);</span><br><span class="line">     ResultActions resultActions = mockMvc.<span class="keyword">perform</span>(requestBuilder);</span><br><span class="line">     resultActions.andDo(MockMvcResultHandlers.print());</span><br><span class="line">     resultActions.andExpect(status().<span class="keyword">is</span>(<span class="number">200</span>));</span><br><span class="line">     resultActions.andExpect(content().string(&quot;hello world&quot;));</span><br><span class="line">     Mockito.verify(helloDao, <span class="built_in">new</span> HelloServiceVerification(<span class="number">1</span>, &quot;world&quot;)).hello(Mockito.<span class="keyword">any</span>(String.<span class="keyword">class</span>));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="junit4-spring-boot"><a href="#junit4-spring-boot" class="headerlink" title="junit4 +spring boot"></a>junit4 +spring boot</h1><ul><li>代码<a href="https://github.com/peterTanBlog/SpringbootJunit4.git">SpringbootJunit4</a> 分支main,jdk8</li><li>unit test code<br>spring boot整合junit4 test<br>要使用@RunWith(SpringJUnit4ClassRunner.class)<br>@SpringBootTest注解<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.<span class="keyword">class</span>)</span><br><span class="line">@SpringBootTest(classes = SpringbootJunit4Application.<span class="keyword">class</span>)</span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> HelloWorldControllerTest &#123;</span><br><span class="line"></span><br><span class="line">    protected MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    protected WebApplicationContext webApplicationContext;</span><br><span class="line"></span><br><span class="line">    @<span class="keyword">Before</span></span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> setup() throws <span class="keyword">Exception</span> &#123;</span><br><span class="line">        <span class="keyword">Assert</span>.<span class="keyword">notNull</span>(webApplicationContext, &quot;&#x27;webApplicationContext&#x27; must not be null&quot;);</span><br><span class="line">        MockitoAnnotations.initMocks(this);</span><br><span class="line">        this.mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build();</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> hello() throws <span class="keyword">Exception</span> &#123;</span><br><span class="line">        MockHttpServletRequestBuilder requestBuilder = MockMvcRequestBuilders.<span class="keyword">get</span>(&quot;/hello&quot;)</span><br><span class="line">                .contentType(MediaType.APPLICATION_FORM_URLENCODED)</span><br><span class="line">                .param(&quot;name&quot;, &quot;world&quot;);</span><br><span class="line">        ResultActions resultActions = mockMvc.<span class="keyword">perform</span>(requestBuilder);</span><br><span class="line">        resultActions.andDo(MockMvcResultHandlers.print());</span><br><span class="line">        resultActions.andExpect(status().<span class="keyword">is</span>(<span class="number">200</span>));</span><br><span class="line">        resultActions.andExpect(content().string(&quot;hello world&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Spring-junit-4"><a href="#Spring-junit-4" class="headerlink" title="Spring+junit 4"></a>Spring+junit 4</h1><ul><li>controller code ,jdk8<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">&quot;/hello&quot;</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="title class_">String</span> <span class="title function_">hello</span>(<span class="params"><span class="built_in">String</span> name</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span>+name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>test code<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.<span class="keyword">class</span>)</span><br><span class="line">@WebAppConfiguration</span><br><span class="line">@ContextConfiguration(locations =&#123;&quot;classpath*:/application-context.xml&quot;&#125;)</span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> HelloControllerTest &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    protected WebApplicationContext webApplicationContext;</span><br><span class="line">    protected MockMvc mockMvc;</span><br><span class="line">    @<span class="keyword">Before</span></span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> setup() throws <span class="keyword">Exception</span> &#123;</span><br><span class="line">        <span class="keyword">Assert</span>.<span class="keyword">notNull</span>(webApplicationContext, &quot;&#x27;webApplicationContext&#x27; must not be null&quot;);</span><br><span class="line">        MockitoAnnotations.initMocks(this);</span><br><span class="line">       this.mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext)</span><br><span class="line">               .build();</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> hello() throws <span class="keyword">Exception</span> &#123;</span><br><span class="line">        MockHttpServletRequestBuilder requestBuilder = MockMvcRequestBuilders.<span class="keyword">get</span>(&quot;/hello&quot;)</span><br><span class="line">                .contentType(MediaType.APPLICATION_FORM_URLENCODED)</span><br><span class="line">                .param(&quot;name&quot;, &quot;world&quot;);</span><br><span class="line">        ResultActions resultActions = mockMvc.<span class="keyword">perform</span>(requestBuilder);</span><br><span class="line">        resultActions.andDo(MockMvcResultHandlers.print());</span><br><span class="line">        resultActions.andExpect(status().<span class="keyword">is</span>(<span class="number">200</span>));</span><br><span class="line">        resultActions.andExpect(content().string(&quot;hello world&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Junittest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Junit5 </tag>
            
            <tag> Junit4 </tag>
            
            <tag> Spring junittest </tag>
            
            <tag> Springboot junittest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows 技巧</title>
      <link href="/2022/09/08/windows-%E6%8A%80%E5%B7%A7/"/>
      <url>/2022/09/08/windows-%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h1><ul><li><p>下载地址：<br><a href="https://github.com/MicrosoftArchive/redis/releases">redis</a></p></li><li><p>选择下载msi 文件进行安装</p></li><li><p>若redis服务启动失败，到redis 安装目录打开 cmd窗口 执行以下命令</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server<span class="selector-class">.exe</span> redis<span class="selector-class">.windows</span><span class="selector-class">.conf</span>  </span><br></pre></td></tr></table></figure></li><li><p>我安装完成启动失败出现Can’t handle RDB format version 7 Fatal error loading the DB: Invalid argument. Exiting.</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  解决：删除 安装目录所有的dump.rdb文件，重新启动redis-<span class="keyword">server</span>。</span><br></pre></td></tr></table></figure></li><li><p>常用命令</p><ul><li><p>安装服务：redis-server.exe –service-install redis.windows.conf –service-name redisserver1 –loglevel verbose</p></li><li><p>启动服务：redis-server.exe  –service-start –service-name redisserver1</p></li><li><p>停止服务：redis-server.exe  –service-stop –service-name redisserver1</p></li><li><p>卸载服务：redis-server.exe  –service-uninstall–service-name redisserver1</p></li></ul></li></ul><h1 id="Windows-查看端口号被哪个程序占用"><a href="#Windows-查看端口号被哪个程序占用" class="headerlink" title="Windows 查看端口号被哪个程序占用"></a>Windows 查看端口号被哪个程序占用</h1><ul><li>打开git bash 窗口</li><li>查找某一特定端口<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano <span class="string">|grep &quot;</span><span class="number">62001</span><span class="string">&quot;</span></span><br></pre></td></tr></table></figure></li><li>显示进程信息<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist <span class="string">|findstr &quot;</span><span class="number">15936</span><span class="string">&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="windows-端口转发"><a href="#windows-端口转发" class="headerlink" title="windows 端口转发"></a>windows 端口转发</h1><ul><li><p>转发（3389 -&gt; 9989）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span>listenaddress - 等待连接的本地IP地址。</span><br><span class="line"><span class="regexp">//</span>listenport - 本地侦听TCP端口。</span><br><span class="line"><span class="regexp">//</span>connectaddress - 将传入连接重定向到本地或远程IP地址（或DNS名称）。</span><br><span class="line">netsh interface portproxy add v4tov4 listenport=<span class="number">9989</span> listenaddress=<span class="number">192.168</span>.<span class="number">3.5</span> connectport=<span class="number">3389</span> connectaddress=<span class="number">192.168</span>.<span class="number">3.5</span></span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh<span class="built_in"> interface </span>portproxy delete v4tov4 <span class="attribute">listenport</span>=9989 <span class="attribute">listenaddress</span>=192.168.3.5</span><br></pre></td></tr></table></figure></li><li><p>查看</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh <span class="keyword">interface</span> <span class="symbol">portproxy</span> <span class="symbol">show</span> <span class="symbol">all</span></span><br></pre></td></tr></table></figure></li><li><p>查找</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano <span class="string">| findstr :9989</span></span><br></pre></td></tr></table></figure></li><li><p>查看已配置的“端口映射”清单</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh <span class="keyword">interface</span> <span class="symbol">portproxy</span> <span class="symbol">show</span> <span class="symbol">v4tov4</span></span><br></pre></td></tr></table></figure></li><li><p>清除所有当前的端口转发规则：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh <span class="keyword">interface</span> <span class="symbol">portproxy</span> <span class="symbol">reset</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="wsl-装ubuntu"><a href="#wsl-装ubuntu" class="headerlink" title="wsl 装ubuntu"></a>wsl 装ubuntu</h1><h2 id="步骤-1-启用适用于-Linux-的-Windows-子系统"><a href="#步骤-1-启用适用于-Linux-的-Windows-子系统" class="headerlink" title="步骤 1 - 启用适用于 Linux 的 Windows 子系统"></a>步骤 1 - 启用适用于 Linux 的 Windows 子系统</h2><p>需要先启用“适用于 Linux 的 Windows 子系统”可选功能，然后才能在 Windows 上安装 Linux 分发。 </p><p>以管理员身份打开 PowerShell（“开始”菜单 &gt;“PowerShell” &gt;单击右键 &gt;“以管理员身份运行”），然后输入以下命令： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart </span><br></pre></td></tr></table></figure><h2 id="步骤-2-检查运行-WSL-2-的要求"><a href="#步骤-2-检查运行-WSL-2-的要求" class="headerlink" title="步骤 2 - 检查运行 WSL 2 的要求"></a>步骤 2 - 检查运行 WSL 2 的要求</h2><p>若要更新到 WSL 2，需要运行 Windows 10。</p><p>对于 x64 系统：版本 1903 或更高版本，内部版本为 18362 或更高版本。 </p><p>对于 ARM64 系统：版本 2004 或更高版本，内部版本为 19041 或更高版本。 或 Windows 11。 </p><p>若要检查 Windows 版本及内部版本号，选择 Windows 徽标键 + R，然后键入“winver”，选择“确定”。 </p><h2 id="步骤-3-启用虚拟机功能"><a href="#步骤-3-启用虚拟机功能" class="headerlink" title="步骤 3 - 启用虚拟机功能"></a>步骤 3 - 启用虚拟机功能</h2><p>安装 WSL 2 之前，必须启用“虚拟机平台”可选功能。 计算机需要虚拟化功能才能使用此功能。 </p><p>以管理员身份打开 PowerShell 并运行： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart </span><br></pre></td></tr></table></figure><p>重新启动计算机，以完成 WSL 安装并更新到 WSL 2。</p><h2 id="步骤-4-下载-Linux-内核更新包"><a href="#步骤-4-下载-Linux-内核更新包" class="headerlink" title="步骤 4 - 下载 Linux 内核更新包"></a>步骤 4 - 下载 Linux 内核更新包</h2><p>下载：<a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi</a> </p><p>运行上一步中下载的更新包。 （双击以运行 - 系统将提示你提供提升的权限，选择“是”以批准此安装。） </p><p>安装完成后，请继续执行下一步 - 在安装新的 Linux 分发时，将 WSL 2 设置为默认版本。 </p><h2 id="步骤-5-将-WSL-2-设置为默认版本"><a href="#步骤-5-将-WSL-2-设置为默认版本" class="headerlink" title="步骤 5 - 将 WSL 2 设置为默认版本"></a>步骤 5 - 将 WSL 2 设置为默认版本</h2><p>打开 PowerShell，然后在安装新的 Linux 发行版时运行以下命令，将 WSL 2 设置为默认版本： </p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --<span class="keyword">set</span>-<span class="keyword">default</span>-version <span class="number">2</span> </span><br></pre></td></tr></table></figure><h2 id="步骤-6-安装所选的-Linux-分发"><a href="#步骤-6-安装所选的-Linux-分发" class="headerlink" title="步骤 6 - 安装所选的 Linux 分发"></a>步骤 6 - 安装所选的 Linux 分发</h2><ul><li>下载Ubuntu 20.04 文件有点大：<a href="https://aka.ms/wslubuntu2004">https://aka.ms/wslubuntu2004</a> </li><li>安装Powershell 管理员执行： <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Add</span>-AppxPackage .\CanonicalGroupLimited.UbuntuonWindows_2004.<span class="number">2021</span>.<span class="number">825</span>.<span class="number">0</span>.AppxBundle </span><br></pre></td></tr></table></figure></li></ul><h2 id="打开ubuntu"><a href="#打开ubuntu" class="headerlink" title="打开ubuntu"></a>打开ubuntu</h2><ul><li>windows 菜单 打开ubuntu 设置用户名和密码<br>用户名和密码特定于安装的每个单独的 Linux 分发版，与 Windows 用户名无关。</li></ul><p>请注意，输入 密码时，屏幕上不会显示任何内容。 这称为盲目键入。  </p><p>不会看到正在键入的内容，这完全正常。 </p><p>创建用户名和密码后，该帐户将是分发版的默认用户，并将在启动时自动登录。此帐户将被视为 Linux 管理员，能够运行 sudo (Super User Do) 管理命令。 </p><p>在 WSL 上运行的每个 Linux 发行版都有其自己的 Linux 用户帐户和密码。 每当添加分发版、重新安装或重置时，都必须配置一个 Linux 用户帐户。 </p><h2 id="设置dns"><a href="#设置dns" class="headerlink" title="设置dns:"></a>设置dns:</h2><p>设置dns（无法上网就设置dns 地址-跟主机dns 地址一样） </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo tee <span class="regexp">/etc/</span>resolv.conf&lt;&lt;-<span class="string">&#x27;EOF&#x27;</span> </span><br><span class="line">nameserver <span class="number">10.202</span>.<span class="number">117.149</span> </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>wsl –shutdown   #停止 </p><ul><li>Localhost 转发至ubuntu(重启后ip会变化)</li></ul><p><a href="#windows-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91">#windows-端口转发</a></p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2022/09/05/JVM/"/>
      <url>/2022/09/05/JVM/</url>
      
        <content type="html"><![CDATA[<h1 id="java代码时如何运行起来"><a href="#java代码时如何运行起来" class="headerlink" title="java代码时如何运行起来"></a>java代码时如何运行起来</h1><ul><li>1 把我们的代码编译打包 jar</li><li>2 java -jar 运行我们得代码</li><li>3 java采用类加载器把编译好得那些class 字节码文件给加载到JVM中，然后供后续代码运行来使用</li><li>4 jvm就会基于自己得字节码执行引擎，来执行加载到内存里得类<br>（比如你的代码有一个 main 方法那么JVM就会有这个 main 方法开始执行里面得代码，它需要哪个类，就会使用类加载器来加载对应，反正对应得类就在.class文件中）</li></ul><p><img src="/2022/08/26/JV/pasted-0.png" alt="java代码时如何运行起来"></p><h1 id="JVM在什么情况下会加载一个类"><a href="#JVM在什么情况下会加载一个类" class="headerlink" title="JVM在什么情况下会加载一个类"></a>JVM在什么情况下会加载一个类</h1><p>其实类加载过程非常的琐碎复杂，但是对于我们平时从工作中实用的角度来说，主要是把握他的核心工作原理就可以。</p><p>一个类从加载到使用，一般会经历下面的这个过程：<br>加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 -&gt; 使用 -&gt; 卸载</p><p>所以首先要搞明白的第一个问题，就是JVM在执行我们写好的代码的过程中，一般在什么情况下会去加载一个类呢？</p><p>也就是说，啥时候会从“.class”字节码文件中加载这个类到JVM内存里来。</p><p>其实答案非常简单，就是在你的代码中用到这个类的时候。</p><ul><li>加载</li><li>验证<br>校验你加载进来JVM规范</li><li>准备<br>类变量分配一定的内存空间 </li><li>解析<br>符号引用替换为直接引用的过程<br>此过程很复杂，涉及到JVM的底层</li><li>核心阶段：初始化<br>类初始化代码<br>规则：初始化一个类的时候，发现他的父亲还未初始化，那么必须先初始化父类？</li><li>类加载器+双亲委派机制<ul><li>启动类加载器 Bootstrap ClassLoader，他主要是负责加载我们在机器上安装的Java目录下的核心类的，java安装目录lib</li><li>扩展类加载器 Extension ClassLoader，这个类加载器其实也是类似的，就是你的Java安装目录下，有一个“lib\ext”目录</li><li>应用程序类加载Application ClassLoader</li><li>自定义类加载器<br>  自定义类加载器，去根据你自己的需求加载你的类。</li></ul></li></ul><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p><img src="/2022/08/26/JV/pasted-1.png" alt=" 双亲委派机制"></p><p>就是假设你的应用程序类加载器需要加载一个类，他首先会委派给自己的父类加载器去加载，最终传导到顶层的类加载器去加载<br>但是如果父类加载器在自己负责加载的范围内，没找到这个类，那么就会下推加载权利给自己的子类加载器。</p><p>这就是所谓的双亲委派模型：先找父亲去加载，不行的话再由儿子来加载。<br>这样的话，可以避免多层级的加载器结构重复加载某些类。</p><p><img src="/2022/08/26/JV/pasted-2.png" alt="双亲委派机制1"></p><h2 id="Tomcat的类加载机制"><a href="#Tomcat的类加载机制" class="headerlink" title="Tomcat的类加载机制"></a>Tomcat的类加载机制</h2><p>首先Tomcat的 类加载器体系如下图所示，他是自定义了很多类加载器的。</p><p><img src="/2022/08/26/JV/pasted-6.png" alt="Tomcat的类加载机制"><br>Tomcat自定义了Common、Catalina、Shared等类加载器，其实就是用来加载Tomcat自己的一些核心基础类库的。然后Tomcat为每个部署在里面的Web应用都有一个对应的WebApp类加载器，负责加载我们部署的这个Web应用的类<br>至于Jsp类加载器，则是给每个JSP都准备了一个Jsp类加载器。<br>而且大家一定要记得，Tomcat是打破了双亲委派机制的<br>每个WebApp负责加载自己对应的那个Web应用的class文件，也就是我们写好的某个系统打包好的war包中的所有class文件，不会传导给上层类加载器去加载。<br>tomcat打破了双亲委派的原则，实际是在应用类加载器中打破了双亲委派，其他类加载器还是遵循双亲委派的。</p><h1 id="java内存区域划分"><a href="#java内存区域划分" class="headerlink" title="java内存区域划分"></a>java内存区域划分</h1><ul><li><p>存在类的方法区<br>主要是放从“.class”文件里加载进来的类，还会有一些类似常量池的东西放在这个区域里。</p><ul><li>1.8前:方法区</li><li>1.8后：Metaspace</li></ul></li><li><p>执行代码指令用的程序计数器</p></li></ul><p>我们写好的Java代码会被翻译成字节码，对应各种字节码指令</p><p>就是用来记录当前执行的字节码指令的位置的，也就是记录目前执行到了哪一条字节码指令</p><ul><li>java虚拟机栈</li></ul><p>JVM必须有一块区域是来保存每个方法内的局部变量等数据的，这个区域就是Java虚拟机栈<br>每个线程都有自己的Java虚拟机栈</p><ul><li><p>java 堆内存<br>这里就是存放我们在代码中创建的各种对象的</p></li><li><p>本地方法栈</p></li></ul><p>在调用这种native方法的时候，就会有线程对应的本地方法栈<br>是跟Java虚拟机栈类似的，也是存放各种native方<br>法的局部变量表之类的信息。</p><p><img src="/2022/08/26/JV/pasted-3.png" alt="java 内存区域"></p><h1 id="java-垃圾回收"><a href="#java-垃圾回收" class="headerlink" title="java 垃圾回收"></a>java 垃圾回收</h1><p>我们在Java堆内存里创建的对象，都是占用内存资源的，而且内存资源有限。</p><p>你只要启动一个JVM进程，他就会自带这么一个垃圾回收的后台线程。<br>这个线程会在后台不断检查JVM堆内存中的各个实例对象，这些不再被人指向的对象实例，即JVM中的“垃圾”，就会定期的被后台垃圾回收线程清理掉，不断释放内存资源</p><p><img src="/2022/08/26/JV/pasted-4.png" alt="java 垃圾回收"></p><h1 id="jvm-分代模型"><a href="#jvm-分代模型" class="headerlink" title="jvm 分代模型"></a>jvm 分代模型</h1><p>年轻代，老年代，永久代</p><ul><li>大部分对象都是存活周期短的</li><li>少数对象时长期活的</li></ul><h2 id="年轻代"><a href="#年轻代" class="headerlink" title="年轻代"></a>年轻代</h2><ul><li>很快就要被回收的对象</li><li>大部分的正常对照都是优先再新生代分配内存</li><li>新生代的内存垃圾回收叫Minor GC 或者叫Young GC</li><li>新生代如果对象满了，会触发Minor GC 回收掉没有人引用的垃圾对象</li><li>大部分的正常对象，都是优先在新生代分配内存的</li></ul><h2 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h2><ul><li>长期存在的对象</li><li>长期存活的对象躲过多次垃圾回收 就会进入老年代，15（动态对象年龄判断机制）次</li><li>如果老年代也满了，那么也会触发垃圾回收，把老年代里没人引用的垃圾对象清理掉</li></ul><h2 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h2><p>我们之前说的方法区，可以放一些类信息</p><p>一般永久代刚开始上线一个系统，没太多可以参考的规范，但是一般你设置个几百MB</p><h2 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h2><ul><li>-Xms：<br>Java堆内存的刚开始的大小</li><li>-Xmx：<br>Java堆内存的最大大小<br>-Xms喝-Xmx通常会设置完全一样的大小</li><li>-Xmn：<br>Java堆内存中的新生代大小，扣除新生代剩下的就是老年代的内存大小了</li><li>-XX:PermSize：<br>永久代大小</li><li>-XX:MaxPermSize：<br>永久代最大大小</li></ul><p>JDK 1.8以后的版本，那么这俩参数被替换为了-XX:MetaspaceSize和-XX:MaxMetaspaceSize，</p><ul><li>-Xss：每个线程的栈内存大小</li></ul><p>，每个线程都有一个自己的虚拟机栈，然后每次执行一个方法，就会将方法的栈帧压入线程的栈里，方法执行完<br>毕，那么栈帧就会从线程的栈里出栈<br>一般也不会特别的去预估和设置的，一般默认就是比如512KB到1MB<br><img src="/2022/08/26/JV/pasted-5.png" alt="jvm 分代模型"></p><ul><li>下面如何设置java程序 jvm参数<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms512M -Xmx512M -Xmn256M -Xss1M -XX:<span class="attribute">PermSize</span>=128M -XX:<span class="attribute">MaxPermSize</span>=128M -jar App.jar</span><br></pre></td></tr></table></figure></li><li>Tomcat、Spring Boot部署启动系统的时候，JVM参数如何设置？<br> tomcat jvm参数: <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">JAVA_OPTS</span>=<span class="string">&quot;-Xms512M -Xmx512M -Xmn256M -Xss1M -XX:PermSize=128M -XX:MaxPermSize=128M&quot;</span></span><br></pre></td></tr></table></figure> Spring Boot jvm参数： <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms512M -Xmx512M -Xmn256M -Xss1M -XX:<span class="attribute">PermSize</span>=128M -XX:<span class="attribute">MaxPermSize</span>=128M -jar App.jar</span><br></pre></td></tr></table></figure></li></ul><h1 id="到底什么情况下会触发新生代的垃圾回收？"><a href="#到底什么情况下会触发新生代的垃圾回收？" class="headerlink" title="到底什么情况下会触发新生代的垃圾回收？"></a>到底什么情况下会触发新生代的垃圾回收？</h1><h1 id="jvm-问题"><a href="#jvm-问题" class="headerlink" title="jvm 问题"></a>jvm 问题</h1><ul><li>我们在Java堆内存中分配的那些对象，到底会占用多少内存？一般怎么来计算和估算我们的系统创建的对象对内存占用的一个压力呢？<br>答：<br>一个对象对内存空间的占用，大致分为两块：<br>一个是对象自己本身的一些信息<br>一个是对象的实例变量作为数据占用的空间<br>比如对象头，如果在64位的linux操作系统上，会占用16字节，然后如果你的实例对象内部有个int类型的实例变量，他<br>会占用4个字节，如果是long类型的实例变量，会占用8个字节。如果是数组、Map之类的，那么就会占用更多的内存<br>了。</li></ul><h1 id="如何合理设置JVM内存大小"><a href="#如何合理设置JVM内存大小" class="headerlink" title="如何合理设置JVM内存大小"></a>如何合理设置JVM内存大小</h1><p>计算了这个系统在日百万交易的压力下，部署3台机器的场景下，每秒钟每台机器需要处理多少笔订单，每笔订单要耗时多久处理，每秒钟会对JVM占据多大内存空间，根据这个横向扩展预估整个系统每<br>秒需要占据多大内存空间。<br>接着根据上述数据模型推算出，在不同的机器配置之下，你的新生代大致会有多大的内存空间，然后在不同的新生代大小之<br>下，多久会触发一次Minor GC<br>为了避免频繁的GC，那么应该选用什么样的机器配置，部署多少台机器，给JVM堆内存多大的内存空间，新生代多大的内存<br>空间。<br>根据这套配置，就可以推算出来整个系统的运行模型了，每秒钟创建多少对象在新生代，然后1秒之后成为垃圾，大概系统运<br>行多久，新生代会触发一次GC，频率有多高 。</p><h1 id="如何合理设置永久代大小？"><a href="#如何合理设置永久代大小？" class="headerlink" title="如何合理设置永久代大小？"></a>如何合理设置永久代大小？</h1><p>话说回来，如何合理设置永久代大小呢？<br>其实一般永久代刚开始上线一个系统，没太多可以参考的规范，但是一般你设置个几百MB，大体上都是够用的<br>因为里面主要就是存放一些类的信息</p><h1 id="如何合理设置栈内存大小"><a href="#如何合理设置栈内存大小" class="headerlink" title="如何合理设置栈内存大小"></a>如何合理设置栈内存大小</h1><p>其实这个栈内存大小设置，一般也不会特别的去预估和设置的，一般默认就是比如512KB到1MB，就差不多够了。<br>这就是每个线程自己的栈内存空间，用来存放线程执行方法期间的各种布局变量的。后面也会用专门的案例演示，栈内存什么<br>时候会发生内存溢出。</p><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>后建立起来一个全面的工程素养，每个合格的工程师，都应该在上线系统的时候，对系统压力做出预估，<br>然后对JVM内存、磁盘空间大小、网络带宽、数据库压力做出预估，然后各方面都给出合理的配置。</p><h1 id="什么时候进行垃圾回收"><a href="#什么时候进行垃圾回收" class="headerlink" title="什么时候进行垃圾回收"></a>什么时候进行垃圾回收</h1><p>只要你的对象被方法的局部变量、类的静态变量给引用了，就不会回收他们。</p><ul><li>强引用</li></ul><p><img src="/2022/09/05/JV/pasted-0.png" alt="强引用"><br>一个变量引用一个对象，只要是强引用的类型，那么垃圾回收的时候绝对不会去回收这个对象的。</p><ul><li><p>软引用<br><img src="/2022/09/05/JV/pasted-2.png" alt="软引用"><br>正常情况下垃圾回收是不会回收软引用对象的，但是如果你进行垃圾回收之后，发现内存空间还是不够存放新的对象，内存都快溢出了<br>此时就会把这些软引用对象给回收掉，哪怕他被变量引用了，但是因为他是软引用，所以还是要回收。</p></li><li><p>弱引用<br>，你这个弱引用就跟没引用是类似的，如果发生垃圾回收，就会把这个对象回收掉。<br><img src="/2022/09/05/JV/pasted-3.png" alt="弱引用"></p></li><li><p>虚引用<br>因为很少用。</p></li><li><p>finalize()方法的作用</p></li></ul><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>把新生代内存划分为两块内存区域，然后只使用其中一块内存<br>待那块内存快满的时候，就把里面的存活对象一次性转移到另外一块内存区域，保证没有内存碎片<br>接着一次性回收原来那块内存区域的垃圾对象，再次空出来一块内存区域。两块内存区域就这么重复着循环使用。<br>缺点:对内存的使用效率太低了。</p><h2 id="Eden区和Survivor区"><a href="#Eden区和Survivor区" class="headerlink" title="Eden区和Survivor区"></a>Eden区和Survivor区</h2><p>真正的复制算法会做出如下优化，把新生代内存区域划分为三块：<br>1个Eden区，2个Survivor区，其中Eden区占80%内存空间，每一块Survivor区各占10%内存空间，比如说Eden区有800MB内存，每一块Survivor区就100MB内存，一块Survivor区就100MB内存，一块Survivor区就100MB内存，<br><img src="/2022/09/05/JV/pasted-4.png" alt="新生代"><br>好处:就是只有10%的内存空间是被闲置的，90%的内存都被使用上了无论是垃圾回收的性能，内存碎片的控制，还是说内存使用的效率，都非常的好。</p><h2 id="新生代垃圾回收的各种万一："><a href="#新生代垃圾回收的各种万一：" class="headerlink" title="新生代垃圾回收的各种万一："></a>新生代垃圾回收的各种万一：</h2><ul><li>躲过15次GC之后进入老年代<br>“-XX:MaxTenuringThreshold”来设置，默认是15岁</li><li>一批对象的总大小大于了这块Survivor区域的内存大小的50%，那么此时大<br>于等于这批对象年龄的对象，就可以直接进入老年代了。(年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区<br>域的50%，此时就会把年龄n以上的对象都放入老年代)</li><li>大对象直接进入老年代：“-XX:PretenureSizeThreshold”，</li></ul><h2 id="Minor-GC后的对象太多无法放入Survivor区怎么办？"><a href="#Minor-GC后的对象太多无法放入Survivor区怎么办？" class="headerlink" title="Minor GC后的对象太多无法放入Survivor区怎么办？"></a>Minor GC后的对象太多无法放入Survivor区怎么办？</h2><ul><li>Minor GC后的对象太多无法放入Survivor区 就会把这些对象转移到老年代</li><li>老年代空间分配担保规则<ul><li>老年代空间也不够放这些对象<ul><li>老年代的可用内存已经小于了新生代的全部对象大小了，就会看一个“-XX:-HandlePromotionFailure”的参数是否设置了(是“-XX:-HandlePromotionFailure”参数没设置，此时就会直接触发一次“FullGC”，就是对老年代进行垃圾回收，尽量腾出来一些内存空间，然后再执行Minor GC。) 是看看老年代的内存大小，是否大于之前每一次Minor GC后进入老年代的对象的平均大小</li><li>第一种可能，Minor GC过后，剩余的存活对象的大小，是小于Survivor区的大小的，那么此时存活对象进入Survivor区域即可。</li><li>第二种可能，Minor GC过后，剩余的存活对象的大小，是大于 Survivor区域的大小，但是是小于老年代可用内存大小的，此时就直接进入老年代即可。</li><li>很不幸，Minor GC过后，剩余的存活对象的大小，大于了Survivor区域的大小，也大于了老年代可用内<br>存的大小。此时老年代都放不下这些存活对象了，就会发生“Handle Promotion Failure”的情况，这个时候就会触<br>发一次“Full GC”。</li><li>Full GC就是对老年代进行垃圾回收，同时也一般会对新生代进行垃圾回收。<br>因为这个时候必须得把老年代里的没人引用的对象给回收掉，然后才可能让Minor GC过后剩余的存活对象进入老年代<br>里面。如果要是Full GC过后，老年代还是没有足够的空间存放Minor GC过后的剩余存活对象，那么此时就会导致所谓的<br>“OOM”内存溢出了</li></ul></li></ul></li></ul><p><img src="/2022/09/05/JV/pasted-6.png" alt="Minor GC后的对象太多无法放入Survivor区"></p><h2 id="老年代垃圾回收算法"><a href="#老年代垃圾回收算法" class="headerlink" title="老年代垃圾回收算法"></a>老年代垃圾回收算法</h2><p>标记整理算法</p><ul><li>首先标记出来老年代当前存活的对象，这些对象可能是东一个西一个的。</li><li>接着会让这些存活对象在内存里进行移动，把存活对象尽量都挪动到一边去，让存活对象紧凑的靠在一起，避免垃圾回收过后出现过多的内存碎片然后再一次性把垃圾对象都回收掉</li></ul><p><img src="/2022/09/05/JV/pasted-5.png" alt="标记整理算法"></p><ul><li>这个老年代的垃圾回收算法的速度至少比新生代的垃圾回收算法的速度慢10倍。<br>如果系统频繁出现老年代的Full GC垃圾回收，会导致系统性能被严重影响，出现频繁卡顿的情况。</li></ul><h1 id="常见垃圾回收器"><a href="#常见垃圾回收器" class="headerlink" title="常见垃圾回收器"></a>常见垃圾回收器</h1><ul><li>Serial和Serial Old垃圾回收器：分别用来回收新生代和老年代的垃圾对象–单线程</li><li>ParNew和CMS垃圾回收器：ParNew现在一般都是用在新生代的垃圾回收器，CMS是用在老年代的垃圾回收器，他们都是多线程并发的机制，性能更好，现在一般是线上生产系统的标配组合</li></ul><p><img src="/2022/09/05/JV/pasted-7.png" alt="ParNew和CMS垃圾回收器"></p><ul><li>G1垃圾回收器：统一收集新生代 和老年代，采用了更加优秀的算法和设计机制，</li></ul><h2 id="stop-the-world"><a href="#stop-the-world" class="headerlink" title="stop the world"></a>stop the world</h2><ul><li>然后让垃圾回收线程可以专心致志的进行垃圾回收的工作使用JVM最大的痛点，其实就是在垃圾回收的这个过程<br>因为在垃圾回收的时候，尽可能要让垃圾回收器专心致志的干工作，不能随便让我们写的Java系统继续对象了，所以此时JVM会在后台<br>直接进入“Stop the World”状态。<br>也就是说，他会直接停止我们写的Java系统的所有工作线程，让我们写的代码不再运行！然后让垃圾回收线程可以专心致志的进行垃圾回收的工作</li></ul><p><img src="/2022/09/05/JV/pasted-10.png" alt="stop the world"><br>就可以让我们的系统暂停运行，然后不再创建新的对象，同时让垃圾回收线程尽快完成垃圾回收的工作，就是标记和转移<br>Eden以及Survivor2的存活对象到Survivor1中去，然后尽快一次性回收掉Eden和Survivor2中的垃圾对象，</p><p>现在大家就很清晰“Stop the World”会对系统造成的影响了， 假设我们的Minor GC要运行100ms，那么可能就会导致我们的系统<br>直接停顿100ms不能处理任何请求<br>在这100ms期间用户发起的所有请求都会出现短暂的卡顿，因为系统的工作线程不在运行，不能处理请求。</p><h2 id="ParNew-是如何工作"><a href="#ParNew-是如何工作" class="headerlink" title="ParNew 是如何工作"></a>ParNew 是如何工作</h2><ul><li>新生代垃圾回收器</li><li>使用“-XX:+UseParNewGC”选项，只要加入这个选项，JVM启动之后对新生代进行垃圾回收的，就是ParNew垃圾回收器了。</li><li>ParNew垃圾回收器默认情况下的线程数量：跟CPU核数一样的线程数量或使用“-XX:ParallelGCThreads”参数设置线程数（一般不要随意动这个参数）</li></ul><p><img src="/2022/09/05/JV/pasted-8.png" alt="ParNew"></p><ul><li><p>新生代的ParNew垃圾回收器主打的就是多线程垃圾回收机制，另外一种Serial垃圾回收器主打的是单线程垃圾回收，他们俩都是回收新生代的，唯一的区别就是单线程和多线程的区别，但是垃圾回收算法是完全一样的。</p></li><li><p>算法：标记-复制算法</p></li><li><p>如果“-XX:SurvivorRatio”参数默认值为8，那么此时新生代里Eden区大概占据了1.2GB内存，每个Survivor区是150MB的内存</p></li><li><p>参数<br>ParNew垃圾回收器的核心参数，其实就是配套的新生代内存大小、Eden和Survivor的比例，只要你设置合理，避免<br>Minor GC后对象放不下Survivor进入老年代，或者是动态年龄判定之后进入老年代，给新生代里的Survivor充足的空<br>间，那么Minor GC一般就没什么问题</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“-Xms3072M -Xmx3072M -Xmn2048M -Xss1M -XX:<span class="attribute">PermSize</span>=256M -XX:<span class="attribute">MaxPermSize</span>=256M -</span><br><span class="line">XX:<span class="attribute">SurvivorRatio</span>=8 -XX:<span class="attribute">MaxTenuringThreshold</span>=5 -XX:<span class="attribute">PretenureSizeThreshold</span>=1M -XX:+UseParNewGC -</span><br><span class="line">XX:+UseConcMarkSweepGC”</span><br></pre></td></tr></table></figure></li></ul><h2 id="对象什么时候进入老年代"><a href="#对象什么时候进入老年代" class="headerlink" title="对象什么时候进入老年代"></a>对象什么时候进入老年代</h2><ul><li><p>首先第一种情况，那绝对就是“-XX:MaxTenuringThreshold&#x3D;5”这个参数会让在一两分钟内连续躲过5次Minor GC的对象迅速进入老年代中。<br>*（1）没有打开“ -XX:HandlePromotionFailure”选项，结果老年代可用内存最多也就1G，新生代对象总大小最多可<br>以有1.8G<br>那么会导致每次Minor GC前一检查，都发现“老年代可用内存” &lt; “新生代总对象大小”，这会导致每次Minor GC<br>前都触发Full GC。<br>当然，上篇文章提到过了，现在JDK 1.6以后的版本废弃了这个参数，其实只要满足下面第二个条件就可以直接触发<br>Minor GC，不需要触发Full GC。<br>*（2）每次Minor GC之前，都检查一下“老年代可用内存空间” &lt; “历次Minor GC后升入老年代的平均对象大小”<br>其实按照我们目前设定的背景，要很多次Minor GC之后才可能有一两次碰巧会有200MB对象升入老年代，所以这个<br>“历次Minor GC后升入老年代的平均对象大小”，基本是很小的。<br>*（3）可能某次Minor GC后要升入老年代的对象有几百MB，但是老年代可用空间不足了<br>*（4）设置了“-XX:CMSInitiatingOccupancyFaction”参数，比如设定值为92%，那么此时可能前面几个条件都没满<br>足，但是刚好发现这个条件满足了，比如就是老年代空间使用超过92%了，此时就会自行触发Full GC</p></li><li><p>参数<br>Full GC优化的前提是Minor GC的优化，Minor GC的优化的前提是合理分配内存空间，合理分<br>配内存空间的前提是对系统运行期间的内存使用模型进行预估。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">“-Xms3072M -Xmx3072M -Xmn2048M -Xss1M -XX:<span class="attribute">PermSize</span>=256M -XX:<span class="attribute">MaxPermSize</span>=256M -</span><br><span class="line">XX:<span class="attribute">SurvivorRatio</span>=8 -XX:<span class="attribute">MaxTenuringThreshold</span>=5 -XX:<span class="attribute">PretenureSizeThreshold</span>=1M -XX:+UseParNewGC -</span><br><span class="line">XX:+UseConcMarkSweepGC -XX:<span class="attribute">CMSInitiatingOccupancyFaction</span>=92 -XX:+UseCMSCompactAtFullCollection</span><br><span class="line">-XX:<span class="attribute">CMSFullGCsBeforeCompaction</span>=0</span><br></pre></td></tr></table></figure></li></ul><h2 id="CMS-垃圾回收器"><a href="#CMS-垃圾回收器" class="headerlink" title="CMS 垃圾回收器"></a>CMS 垃圾回收器</h2><ul><li><p>算法：标记清理算法</p></li><li><p>初始标记<br>stop the world状态（系统的工作线程全部停止）<br>影响不大，速度很快</p></li><li><p>并发标记<br>让系统可以随意创建各种对象，继续运行<br>对老年代所有所有对象进行Gc Roots追踪，其实最耗时<br>，跟系统程序并发运行，对系统运行造成影响<br>他需要追踪所有对象是否从根源上被GC Roots引用了，但是这个最耗时的阶段，是跟系统程序并发运行的，所以其实这个阶段不会对<br>系统运行造成影响的。</p></li><li><p>重新标记<br>stop the world状态（系统的工作线程全部停止）<br>是速度很快的，他其实就是对在第二阶段中被系统程序运行变动过的少数对象进行标记，所以运行速度很快</p></li><li><p>并发清理<br>是让系统程序随意运行，然后他来清理掉之前标记为垃圾的对象即可。<br>因为需要进行对象的清理，但是他也是跟系统程序并发运行的，所以其实也不影响系统程序的执行</p></li></ul><p><img src="/2022/09/05/JV/pasted-9.png" alt="cms"></p><ul><li><p>总结 :最耗时的，其实就是对老年代全部对相关进行GC Roots追踪，标记出来到底哪些可以回收，然后就是对各种垃圾对象从内存里清理掉，这是最耗时的。第二阶段和第四阶段，都是和系统程序并发执行的，基本这两个最耗时的阶段对性能影响不大。<br>第一个阶段和第三个阶段是需要“Stop the World”的，但是这两个阶段都是简单的标记而已，速度非常的快，所以基本上对系<br>统运行响应也不大。</p></li><li><p>“-XX:MaxTenuringThreshold”参数的默认值15次来说</p></li><li><p>-XX:PretenureSizeThreshold&#x3D;1M 大对象进入老年代</p></li></ul><h3 id="cms-性能分析"><a href="#cms-性能分析" class="headerlink" title="cms 性能分析"></a>cms 性能分析</h3><p>CMS垃圾回收器有一个最大的问题，虽然能在垃圾回收的同时让系统同时工作，但是大家发现没有，在并发标记和并发清理两个最耗时<br>的阶段，垃圾回收线程和系统工作线程同时工作，会导致有限的CPU资源被垃圾回收线程占用了一部分<br>CMS垃圾回收器有一个最大的问题，虽然能在垃圾回收的同时让系统同时工作，但是大家发现没有，在并发标记和并发清理两个最耗时<br>的阶段，垃圾回收线程和系统工作线程同时工作，会导致有限的CPU资源被垃圾回收线程占用了一部分。<br>CMS的垃圾回收线程是比较耗费CPU资源的。CMS默认启动的垃圾回收线程的数量是（CPU核数 + 3）&#x2F; 4。</p><p>“-XX:CMSInitiatingOccupancyFaction”参数可以用来设置老年代占用多少比例的时候触发CMS垃圾回收，JDK 1.6里面默认的值是<br>92%。</p><p>如果内存碎片太多，会导致后续对象进入老年代找不到可用的连续内存空间了，然后触发Full GC。<br>所以CMS不是完全就仅仅用“标记-清理”算法的，因为太多的内存碎片实际上会导致更加频繁的Full GC。</p><ul><li><p>CMS有一个参数是“-XX:+UseCMSCompactAtFullCollection”，默认就打开了是在Full GC之后要再次进行“Stop the World”，停止工作线程，然后进行碎片整理，就是把存活对象挪到一起，空出来大片<br>连续内存空间，避免内存碎片。</p></li><li><p>-XX:CMSFullGCsBeforeCompaction”，这个意思是执行多少次FullGC之后再执行一次内存碎片整理的工作，默认是0，意思就是每次FullGC之后都会进行一次内存整理。</p></li><li><p>-XX:+UseParNewGC -<br>XX:+UseConcMarkSweepGC” 指定新生代回收器，指定老年代回收器</p></li></ul><h1 id="G1-垃圾回收器"><a href="#G1-垃圾回收器" class="headerlink" title="G1 垃圾回收器"></a>G1 垃圾回收器</h1><ul><li>ParNew + CMS带给我们的痛点是什么？<br>stop the world</li></ul><p>之后对垃圾回收器的优化，都是朝着减少“Stop the World”的目标去做的。</p><p>G1垃圾回收器是可以同时回收新生代和老年代的对象的</p><p>他最大的一个特点，就是把Java堆内存拆分为多个大小相等的Region 后G1也会有新生代和老年代的概念，但是只不过是逻辑上的概念<br>也就是说，新生代可能包含了某些Region，老年代可能包含了某些Reigon，<br><img src="/2022/09/05/JV/pasted-11.png" alt="G1垃圾回收器"></p><ul><li>可以让我们设置一个垃圾回收的预期停顿时间</li></ul><p>希望G1在垃圾回收的时候，可以保证，在1小时内由G1垃圾回收导致的“Stop the World”时间，<br>也就是系统停顿的时间，不能超过1分钟。</p><ul><li>其实我们对内存合理分配，优化一些参数，就是为<br>了尽可能减少Minor GC和Full GC，尽量减少GC带来的系统停顿，避免影响系统处理请求。</li></ul><h2 id="G1是如何做到对垃圾回收导致的系统停顿可控的？"><a href="#G1是如何做到对垃圾回收导致的系统停顿可控的？" class="headerlink" title="G1是如何做到对垃圾回收导致的系统停顿可控的？"></a>G1是如何做到对垃圾回收导致的系统停顿可控的？</h2><p>G1可以做到让你来设定垃圾回收对系统的影响，他自己通过把内存拆分为大量小Region，以及追踪每个Region中可以<br>回收的对象大小和预估时间，最后在垃圾回收的时候，尽量把垃圾回收对系统造成的影响控制在你指定的时间范围内，同时在有限的时间内尽量回收尽可能多的垃圾对象。</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li><p>用“-XX:+UseG1GC”来指定使用G1垃圾回收器，<br>因为JVM最多可以有2048个Region，然后Region的大小必须是2的倍数，比如说1MB、2MB、4MB之类的。<br>比如说堆大小是4G，那么就是4096MB，此时除以2048个Region，每个Region的大小就是2MB。大概就是这样子来决定Region的数<br>量和大小的，大家一般保持默认的计算方式就可以<br>如果通过手动方式来指定，则是“-XX:G1HeapRegionSize”，</p></li><li><p>刚开始的时候，默认新生代对堆内存的占比是5%，也就是占据200MB左右的内存，对应大概是100个Region，这个是可以通过“-<br>XX:G1NewSizePercent”来设置新生代初始占比的，其实维持这个默认值即可。</p></li><li><p>因为在系统运行中，JVM其实会不停的给新生代增加更多的Region，但是最多新生代的占比不会超过60%，可以通过“-<br>XX:G1MaxNewSizePercent”。</p></li><li><p>新生代还有Eden和Survivor的概念吗？<br>“-XX:SurvivorRatio&#x3D;8”，所以这里还是可以区分出来属于新生代的Region里哪些属于Eden，哪些哪些属于Survivor。<br>，有100个Region，那么可能80个Region就是Eden，两个Survivor各自占10个Region，如下<br>图。</p></li><li><p>因为G1是可以设定目标GC停顿时间的，也就是G1执行GC的时候最多可以让系统停顿多长时间，可<br>以通过“-XX:MaxGCPauseMills”参数来设定，默认值是200ms。</p></li></ul><h2 id="对象什么时候进入老年代-1"><a href="#对象什么时候进入老年代-1" class="headerlink" title="对象什么时候进入老年代"></a>对象什么时候进入老年代</h2><p>（1）对象在新生代躲过了很多次的垃圾回收，达到了一定的年龄了，“-XX:MaxTenuringThreshold”参数可以设置这个年龄，他就会进入老年代<br>（2）动态年龄判定规则，如果一旦发现某次新生代GC过后，存活对象超过了Survivor的50%<br>此时就会判断一下，比如年龄为1岁，2岁，3岁，4岁的对象的大小总和超过了Survivor的50%，此时4岁以上的对象全部会进入老年<br>代，这就是动态年龄判定规则</p><ul><li><p>大对象Region<br>G1提供了专门的Region来存放大对象<br>在G1中，大对象的判定规则就是一个大对象超过了一个Region大小的50%，比如按照上面算的，每个Region是2MB，只要一个大对象超过了1MB，就会被放入大对象专门的Region中<br>而且一个大对象如果太大，可能会横跨多个Region来存放。如下图。<br><img src="/2022/09/05/JV/pasted-12.png" alt="G1回收器"><br>其实新生代、老年代在回收的时候，会顺带带着大对象Region一起回收，所以这就是在G1内存模型下对大对象的分配和回<br>收的策略。</p></li><li><p>什么时候触发新生代+老年代的混合垃圾回收？</p><ul><li><p>G1有一个参数，是“-XX:InitiatingHeapOccupancyPercent”，他的默认值是45%</p></li><li><p>“-XX:G1MixedGCCountTarget”参数，就是在一次混合回收的过程中，最后一个阶段执行几次混合</p></li></ul></li></ul><p>回收，默认值是8次<br>意味着最后一个阶段，先停止系统运行，混合回收一些Region，再恢复系统运行，接着再次禁止系统运行，混合回收一些Region，反<br>复8次因为你停止系统一会儿，回收掉一些Region，再让系统运行一会儿，然后再次停止系统一会儿，再次回收掉一些Region，这样可以尽可能让系统不要停顿时间过长，可以在多次回收的间隙，也运行一下。</p><pre><code>* “-XX:G1HeapWastePercent”，默认值是5%</code></pre><p>在混合回收的时候，对Region回收都是基于复制算法进行的，都是把要回收的Region里的存活对象放入其他<br>Region，然后这个Region中的垃圾对象全部清理掉<br>    * “-XX:G1MixedGCLiveThresholdPercent”，他的默认值是85%，意思就是确定要回收的Region的时候，必须是存<br>活对象低于85%的Region才可以进行回收</p><h2 id="G1-回收过程"><a href="#G1-回收过程" class="headerlink" title="G1 回收过程"></a>G1 回收过程</h2><ul><li><p>初始标记<br>首先会触发一个“初始标记”的操作，这个过程是需要进入“Stop the World”的，仅仅只是标记一下GC Roots直接能引用的对象，<br>这个过程速度是很快</p></li><li><p>并发标记<br>允许系统程序的运行，同时进行GC Roots追踪，从GC Roots开始追踪所有的存活对象，</p></li><li><p>最终标记<br>会进入“Stop the World”，系统程序是禁止运行的，但是会根据并发标记 阶段记录的<br>那些对象修改，最终标记一下有哪些存活对象，有哪些是垃圾对象</p></li><li><p>混合回收<br>“混合回收“阶段，这个阶段会计算老年代中每个Region中的存活对象数量，存活对象的占比，还有执行垃圾回<br>收的预期性能和效率。会停止系统程序，然后全力以赴尽快进行垃圾回收，此时会选择部分Region进行回收，因为必须让垃圾回收的停顿时间控制在我们指定的范围内。<br>因为我们设定了对GC停顿时间的目标，所以说他会从新生代、老年代、大对象里各自挑选一些Region，保证用指定的时间（比如200ms）回收尽可能多的垃圾，这就是所谓的混合回收，</p></li><li><p>如果在进行Mixed回收的时候，无论是年轻代还是老年代都基于复制算法进行回收，都要把各个Region的存活对象拷贝到别的Region里去此时万一出现拷贝的过程中发现没有空闲Region可以承载自己的存活对象了，就会触发 一次失败。<br>一旦失败，立马就会切换为停止系统程序，然后采用单线程进行标记、清理和压缩整理，空闲出来一批Region，这个过程是极慢极慢<br>的。</p></li></ul><h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">“-Xms4096M -Xmx4096M -Xss1M -<span class="variable constant_">XX</span><span class="symbol">:PermSize=</span>256M -<span class="variable constant_">XX</span><span class="symbol">:MaxPermSize=</span>256M -<span class="variable constant_">XX</span><span class="symbol">:+UseG1GC</span>“</span><br><span class="line">“-<span class="variable constant_">XX</span><span class="symbol">:G1NewSizePercent</span>”参数是用来设置新生代初始占比的，不用设置，维持默认值为<span class="number">5</span>%即可。</span><br><span class="line">“-<span class="variable constant_">XX</span><span class="symbol">:G1MaxNewSizePercent</span>”参数是用来设置新生代最大占比的，也不用设置，维持默认值为<span class="number">60</span>%即可。</span><br><span class="line">就是“* -<span class="variable constant_">XX</span><span class="symbol">:MaxGCPauseMills</span>”，他的默认值是<span class="number">200</span></span><br><span class="line">毫秒</span><br></pre></td></tr></table></figure><ul><li>合理设置-XX:MaxGCPauseMills </li><li>是mixed gc的优化了<br>里核心还是在于调节“-XX:MaxGCPauseMills”这个参数的值，在保证他的新生代gc别太频繁的同时，还得考<br>虑每次gc过后的存活对象有多少，避免存活对象太多快速进入老年代，频繁触发mixed gc。</li></ul><h2 id="基于JVM运行的系统最怕什么？"><a href="#基于JVM运行的系统最怕什么？" class="headerlink" title="基于JVM运行的系统最怕什么？"></a>基于JVM运行的系统最怕什么？</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>微服务</title>
      <link href="/2022/09/03/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
      <url>/2022/09/03/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h1><ul><li><p>在软件设计中，经常提及和使用经典3层模型，即表示层、业务逻辑层、数据访问层。</p></li><li><p>表示层：用于直接和用户交互，也称为交互层，通常是网页、UI等</p></li><li><p>业务逻辑层：即业务逻辑处理层，例如用户输入的信息要经过业务逻辑层的处理后才能展现给用户</p></li><li><p>数据访问层：用于操作数据库，用户在表示层会产生大量的数据，通过数据访问层对数据库进行读写操作</p></li><li><p>一个经典的单体应用就是将所有的业务场景的表示层、业务逻辑层和数据访问层放在一个工程中最终经过编译、打包，部署在一台服务器上。</p></li></ul><p><img src="/2022/09/03/%E5%BE%AE%E6%9C%8D/pasted-1.png" alt="经典单体架构"></p><h2 id="LTMJ应用服务器示"><a href="#LTMJ应用服务器示" class="headerlink" title="LTMJ应用服务器示"></a>LTMJ应用服务器示</h2><p>如左图所示，LTMJ系统即是<br>服务器是linux系统，<br>开发应用程序语言是JAVA,<br>部署在Tomcat上，<br>采用MySQL数据库<br><img src="/2022/09/03/%E5%BE%AE%E6%9C%8D/pasted-2.png" alt="LTMJ应用服务器示意图"></p><h2 id="单体架构有什么问题"><a href="#单体架构有什么问题" class="headerlink" title="单体架构有什么问题"></a>单体架构有什么问题</h2><ul><li><p>1.复杂性逐渐变高</p><p>业务越来越复杂，单体应用的代码量越来越大，代码可读性、可维护性、可扩展性下降，新人接手代码所需的时间成倍增加，业务扩展带来的代价越来越大</p></li><li><p>2.单体应用并发能力有限</p></li></ul><p> 随着用户越来越多，程序承受的并发越来越高，单体应用的并发能力有限</p><ul><li>3.测试难度大</li></ul><p>单体应用的业务都在用一个程序中，随着业务的扩张、复杂度的增加，单体应用的修改或添加业务和或许会给其他业务带来一定的影响，导致测试难度增加</p><h2 id="单体应用集群架构"><a href="#单体应用集群架构" class="headerlink" title="单体应用集群架构"></a>单体应用集群架构</h2><p>1 系统仍然为单体应用</p><p>2 面对海量用户，数据库将会成为瓶颈，解决方案：分布式数据库，分库分表</p><p>3 持续交付能力差，业务越来越复杂，代码越多，修改的和添加代码所需时间长，新人熟悉代码时间长，成本高</p><p><img src="/2022/09/03/%E5%BE%AE%E6%9C%8D/pasted-3.png" alt="单体应用集群架构"></p><h1 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h1><ul><li>微服务最早由Martin Fowler与James Lewis于2014年共同提出，微服务架构风格是一种使用一套小服务来开发单个应用的方式途径，每个服务运行在自己的进程中，并使用轻量级机制通信，通常是HTTP API，这些服务基于业务能力构建，并能够通过自动化部署机制来独立部署，这些服务使用不同的编程语言实现，以及不同数据存储技术，并保持最低限度的集中式管理。</li><li>微服务的特性：<ul><li>按业务拆分为一个独立运行的程序，即服务单元</li><li>服务之间通过HTTP协议相互通讯</li><li>自动化部署</li><li>可以使用不同编程语言</li><li>可以使用不同存储技术</li><li>服务集中化管理</li><li>微服务是一个分布式系统</li></ul></li></ul><h2 id="微服务单元按业务拆分"><a href="#微服务单元按业务拆分" class="headerlink" title="微服务单元按业务拆分"></a>微服务单元按业务拆分</h2><ul><li><p>微服务的“微”是按照业务拆分，一个大的业务可以拆分成若干的小的业务，一个小的业务又可以拆分成若干更小的业务，业务怎么拆分是有开发人员自己决定</p></li><li><p>按业务划分的微服务单元独立部署，运行在独立的进程中。这些微服务是高度组件化的模块，并提供了稳定额模块边界，服务与服务之间没有任何的耦合，有非常好的扩展性和复用性。</p></li><li><p>现有我们开发模式通常由UI团队、服务端团队、数据库和运维团队构成，每个人各司其职，很少跨职能工作。</p></li><li><p>现在按照业务来划分服务，每个服务都需要UI、服务端、数据库和运维。也就是说一个小的业务的微服务需要动用一个团队的人协作，这显然添加了团队和团队之间交流协作的成本，所以产生了跨职能团队，这个团队复杂一个服务的所有工作，包括UI，服务端和数据库。若这个团队只有1-2个人，就对开发人员提出更高的要求</p></li></ul><h2 id="微服务通过HTTP来互相通信"><a href="#微服务通过HTTP来互相通信" class="headerlink" title="微服务通过HTTP来互相通信"></a>微服务通过HTTP来互相通信</h2><ul><li><p>按照业务拆分的微服务反应独立部署，并允许在各自的进程中。</p></li><li><p>微服务单元之间的通信方式一般倾向于使用HTTP这种简单的通信机制，更多时候是使用RESTfulAPI</p></li><li><p>服务与服务之间也可以通过轻量级的消息总线来通信，例如RabbitMQ、Kafaka.通过发送消息或订阅消息来达到服务与服务之间通信的目的</p></li><li><p>这两种方式有弊端：其通信机制是不可靠的，虽然成功率很高，但还是会有失败的时候</p></li></ul><p><img src="/2022/09/03/%E5%BE%AE%E6%9C%8D/pasted-4.png" alt="微服务通过HTTP来互相通信">    </p><h2 id="微服务的数据库独立"><a href="#微服务的数据库独立" class="headerlink" title="微服务的数据库独立"></a>微服务的数据库独立</h2><ul><li>例如 一个应用有这样的几个业务：用户的信息、用户的账户，用户购物车、素报表服务等，所有业务都共用一个数据库，随着业务量的添加，数据库的表数量越来越多，难以管理和维护，并且数据量的添加会导致查询速度越来越慢。</li></ul><p><img src="/2022/09/03/%E5%BE%AE%E6%9C%8D/pasted-5.png" alt="单体架构"></p><ul><li>每个微服务都有自己的数据库，他们之间数据库是没有联系。每个服务所使用的数据库存储技术å是根据业务需求决定<br><img src="/2022/09/03/%E5%BE%AE%E6%9C%8D/pasted-6.png" alt="微服务"></li></ul><h2 id="微服务的自动化部署"><a href="#微服务的自动化部署" class="headerlink" title="微服务的自动化部署"></a>微服务的自动化部署</h2><ul><li>自动化部署可以提供部署的效率，减少人为的控制，部署过程中出现的错误的概率降低，提供软件的质量</li><li>构建一个自动化部署的系统，虽然在前期需要开发人员或运维人员学习</li><li>随着客户实施DevOps，自动化部署必然会成为微服务部署一种方式<br>如果微服务按照单体架构的部署方式，则部署难度会呈指数增加。随着技术的发展，Docker容器技术、Kubernetes技术的推进，以及自动化部署工具（Jenkins）出现，自动化部署变得越来越简单</li></ul><p><img src="/2022/09/03/%E5%BE%AE%E6%9C%8D/pasted-7.png" alt="微服务的自动化部署"></p><h2 id="服务集中化管理"><a href="#服务集中化管理" class="headerlink" title="服务集中化管理"></a>服务集中化管理</h2><ul><li>微服务系统是按业务单元来划分，服务数量越多，管理起来就越复杂，因此微服务必须使用集中化管理。目前流行的微服务框架中，例如Spring cloud 采用Eureka来注册服务</li></ul><h2 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h2><ul><li>分布式系统是集群部署，由很多计算机相互协作共同构成，它能够处理海量用户的请求，当分布式系统对外提供服务时，用户是毫不知情的，还以为是一台服务器在提供服务。</li><li>微服务架构是分布式架构，是集群化部署，会给数据一致性带来困难，分布式系统中的服务通信依赖于网络，网络不好，必然会对分布式系统带来很大的影响，在分布式系统中服务之间相互依赖，如果一个服务出现了故障或网络延迟，在高并发的情况下，会导致线程阻塞，在很短时间内该服务的线程资源会消耗殆尽，最终服务不可用，由于服务的相互依赖，可能会导致整个系统不可用，这就是“雪崩效应”，为了防止此类事件的发生，分布式系统必然要采取相应的措施，例如熔断机制。</li></ul><h2 id="熔断机制"><a href="#熔断机制" class="headerlink" title="熔断机制"></a>熔断机制</h2><ul><li>为了防止雪崩效应事件的发生，分布式系统采用熔断机制。在用Spring cloud构建的微服务系统中，采用了熔断器（即Hystrix组建的Circuit breaker）去做熔断</li><li>例如在微服务系统中 有a、b、c、d等多个微服务，用户的请求通过网关后再到具体的服务，服务之间相互依赖，例如服务b依赖服务d，一个对外暴露的API需要服务b和服务d相互协作才能完成</li></ul><p><img src="/2022/09/03/%E5%BE%AE%E6%9C%8D/pasted-8.png" alt="微服务"><br>如果此时服务b出现故障或者网络延迟在高并发的情况下，服务b会出现大量的线程阻塞，有可能在很短时间内线程资源就会被耗尽，导致服务b的不可用。<br>如果此时没有熔断机制就会导致雪崩效应<br>为了解决此问题，引入熔断机制：</p><p><img src="/2022/09/03/%E5%BE%AE%E6%9C%8D/pasted-9.png" alt="b服务故障"></p><p><img src="/2022/09/03/%E5%BE%AE%E6%9C%8D/pasted-10.png" alt="b服务熔断"></p><ul><li>熔断机制<br>主要在三种状态中转换：</li><li>关闭状态 ：</li></ul><p> 当熔断器处于关闭状态时，请求是可以被放行的；<br> 当熔断器统计的失败次数触发开关时，转为打开状态。</p><ul><li>打开状态 ：</li></ul><p>当熔断器处于打开状态时，所有请求都是不被放行的，直接返回失败；<br>只有在经过一个设定的时间窗口周期后，熔断器才会转换到半开状态</p><ul><li>半开状态 ：</li></ul><p>当熔断器处于半开状态时，当前只能有一个请求被放行；<br>这个被放行的请求获得远端服务的响应后，假如是成功的，熔断器转换为关闭状态，否则转换到打开状态。</p><p><img src="/2022/09/03/%E5%BE%AE%E6%9C%8D/pasted-11.png" alt="熔断机制"></p><h1 id="微服务优势"><a href="#微服务优势" class="headerlink" title="微服务优势"></a>微服务优势</h1><ul><li><p>微服务是松藕合的，无论是在开发阶段或部署阶段都是独立的。</p></li><li><p>能够快速响应, 局部修改容易, 一个服务出现问题不会影响整个应用。</p></li><li><p>易于和第三方应用系统集成, 支持使用不同的语言开发, 允许你利用融合最新技术。</p></li><li><p>每个微服务都很小，足够内聚，足够小，代码容易理解。团队能够更关注自己的工作成果, 聚焦指定的业务功能或业务需求。</p></li><li><p>开发简单、开发效率提高，一个服务可能就是专一的只干一件事, 能够被小团队单独开发，这个小团队可以是 2 到 5 人的开发人员组成。</p></li></ul><h1 id="微服务的不足"><a href="#微服务的不足" class="headerlink" title="微服务的不足"></a>微服务的不足</h1><ul><li><p>微服务的复杂度</p><p> 开发人员需要付出一定的学习成本去掌握更多架构知识和框架知识；另外服务与服务之间是相互依赖，若修改一个服务就会对另外一个服务产生影响；</p></li><li><p>分布式事务</p><p>   在微服务架构应用中，需要更新不同服务所使用的不同的数据库</p></li><li><p>服务的划分</p><p>如何拆分服务</p></li><li><p>服务的部署</p><p> 需要对微服务有足够强的控制力，及自动化部署（例如使用阿里云提供paas服务）</p></li></ul><h1 id="微服务特点"><a href="#微服务特点" class="headerlink" title="微服务特点"></a>微服务特点</h1><p>根据微服务的特点，一个微服务应该有以下功能</p><ul><li>服务的注册和发现</li><li>服务的负载均衡 </li><li>服务的容错</li><li>服务的网关</li><li>服务配置的统一管理</li><li>链路跟踪</li><li>实时日志</li></ul><h2 id="服务的注册与消费"><a href="#服务的注册与消费" class="headerlink" title="服务的注册与消费"></a>服务的注册与消费</h2><ul><li><p>微服务系统是由很多个单一职责的服务单元组成，需要服务注册中心类统一管理这些微服务实例，方便查看每个微服务实例的健康状态。</p></li><li><p>服务注册是指向服务注册中心注册一个服务实例，服务提供者将自己的服务信息（服务名、IP地址）告知服务注册中心。</p></li><li><p>服务发现是指当服务消费者需要消费另外一个服务时，服务注册中心能够告知服务消费者它所要消费服务的实例信息（如服务名，IP地址等）</p></li><li><p>服务消费者一般使用HTTP协议来进行服务消费</p></li><li><p>服务注册中心会提供服务的健康检查方案，检查被注册的服务是否可用</p></li></ul><p><img src="/2022/09/03/%E5%BE%AE%E6%9C%8D/pasted-12.png" alt="服务的注册与消费"></p><h2 id="服务的负载均衡"><a href="#服务的负载均衡" class="headerlink" title="服务的负载均衡"></a>服务的负载均衡</h2><ul><li><p>在微服务架构中，服务之间的相互调用一般是通过HTTP通信协议来实现。但网络往往不可靠，为了保证服务的高可用，服务单元往往集群化部署。那服务消费者该调用哪个服务提供者的实例呢？</p></li><li><p>如图所示：所有服务都向服务注册中心注册（IP，服务名），服务消费者集成负载均衡组件，该组件会向服务消费者获取服务的注册列表信息，每隔一段时间重现刷新获取改列表。当服务消费者消费服务时，负载均衡组件获取服务提供者所有实例注册信息，并通过一定的负载均衡策略，选择一个服务提供者的实例，向该实例进行服务消费。</p></li><li><p>另外服务注册中心不但需要定时接收每个服务的心跳（用来检查服务是否可用），而且每个服务会定期获取服务注册列表的信息，当服务实例数量很多，服务注册中心承担了非常大的负载。由于服务注册中心很重要，所以必须实现高可用。</p></li></ul><p><img src="/2022/09/03/%E5%BE%AE%E6%9C%8D/pasted-13.png" alt="服务的负载均衡"></p><h2 id="服务的容错"><a href="#服务的容错" class="headerlink" title="服务的容错"></a>服务的容错</h2><p><a href="/2022/09/03/%E5%BE%AE%E6%9C%8D%E5%8A%A1/#%E7%86%94%E6%96%AD%E6%9C%BA%E5%88%B6">熔断机制</a></p><h2 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h2><ul><li><p>微服务系统接口资源通常由服务网关统一暴露，内部服务不直接对外提供API资源的暴露。</p></li><li><p>网关的作用</p><ul><li>统一暴露微服务系统对外服务的接口</li><li>用户身份认证、权限认证</li><li>实现监控功能，实时日志输出，对请求进行记录</li><li>流量监控，在高并发的情况，对服务进行降级</li></ul></li></ul><p><img src="/2022/09/03/%E5%BE%AE%E6%9C%8D/pasted-14.png" alt="服务网关"></p><h2 id="服务配置的统一管理"><a href="#服务配置的统一管理" class="headerlink" title="服务配置的统一管理"></a>服务配置的统一管理</h2><ul><li>在微服务架构中，需要有统一管理配置文件的组件，例如Spring cloud的config,阿里Nacos</li></ul><p>如图所示：<br>    * 1 ）首先Config server读取配置文件仓库的配置信息，仓库可以是本地仓库或git</p><pre><code>* 2） 配置服务启动时，读取配置文件信息，缓存在内存中* 3 ）由于a、b、c等服务指定了向配置服务读取配置信息，所以这些服务启动时就会向配置中心读取配置</code></pre><p><img src="/2022/09/03/%E5%BE%AE%E6%9C%8D/pasted-15.png" alt="服务配置的统一管理"></p><h2 id="服务链路跟踪"><a href="#服务链路跟踪" class="headerlink" title="服务链路跟踪"></a>服务链路跟踪</h2><ul><li><p>微服务系统有很多个服务，且服务与服务之间的调用有可能很复杂，一旦出现异常和错误很难定位。</p></li><li><p>所以微服务架构中必须实现分布式链路跟踪，去跟进一个请求到底有哪些服务参与，参与的顺序又是怎么样的。从而使每个请求链路清晰可见</p></li><li><p>如果所示 一个接口首先调服务A，后再调用B，而B需要调用C，对于这样一个请求需要三个服务，怎么样将它的请求过程的数据记录下，这就需要服务链路跟踪</p></li><li><p>目前链路跟踪组件：Google的Dapper、Twitter的Zipkin</p></li></ul><p><img src="/2022/09/03/%E5%BE%AE%E6%9C%8D/pasted-16.png" alt="服务链路跟踪"></p><h1 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h1><p><img src="/2022/09/03/%E5%BE%AE%E6%9C%8D/pasted-17.png" alt="Spring Cloud"></p><h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><ul><li>SpringCloud是基于Spring boot的。而Spring boot是简化了Spring的复杂的配置和依赖管理，从而提高在开发和部署上的效率。</li><li>目标：通过一系列的开发组件和框架，帮助开发者迅速搭建一个分布式的微服务系统。<br>常用组件：</li></ul><p><img src="/2022/09/03/%E5%BE%AE%E6%9C%8D/pasted-18.png" alt="组件1"></p><p><img src="/2022/09/03/%E5%BE%AE%E6%9C%8D/pasted-19.png" alt="组件2"></p><p><img src="/2022/09/03/%E5%BE%AE%E6%9C%8D/pasted-20.png" alt="简单微服务"></p><h1 id="构建微服务"><a href="#构建微服务" class="headerlink" title="构建微服务"></a>构建微服务</h1><ul><li>开发环境：Jdk1.8,MAVEN3.2.3,Eclipse</li><li>spring cloud版本：Greenwich.SR2</li><li>Spring boot：2.1.6.RELEASE</li></ul><p><img src="/2022/09/03/%E5%BE%AE%E6%9C%8D/pasted-21.png" alt="微服务"></p><ul><li>部署环境：<ul><li>k8s matser: 2核cpu 系统 cenots 7.9 硬盘20g 内存2048m ip:192.168.31.59 docker版本:18.09.7,k8s:1.15.1</li></ul></li><li>k8s node :2核cpu 系统 cenots 7.9 硬盘20g 内存3072 m ip:192.168.31.181 docker版本:18.09.7,k8s:1.15.1</li><li>docker：CPU1个，内存521M硬盘20G, 含有JAVA和MAVEN环境 镜像仓库使用阿里云</li><li>部署说明<br>下载[soft.zip]链接: <a href="https://pan.baidu.com/s/1jp2UuZUX-DtpVz51ucsAFA">https://pan.baidu.com/s/1jp2UuZUX-DtpVz51ucsAFA</a> 提取码: 3ahf<br>百度网盘不能下载请及时联系</li></ul><p><img src="/2022/09/03/%E5%BE%AE%E6%9C%8D/pasted-24.png" alt="soft.zip"><br><a href="/download/springcloud.zip">springcloud.zip</a></p><p><img src="/2022/09/03/%E5%BE%AE%E6%9C%8D/pasted-25.png" alt="springcloud.zip"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">------------------------------使用阿里云镜像仓库----</span><br><span class="line"><span class="comment">#上传soft文件至docker,k8smaster k8snode</span></span><br><span class="line"><span class="comment">#将镜像推送至ali,ali免费版可以存300个</span></span><br><span class="line">https:<span class="regexp">//</span>help.aliyun.com<span class="regexp">/document_detail/</span><span class="number">60945</span>.html?spm=a2c4g.<span class="number">11186623.6</span>.<span class="number">542.48983</span>d31EbMHWT</span><br><span class="line"><span class="comment">#1)仅是安装docker 环境（下载soft文件 解压后上传docker机器上root 目录 ，soft目录下installDocker.sh）</span></span><br><span class="line"><span class="comment">#docker version:18.09.7 k8s version:1.15.1</span></span><br><span class="line">tr -d <span class="string">&#x27;\r&#x27;</span> &lt;<span class="regexp">/root/</span>soft<span class="regexp">/installDocker.sh &gt; /</span>root<span class="regexp">/soft/i</span>nstallDocker_new.sh  &amp;&amp; chmod +x <span class="regexp">/root/</span>soft<span class="regexp">/*.sh &amp;&amp; /</span>root<span class="regexp">/soft/i</span>nstallDocker_new.sh  init installDocker</span><br><span class="line"><span class="comment">#登录阿里云：</span></span><br><span class="line"><span class="comment"># docker login --username=test@1594726148325608 registry.cn-shenzhen.aliyuncs.com</span></span><br><span class="line"><span class="comment">#密码：t12345678</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">#RAM用户控制台：</span></span><br><span class="line"> <span class="comment">#test@1594726148325608.onaliyun.com</span></span><br><span class="line"> <span class="comment">#密码：4DzBf)xUvq8hzY6B6QMlFR&#123;K?Oq(rsNv</span></span><br><span class="line"> <span class="comment">#https://cr.console.aliyun.com/cn-shenzhen/instance/repositories</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">#2)导入镜像：</span></span><br><span class="line">tr -d <span class="string">&#x27;\r&#x27;</span> &lt;<span class="regexp">/root/</span>soft<span class="regexp">/installDocker.sh &gt; /</span>root<span class="regexp">/soft/i</span>nstallDocker_new.sh  &amp;&amp; chmod +x <span class="regexp">/root/</span>soft<span class="regexp">/*.sh &amp;&amp; /</span>root<span class="regexp">/soft/i</span>nstallDocker_new.sh  loadJavaDockerImage</span><br><span class="line"></span><br><span class="line"> <span class="comment">#3)配置java环境：</span></span><br><span class="line"> <span class="comment">##配置java环境和MAVEN(maven库：/mavenFactory/repository)</span></span><br><span class="line">tr -d <span class="string">&#x27;\r&#x27;</span> &lt;<span class="regexp">/root/</span>soft<span class="regexp">/installDocker.sh &gt; /</span>root<span class="regexp">/soft/i</span>nstallDocker_new.sh  &amp;&amp; chmod +x <span class="regexp">/root/</span>soft<span class="regexp">/*.sh &amp;&amp; /</span>root<span class="regexp">/soft/i</span>nstallDocker_new.sh    configJava</span><br><span class="line"></span><br><span class="line"> <span class="comment">#4)build docker 新打开一个窗口执行 上传sprincloud代码至/root</span></span><br><span class="line"></span><br><span class="line">cd <span class="regexp">/root/</span>springcloud/deployment</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5)alidev（build全部）如果mvn和java配置失败 请重新执行source /etc/profile</span></span><br><span class="line">tr -d <span class="string">&#x27;\r&#x27;</span> &lt;buildDocker.sh &gt; buildDocker_bew.sh &amp;&amp; chmod +x *.sh &amp;&amp; ./buildDocker_bew.sh  -Dver=<span class="number">1.0</span>.<span class="number">0</span> -Denv=aliyun_dev</span><br><span class="line"><span class="comment">#单个</span></span><br><span class="line">tr -d <span class="string">&#x27;\r&#x27;</span> &lt;buildDocker.sh &gt; buildDocker_bew.sh &amp;&amp; chmod +x *.sh &amp;&amp; ./buildDocker_bew.sh  -Dver=<span class="number">1.0</span>.<span class="number">0</span> -Denv=aliyun_dev EurekaServer</span><br><span class="line">tr -d <span class="string">&#x27;\r&#x27;</span> &lt;buildDocker.sh &gt; buildDocker_bew.sh &amp;&amp; chmod +x *.sh &amp;&amp; ./buildDocker_bew.sh  -Dver=<span class="number">1.0</span>.<span class="number">0</span> -Denv=aliyun_dev configServer</span><br><span class="line">tr -d <span class="string">&#x27;\r&#x27;</span> &lt;buildDocker.sh &gt; buildDocker_bew.sh &amp;&amp; chmod +x *.sh &amp;&amp; ./buildDocker_bew.sh  -Dver=<span class="number">1.0</span>.<span class="number">0</span> -Denv=aliyun_dev ServiceClient</span><br><span class="line">tr -d <span class="string">&#x27;\r&#x27;</span> &lt;buildDocker.sh &gt; buildDocker_bew.sh &amp;&amp; chmod +x *.sh &amp;&amp; ./buildDocker_bew.sh  -Dver=<span class="number">1.0</span>.<span class="number">0</span> -Denv=aliyun_dev ServiceClientB</span><br><span class="line">tr -d <span class="string">&#x27;\r&#x27;</span> &lt;buildDocker.sh &gt; buildDocker_bew.sh &amp;&amp; chmod +x *.sh &amp;&amp; ./buildDocker_bew.sh  -Dver=<span class="number">1.0</span>.<span class="number">0</span> -Denv=aliyun_dev gateway</span><br><span class="line"></span><br><span class="line"><span class="comment">##--------------安装k8s master和k8s node ------------</span></span><br><span class="line"><span class="comment">#6)安装K8sMaster（soft目录下installk8sMaster.sh） 需要修改aliyun镜像仓库地址，用户户名和密码，k8smaster ip,k8s node ip</span></span><br><span class="line">tr -d <span class="string">&#x27;\r&#x27;</span> &lt;<span class="regexp">/root/</span>soft<span class="regexp">/installk8sMaster.sh &gt; /</span>root<span class="regexp">/soft/i</span>nstallk8sMaster.sh_new.sh  &amp;&amp; chmod +x <span class="regexp">/root/</span>soft<span class="regexp">/*.sh &amp;&amp; /</span>root<span class="regexp">/soft/i</span>nstallk8sMaster.sh_new.sh </span><br><span class="line"><span class="comment">#7)重新配置master</span></span><br><span class="line">tr -d <span class="string">&#x27;\r&#x27;</span> &lt;<span class="regexp">/root/</span>soft<span class="regexp">/installk8sMaster.sh &gt; /</span>root<span class="regexp">/soft/i</span>nstallk8sMaster.sh_new.sh  &amp;&amp; chmod +x <span class="regexp">/root/</span>soft<span class="regexp">/*.sh &amp;&amp; /</span>root<span class="regexp">/soft/i</span>nstallk8sMaster.sh_new.sh configMaster</span><br><span class="line"><span class="comment"># 8)检查 master 初始化结果</span></span><br><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9)获得 join命令参数 </span></span><br><span class="line">kubeadm token create --print-join-command</span><br><span class="line"></span><br><span class="line"><span class="comment">#10)安装Node:( (确保master 状态为ready 正常再操作node))（soft目录下installk8sNode.sh）</span></span><br><span class="line"><span class="comment">#需要修改aliyun镜像仓库地址，用户户名和密码，k8smaster ip,k8s node ip</span></span><br><span class="line">tr -d <span class="string">&#x27;\r&#x27;</span> &lt;<span class="regexp">/root/</span>soft<span class="regexp">/installk8sNode.sh &gt; /</span>root<span class="regexp">/soft/i</span>nstallk8sNode.sh_new.sh  &amp;&amp; chmod +x <span class="regexp">/root/</span>soft<span class="regexp">/*.sh &amp;&amp; /</span>root<span class="regexp">/soft/i</span>nstallk8sNode.sh_new.sh</span><br><span class="line"><span class="comment"># 11)只在 worker 节点执行 设置masterip 和apiserver.demo</span></span><br><span class="line">echo <span class="string">&quot;192.168.31.200 apiserver.demo&quot;</span> &gt;&gt; <span class="regexp">/etc/</span>hosts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 12)执行第9步： kubeadm token create --print-join-command 命令的输出 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 13)只在 master 节点执行 直至nodes ready状态 等待 3-10 分钟</span></span><br><span class="line">kubectl get nodes -o wide</span><br><span class="line"></span><br><span class="line"><span class="comment">#若一直没有ready失败则kubectl get pod -n kube-system pod是否是ready状态和running状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##14)在master安装Kubectl,helm</span></span><br><span class="line">tr -d <span class="string">&#x27;\r&#x27;</span> &lt;<span class="regexp">/root/</span>soft<span class="regexp">/installk8sMaster.sh &gt; /</span>root<span class="regexp">/soft/i</span>nstallk8sMaster.sh_new.sh  &amp;&amp; chmod +x <span class="regexp">/root/</span>soft<span class="regexp">/*.sh &amp;&amp; /</span>root<span class="regexp">/soft/i</span>nstallk8sMaster.sh_new.sh configKubectl</span><br><span class="line"></span><br><span class="line"><span class="comment">#15)安装ingress </span></span><br><span class="line">tr -d <span class="string">&#x27;\r&#x27;</span> &lt;<span class="regexp">/root/</span>soft<span class="regexp">/installk8sMaster.sh &gt; /</span>root<span class="regexp">/soft/i</span>nstallk8sMaster.sh_new.sh  &amp;&amp; chmod +x <span class="regexp">/root/</span>soft<span class="regexp">/*.sh &amp;&amp; /</span>root<span class="regexp">/soft/i</span>nstallk8sMaster.sh_new.sh installIngress</span><br><span class="line"></span><br><span class="line"><span class="comment"># 16)记下kubord token</span></span><br><span class="line">eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJvYXJkIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6Imt1Ym9hcmQtdXNlci10b2tlbi01OTk4ZiIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50Lm5hbWUiOiJrdWJvYXJkLXVzZXIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiJjMjMzM2Y2Mi00OTdlLTQwNGUtYmRmOS1kMWMwNjg4OWQwZWEiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3Vib2FyZDprdWJvYXJkLXVzZXIifQ.fGttYtIb3w6YrqYIrZodd7J0PXz5cCT8P7w7L_0V0ddCJY8gaEm-n5dTQurfigJuTcSUAzjJgHXAyp4sb-XZ8ma5jnnipZfW3543oiFo-gcbKwvVGPQYUqJ-UrCQlw_yW43iJ6Y7DzFPrVwfQ1ByfoUCDnEvDTLxG6yC3qNlzlVAsBMtreeUXqNl-xMIUAa-GQZL7gaddRiBQhmY96a67NFhqgiU8Lz_lv8NiQxAZT5ECDsoCl9-qzx7pm04I5W3tS2wPrew06Fqlpf0sxLWY__bd_SnTbFKlCGRA9_-h4uDZW9x3vn6FxfS-RT_o9Yd8GZYKr8I2P5cPZ8Xqx094w</span><br><span class="line"><span class="comment">#查看pod :kubectl get pod --all-namespaces </span></span><br><span class="line"><span class="comment"># host文件设置  192.168.31.200 kuboard.yanwen.com  （换成虚拟机主机ip）</span></span><br><span class="line"><span class="comment">#直至所有pod启动成功浏览器访问kuboard.yanwen.com 输入 &quot;脚本最打印后token&quot;</span></span><br><span class="line"><span class="comment">##--------------安装k8s master和k8s node ------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##----------------------------部署代码------------------------------ </span></span><br><span class="line"><span class="comment">#17）确保kubectl master node确保是否是readey</span></span><br><span class="line">kubectl get nodes -o wide</span><br><span class="line"><span class="comment">#代码master上传至： /root/springcloud/deployment</span></span><br><span class="line"><span class="comment">#18）执行部署</span></span><br><span class="line">tr -d <span class="string">&#x27;\r&#x27;</span> &lt;<span class="regexp">/root/</span>soft<span class="regexp">/installk8sMaster.sh &gt; /</span>root<span class="regexp">/soft/i</span>nstallk8sMaster.sh_new.sh  &amp;&amp; chmod +x <span class="regexp">/root/</span>soft<span class="regexp">/*.sh &amp;&amp; /</span>root<span class="regexp">/soft/i</span>nstallk8sMaster.sh_new.sh createSecret</span><br><span class="line"></span><br><span class="line">tr -d <span class="string">&#x27;\r&#x27;</span> &lt;<span class="regexp">/root/</span>soft<span class="regexp">/installk8sMaster.sh &gt; /</span>root<span class="regexp">/soft/i</span>nstallk8sMaster.sh_new.sh  &amp;&amp; chmod +x <span class="regexp">/root/</span>soft<span class="regexp">/*.sh &amp;&amp; /</span>root<span class="regexp">/soft/i</span>nstallk8sMaster.sh_new.sh deploy</span><br><span class="line"></span><br><span class="line"><span class="comment">#host设置：192.168.31.200  demodev.yanwen.com.cn eureka.intranet.local kuboard.yanwen.com demodev.intranet.local kuboard.yanwen.com （换成k8s master 节点 ip）</span></span><br><span class="line"></span><br><span class="line">demodev.yanwen.com.cn--ingress 配置 svc-nginx:<span class="number">80</span>, nginx访问http:<span class="regexp">//</span>svc-ing-gateway-gateway:<span class="number">6083</span></span><br><span class="line">demodev.intranet.local --ingress 配置http:<span class="regexp">//</span>svc-ing-gateway-gateway:<span class="number">6083</span></span><br><span class="line"></span><br><span class="line">eureka.intranet.local ingress 配置svc-ing-eureka-springclouddemoeureka:<span class="number">6080</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#19）测试连接：前往kuboard.yanwen.com 进行查看应用启动日志</span></span><br><span class="line"></span><br><span class="line">eureka: eureka.intranet.local </span><br><span class="line">gateway:</span><br><span class="line">http:<span class="regexp">//</span>demodev.yanwen.com.cn<span class="regexp">/searviceA/u</span>sers/<span class="number">111</span></span><br><span class="line">http:<span class="regexp">//</span>demodev.yanwen.com.cn<span class="regexp">/searviceB/u</span>sers/<span class="number">11</span></span><br><span class="line">内网</span><br><span class="line">http:<span class="regexp">//</span>demodev.intranet.local<span class="regexp">/searviceA/u</span>sers/<span class="number">111</span></span><br><span class="line">http:<span class="regexp">//</span>demodev.intranet.local<span class="regexp">/searviceB/u</span>sers/<span class="number">11</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">扩容searviceA 待启动后 </span><br><span class="line">kubectl get deployment --all-namespaces</span><br><span class="line">kubectl scale --replicas=<span class="number">2</span> deployments/rs-serviceclient -n springclouddemo</span><br><span class="line"></span><br><span class="line">kubectl scale --replicas=<span class="number">1</span> deployments/rs-serviceclient -n springclouddemo</span><br><span class="line"></span><br><span class="line">在访问 测试ribbon负载均衡组件</span><br><span class="line">http:<span class="regexp">//</span>demodev.yanwen.com.cn<span class="regexp">/searviceB/u</span>sers/<span class="number">11</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">helm <span class="keyword">delete</span> --pruge configserver </span><br><span class="line">helm <span class="keyword">delete</span> --pruge gateway </span><br><span class="line">helm <span class="keyword">delete</span> --pruge nginx </span><br><span class="line">helm <span class="keyword">delete</span> --pruge serviceclient </span><br><span class="line">helm <span class="keyword">delete</span> --pruge serviceclientb </span><br><span class="line">helm <span class="keyword">delete</span> --pruge springclouddemoeureka</span><br><span class="line">helm <span class="keyword">delete</span> --pruge svcingress </span><br><span class="line"></span><br><span class="line"><span class="comment"># 单独部署：</span></span><br><span class="line">  dir=<span class="regexp">/root/</span>springcloud/deployment</span><br><span class="line">cd <span class="variable">$dir</span></span><br><span class="line"></span><br><span class="line">tr -d <span class="string">&#x27;\r&#x27;</span> &lt;deploy.sh &gt; deploy_bew.sh  &amp;&amp; chmod +x <span class="variable">$dir</span><span class="regexp">/*.sh   &amp;&amp; ./</span>deploy_bew.sh  -Dver=<span class="number">1.0</span>.<span class="number">0</span> -Denv=ali_dev -Dnamespace=springclouddemo -Dname=springclouddemoeureka  eureka</span><br><span class="line">tr -d <span class="string">&#x27;\r&#x27;</span> &lt;deploy.sh &gt; deploy_bew.sh  &amp;&amp; chmod +x <span class="variable">$dir</span><span class="regexp">/*.sh  &amp;&amp; ./</span>deploy_bew.sh  -Dver=<span class="number">1.0</span>.<span class="number">0</span> -Denv=ali_dev -Dnamespace=springclouddemo  -Dname=configserver configServer </span><br><span class="line">tr -d <span class="string">&#x27;\r&#x27;</span> &lt;deploy.sh &gt; deploy_bew.sh  &amp;&amp; chmod +x <span class="variable">$dir</span><span class="regexp">/*.sh  &amp;&amp; ./</span>deploy_bew.sh  -Dver=<span class="number">1.0</span>.<span class="number">0</span> -Denv=ali_dev -Dnamespace=springclouddemo  -Dname=serviceclient ServiceClient</span><br><span class="line">tr -d <span class="string">&#x27;\r&#x27;</span> &lt;deploy.sh &gt; deploy_bew.sh   &amp;&amp; chmod +x <span class="variable">$dir</span><span class="regexp">/*.sh &amp;&amp; ./</span>deploy_bew.sh  -Dver=<span class="number">1.0</span>.<span class="number">0</span> -Denv=ali_dev -Dnamespace=springclouddemo  -Dname=serviceclientb ServiceClientB</span><br><span class="line">tr -d <span class="string">&#x27;\r&#x27;</span> &lt;deploy.sh &gt; deploy_bew.sh  &amp;&amp; chmod +x <span class="variable">$dir</span><span class="regexp">/*.sh  &amp;&amp; ./</span>deploy_bew.sh  -Dver=<span class="number">1.0</span>.<span class="number">0</span> -Denv=ali_dev -Dnamespace=springclouddemo  -Dname=svcingress ingress</span><br><span class="line"></span><br><span class="line">tr -d <span class="string">&#x27;\r&#x27;</span> &lt;deploy.sh &gt; deploy_bew.sh   &amp;&amp; chmod +x <span class="variable">$dir</span><span class="regexp">/*.sh &amp;&amp; ./</span>deploy_bew.sh  -Dver=<span class="number">1.0</span>.<span class="number">0</span> -Denv=ali_dev -Dnamespace=springclouddemo  -Dname=gateway gateway</span><br><span class="line">    tr -d <span class="string">&#x27;\r&#x27;</span> &lt;deploy.sh &gt; deploy_bew.sh  &amp;&amp; chmod +x <span class="variable">$dir</span><span class="regexp">/*.sh  &amp;&amp; ./</span>deploy_bew.sh  -Dver=<span class="number">1.16</span>.<span class="number">1</span> -Denv=ali_dev -Dnamespace=springclouddemo  -Dname=nginx nginx</span><br><span class="line">------------------------------使用阿里云镜像仓库----</span><br></pre></td></tr></table></figure><ul><li>eureka.intranet.local</li></ul><p><img src="/2022/09/03/%E5%BE%AE%E6%9C%8D/pasted-22.png" alt="eureka.intranet.local "></p><ul><li><a href="http://demodev.yanwen.com.cn/searviceA/users/111">http://demodev.yanwen.com.cn/searviceA/users/111</a></li></ul><p><img src="/2022/09/03/%E5%BE%AE%E6%9C%8D/pasted-23.png" alt="demodev.yanwen.com.cn"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> 微服务 </tag>
            
            <tag> spring cloud </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes知识</title>
      <link href="/2022/08/22/K8S%E7%9F%A5%E8%AF%86/"/>
      <url>/2022/08/22/K8S%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Kubernetes"><a href="#什么是Kubernetes" class="headerlink" title="什么是Kubernetes"></a>什么是Kubernetes</h1><ul><li><p>Kubernetes是Google 2014年创建管理的，是Google 10多年大规模容器管理技术Borg的开源版本。</p></li><li><p>Kubernetes（K8S）是Google开源的容器集群管理系统，其设计源于Google在容器编排方面积累的丰富经验，并结合社区创新的最佳实践。</p></li><li><p>K8S在Docker容器技术的基础之上，大大地提高了容器化部署应用简单高效。并且具备了完整的集群管理能力，例如服务发现、资源配额、缩容扩容、动态更新、持久化存储、监控、日志等，涵盖项目周期的各个环节。</p></li><li><p>经过这几年的快速发展，K8S已经成为建设容器云平台的首选方案</p></li><li><p>Kubernetes的名字来自希腊语，意思是“舵手” 或 “领航员”。K8s是将8个字母“ubernete”替换为“8”的缩写。</p></li></ul><h2 id="Kubernetes与docker联系"><a href="#Kubernetes与docker联系" class="headerlink" title="Kubernetes与docker联系"></a>Kubernetes与docker联系</h2><ul><li>Docker是一个容器引擎，用于运行容器，Kubernetes是一个容器编排系统，不具备容器引擎功能，相比Docker是一个更高级封装，而他们在一起堪称珠联璧合，一起搞大事！如图：</li></ul><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-0.png" alt="Kubernetes与docker联系"></p><h1 id="Kubernetes-介绍"><a href="#Kubernetes-介绍" class="headerlink" title="Kubernetes 介绍"></a>Kubernetes 介绍</h1><ul><li><p>存储编排<br>Kubernetes 允许您自动挂载您选择的存储系统，例如本地存储、公共云提供商、NFS等。</p></li><li><p>应用程序健康检查<br>容器内服务可能进场阻塞无法处理请求，可以设置监控检查策略保证 应用健壮性</p></li><li><p>复制应用程序实例<br>控制器维护着pod的副本数量，保证一个Pod或一组同类的Pod数量始终可用</p></li><li><p>弹性伸缩<br>根据设定的指标（CPU利用率）自动缩放Pod副本数量</p></li><li><p>服务发现<br>使用环境变量或DNS服务插件保证容器中程序发现Pod入口访问地址</p></li><li><p>负载均衡<br>一组Pod副本分配一个私有的集群IP地址，负载均衡转发请求到后端容器。在集群里内部其他Pod可通过这个ClusterIp访问应用</p></li><li><p>滚动更新<br>更新服务不中断，一次更新一个pod</p></li><li><p>服务编排<br>通过文件描述部署服务，使得应用程序部署变得更高效</p></li><li><p>资源监控<br>Node节点组件集成cAdvisor资源收集工具，可通过Heapster汇总整个集群节点资源数据，然后存储到InFluxDB时序数据库，再由Grafana展示</p></li><li><p>提供认证和授权<br>支持角色访问权限（RBAC）</p></li><li><p>日志访问<br>可以查询容器运行日志</p></li></ul><h2 id="Kubernetes不是什么？"><a href="#Kubernetes不是什么？" class="headerlink" title="Kubernetes不是什么？"></a>Kubernetes不是什么？</h2><ul><li><p>Kubernetes并不是传统的PaaS（平台即服务）系统。</p></li><li><p>Kubernetes不限制支持应用的类型，不限制应用框架。不限制受支持的语言runtimes (例如, Java, Python, Ruby)，满足12-factor applications 。不区分 “apps” 或者“services”。 Kubernetes支持不同负载应用，包括有状态、无状态、数据处理类型的应用。只要这个应用可以在容器里运行，那么就能很好的运行在Kubernetes上。</p></li><li><p>Kubernetes不提供中间件（如message buses）、数据处理框架（如Spark）、数据库(如Mysql)或者集群存储系统(如Ceph)作为内置服务。但这些应用都可以运行在Kubernetes上面。</p></li><li><p>Kubernetes不部署源码不编译应用。持续集成的 (CI)工作流方面，不同的用户有不同的需求和偏好的区域，因此，我们提供分层的 CI工作流，但并不定义它应该如何工作。</p></li><li><p>Kubernetes允许用户选择自己的日志、监控和报警系统。</p></li><li><p>Kubernetes不提供或授权一个全面的应用程序配置 语言&#x2F;系统（例如，jsonnet）。</p></li><li><p>Kubernetes不提供任何机器配置、维护、管理或者自修复系统。</p></li></ul><h1 id="Kubernetes组件"><a href="#Kubernetes组件" class="headerlink" title="Kubernetes组件"></a>Kubernetes组件</h1><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-1.png" alt="Kubernetes组件"></p><h2 id="Kubernetes组件–Master-组件"><a href="#Kubernetes组件–Master-组件" class="headerlink" title="Kubernetes组件–Master 组件"></a>Kubernetes组件–Master 组件</h2><ul><li>Master 组件提供集群的控制平面<br>Master 组件对集群进行全局决策（例如，调度），并检测和响应集群事件（例如，当不满足部署的 replicas 字段时，启动新的 pod）。</li><li>kube-apiserver<br>主节点上负责提供 Kubernetes API 服务的组件；它是 Kubernetes 控制面的前端。</li><li>etcd<br>etcd 是兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。</li><li>kube-scheduler<br>主节点上的组件，该组件监视那些新创建的未指定运行节点的 Pod，并选择节点让 Pod 在上面运行。<br>调度决策考虑的因素包括单个 Pod 和 Pod 集合的资源需求、硬件&#x2F;软件&#x2F;策略约束、亲和性和反亲和性规范、数据位置、工作负载间的干扰和最后时限。</li><li>kube-controller-manager<br>在主节点上运行控制器的组件。<br>从逻辑上讲，每个控制器都是一个单独的进程，但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。<br>这些控制器包括:<ul><li>节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应。</li><li>副本控制器（Replication Controller）: 负责为系统中的每个副本控制器对象维护正确数量的 Pod。</li><li>端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入 Service 与 Pod)。</li><li>服务帐户和令牌控制器（Service Account &amp; Token Controllers）: 为新的命名空间创建默认帐户和 API 访问令牌</li></ul></li></ul><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-2.png" alt="kube-controller-manager"></p><ul><li>容器运行环境(Container Runtime)<br>容器运行环境是负责运行容器的软件。–docker</li></ul><h2 id="Kubernetes组件–Node-组件"><a href="#Kubernetes组件–Node-组件" class="headerlink" title="Kubernetes组件–Node 组件"></a>Kubernetes组件–Node 组件</h2><ul><li><p>kubelet<br>一个在集群中每个节点上运行的代理。它保证容器都运行在 Pod 中。<br>kubelet 接收一组通过各类机制提供给它的 PodSpecs，确保这些 PodSpecs 中描述的容器处于运行状态且健康。kubelet 不会管理不是由 Kubernetes 创建的容器。</p></li><li><p>kube-proxy<br>kube-proxy 是集群中每个节点上运行的网络代理,实现 Kubernetes Service 概念的一部分。<br>kube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod 进行网络通信。<br>如果有 kube-proxy 可用，它将使用操作系统数据包过滤层。否则，kube-proxy 会转发流量本身。</p></li><li><p>容器运行环境(Container Runtime)<br>容器运行环境是负责运行容器的软件。–docker</p></li></ul><h1 id="Kubernetes-核心对象概念"><a href="#Kubernetes-核心对象概念" class="headerlink" title="Kubernetes 核心对象概念"></a>Kubernetes 核心对象概念</h1><ul><li><p>pod<br>Pod是最小部署 单元，一个Pod有一个或多个容器组成，Pod中容器共享存储和网站，在同一个DOcker主机上运行</p></li><li><p>Service<br>Service一个应用服务抽象，定义了Pod逻辑集合和访问这个Pod集成的策略<br>Service代理Pod集合对外表现是为一个访问入口，分配一个集群Ip地址，来自这个Ip的请求将负载均衡转发后端Pod中容器<br>Servie 通过Label Selector 选择一组Pod提供服务</p></li><li><p>Volume<br> 数据卷，供于Pod使用的数据</p></li><li><p>Namespace<br> 命名空间将对象逻辑上分配到不同Namespace,可以不同项目、用户等区分管理，从而实现多租户。命名空间也成为虚拟集群</p></li><li><p>Label<br> 标签用于区分对象（比如Pod service）,键&#x2F;值对存在，每个对象可以有多个标签，通过标签关联对象</p></li><li><p>ReplicaSet<br>下一代Replication Controller，确保任何给定时间指定Pod副本数量，并提供声明式更新等功能<br>RC与RS唯一区别就是Label Selector支持不同，RS支持新的基于集合的标签，RC仅支持基于等式标签</p></li><li><p>Deployment<br>是更高层次的PAI对象，它管理Replica和Pod，并提供声明式更新等功能<br>官方建议使用Deployment管理ReplicaSet ,而不是直接使用RelicaSet，这就意味着可能永远不需要直接操作ReplicaSet对象</p></li><li><p>Job<br>一次性任务，运行完成后Pod销毁。不再重新启动部署新容器，还可以任务定时运行</p></li><li><p>StatefulSet<br>适合持久性的应用程序，有唯一的网络标识符（IP）,持久存储，有序的部署、扩展、删除和滚动更新</p></li><li><p>DaementSet<br>DaementSet确保所有（或一些）节点运行同一个Pod,当节点加入kubernets集群中，Pod会调到该节点上运行。当节点集群中移除，DaementSet的Pod会被删除，删除DaemonSet会清理它所有创建的Pod</p></li></ul><h1 id="Kubernetes-安装"><a href="#Kubernetes-安装" class="headerlink" title="Kubernetes 安装"></a>Kubernetes 安装</h1><ul><li>minikube<br>Minikube是一个工具，可以在本地快速运行一个单点的Kubernetes，尝试Kubernetes或日常开发的用户使用。不能用于生产环境。<br>官方地址：<a href="https://kubernetes.io/docs/setup/minikube/">https://kubernetes.io/docs/setup/minikube/</a></li><li>kubeadm<br>Kubeadm也是一个工具，提供kubeadm init和kubeadm join，用于快速部署Kubernetes集群。<br>官方地址：<a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/">https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/</a></li><li>二进制包<br>从官方下载发行版的二进制包，手动部署每个组件，组成Kubernetes集群。</li></ul><h2 id="虚拟机安装centos"><a href="#虚拟机安装centos" class="headerlink" title="虚拟机安装centos"></a>虚拟机安装centos</h2><ul><li>k8s matser: 2核cpu 系统 cenots 7.9 硬盘20g 内存2048m  ip:192.168.31.59 docker版本:18.09.7</li><li>k8s node :2核cpu 系统 cenots 7.9 硬盘20g 内存2048m  ip:192.168.31.181 docker版本:18.09.7</li></ul><h2 id="k8s-master-安装k8s-2-15版本"><a href="#k8s-master-安装k8s-2-15版本" class="headerlink" title="k8s master 安装k8s 2.15版本"></a>k8s master 安装k8s 2.15版本</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Kubernetes 安装部署</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Kubernetes --master</span></span><br><span class="line"><span class="comment"># ipaddr 确认主机ip</span></span><br><span class="line"><span class="comment"># 在 master 节点和 worker 节点都要执行</span></span><br><span class="line">cat <span class="regexp">/etc/</span>redhat-release</span><br><span class="line"><span class="comment"># 此处 hostname 的输出将会是该机器在 Kubernetes 集群中的节点名字</span></span><br><span class="line"><span class="comment"># 不能使用 localhost 作为节点的名字</span></span><br><span class="line">hostname</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请使用 lscpu 命令，核对 CPU 信息</span></span><br><span class="line"><span class="comment"># Architecture: x86_64    本安装文档不支持 arm 架构</span></span><br><span class="line"><span class="comment"># CPU(s):       2         CPU 内核数量不能低于 2</span></span><br><span class="line">lscpu</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 以下脚本在master执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 hostname</span></span><br><span class="line">hostnamectl set-hostname k8s-master</span><br><span class="line"><span class="comment"># 查看修改结果</span></span><br><span class="line">hostnamectl status</span><br><span class="line"><span class="comment"># 设置 hostname 解析</span></span><br><span class="line">echo <span class="string">&quot;127.0.0.1   $(hostname)&quot;</span> &gt;&gt; <span class="regexp">/etc/</span>hosts</span><br><span class="line">cat <span class="regexp">/etc/</span>hosts</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##安装docker:</span></span><br><span class="line"><span class="comment">##卸载旧版本</span></span><br><span class="line"> yum remove -y docker \</span><br><span class="line">docker-client \</span><br><span class="line">docker-client-latest \</span><br><span class="line">docker-common \</span><br><span class="line">docker-latest \</span><br><span class="line">docker-latest-logrotate \</span><br><span class="line">docker-logrotate \</span><br><span class="line">docker-selinux \</span><br><span class="line">docker-engine-selinux \</span><br><span class="line">docker-engine</span><br><span class="line"></span><br><span class="line"><span class="comment">##设置yum docker repository</span></span><br><span class="line"> yum install -y yum-utils  device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line">  yum-config-manager --add-repo https:<span class="regexp">//</span>download.docker.com<span class="regexp">/linux/</span>centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="comment">##安装并启动 docker</span></span><br><span class="line"> yum install -y docker-ce-<span class="number">18.09</span>.<span class="number">7</span> docker-ce-cli-<span class="number">18.09</span>.<span class="number">7</span> containerd.io</span><br><span class="line"> systemctl enable docker</span><br><span class="line"> systemctl start docker</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 查看docker版本</span></span><br><span class="line">docker version</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 nfs-utils</span></span><br><span class="line">yum install -y nfs-utils</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置K8S的yum源</span></span><br><span class="line"></span><br><span class="line">cat &lt;&lt;EOF &gt; <span class="regexp">/etc/yum</span>.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/kubernetes/yum</span><span class="regexp">/repos/</span>kubernetes-el7-x86_64</span><br><span class="line">enabled=<span class="number">1</span></span><br><span class="line">gpgcheck=<span class="number">0</span></span><br><span class="line">repo_gpgcheck=<span class="number">0</span></span><br><span class="line">gpgkey=http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/kubernetes/yum</span><span class="regexp">/doc/yum</span>-key.gpg</span><br><span class="line">       http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/kubernetes/yum</span><span class="regexp">/doc/</span>rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line"> </span><br><span class="line"><span class="comment">#关闭 防火墙、SeLinux、swap</span></span><br><span class="line"></span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line"></span><br><span class="line">setenforce <span class="number">0</span></span><br><span class="line">sed -i <span class="string">&quot;s/SELINUX=enforcing/SELINUX=disabled/g&quot;</span> <span class="regexp">/etc/</span>selinux/config</span><br><span class="line"></span><br><span class="line">swapoff -a</span><br><span class="line">yes | cp <span class="regexp">/etc/</span>fstab <span class="regexp">/etc/</span>fstab_bak</span><br><span class="line">cat <span class="regexp">/etc/</span>fstab_bak |grep -v swap &gt; <span class="regexp">/etc/</span>fstab</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改 /etc/sysctl.conf</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vi <span class="regexp">/etc/</span>sysctl.conf</span><br><span class="line"><span class="comment">## 添加以下内容</span></span><br><span class="line">net.ipv4.ip_forward = <span class="number">1</span></span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = <span class="number">1</span></span><br><span class="line">net.bridge.bridge-nf-call-iptables = <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="comment"># 令以上内容执行生效</span></span><br><span class="line">sysctl -p</span><br><span class="line"></span><br><span class="line"><span class="comment">## 安装kubelet、kubeadm、kubectl</span></span><br><span class="line">yum install -y kubelet-<span class="number">1.15</span>.<span class="number">1</span> kubeadm-<span class="number">1.15</span>.<span class="number">1</span> kubectl-<span class="number">1.15</span>.<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 修改docker Cgroup Driver为systemd</span></span><br><span class="line"> vi <span class="regexp">/usr/</span>lib<span class="regexp">/systemd/</span>system/docker.service</span><br><span class="line"><span class="comment">## 在ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock添加</span></span><br><span class="line"> --exec-opt native.cgroupdriver=systemd</span><br><span class="line"></span><br><span class="line"><span class="comment">##设置 docker 镜像</span></span><br><span class="line">mkdir -p <span class="regexp">/etc/</span>docker</span><br><span class="line">tee <span class="regexp">/etc/</span>docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://hrei34jl.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"> <span class="comment"># 重启 docker，并启动 kubelet</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line">systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br><span class="line"></span><br><span class="line"><span class="comment">## 初始化 master 节点 需要换成物理网络ip</span></span><br><span class="line"><span class="comment"># 配置 apiserver.demo 的域名</span></span><br><span class="line">echo <span class="string">&quot;192.168.31.59 apiserver.demo&quot;</span> &gt;&gt; <span class="regexp">/etc/</span>hosts</span><br><span class="line"></span><br><span class="line"><span class="comment">##创建 ./kubeadm-config.yaml</span></span><br><span class="line">cat &lt;&lt;EOF &gt; ./kubeadm-config.yaml</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta1</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">kubernetesVersion: v1.<span class="number">15.1</span></span><br><span class="line">imageRepository: registry.cn-hangzhou.aliyuncs.com/google_containers</span><br><span class="line">controlPlaneEndpoint: <span class="string">&quot;apiserver.demo:6443&quot;</span></span><br><span class="line">networking:</span><br><span class="line">  podSubnet: <span class="string">&quot;10.100.0.1/20&quot;</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment">## 初始化 apiserver  根据您服务器网速的情况，您需要等候 1 - 10 分钟</span></span><br><span class="line">kubeadm init --config=kubeadm-config.yaml --upload-certs</span><br><span class="line"></span><br><span class="line">rm -rf <span class="regexp">/root/</span>.kube/</span><br><span class="line">mkdir <span class="regexp">/root/</span>.kube/</span><br><span class="line">cp -i <span class="regexp">/etc/</span>kubernetes<span class="regexp">/admin.conf /</span>root<span class="regexp">/.kube/</span>config</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">##安装 calico</span></span><br><span class="line"></span><br><span class="line">kubectl apply -f https:<span class="regexp">//</span>docs.projectcalico.org<span class="regexp">/v3.6/g</span>etting-started<span class="regexp">/kubernetes/i</span>nstallation<span class="regexp">/hosted/</span>kubernetes-datastore<span class="regexp">/calico-networking/</span><span class="number">1.7</span>/calico.yaml</span><br><span class="line"><span class="comment">##等待calico安装就绪：</span></span><br><span class="line"><span class="comment"># 可在 master 节点执行  执行如下命令，等待 3-10 分钟，直到所有的容器组处于 Running 状态</span></span><br><span class="line">watch kubectl get pod -n kube-system</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查 master 初始化结果</span></span><br><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure><p>安装成功：</p><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-4.png" alt="kubectl get pod -n kube-system"></p><h2 id="k8s-node-安装k8s-2-15版本"><a href="#k8s-node-安装k8s-2-15版本" class="headerlink" title="k8s node 安装k8s 2.15版本"></a>k8s node 安装k8s 2.15版本</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">##以下脚本在node节点执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 master 节点和 worker 节点都要执行</span></span><br><span class="line">cat <span class="regexp">/etc/</span>redhat-release</span><br><span class="line"><span class="comment"># 此处 hostname 的输出将会是该机器在 Kubernetes 集群中的节点名字</span></span><br><span class="line"><span class="comment"># 不能使用 localhost 作为节点的名字</span></span><br><span class="line">hostname</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请使用 lscpu 命令，核对 CPU 信息</span></span><br><span class="line"><span class="comment"># Architecture: x86_64    本安装文档不支持 arm 架构</span></span><br><span class="line"><span class="comment"># CPU(s):       2         CPU 内核数量不能低于 2</span></span><br><span class="line">lscpu</span><br><span class="line"><span class="comment"># 修改 hostname</span></span><br><span class="line">hostnamectl set-hostname k8s-node </span><br><span class="line"><span class="comment"># 查看修改结果</span></span><br><span class="line">hostnamectl status</span><br><span class="line"><span class="comment"># 设置 hostname 解析</span></span><br><span class="line">echo <span class="string">&quot;127.0.0.1   $(hostname)&quot;</span> &gt;&gt; <span class="regexp">/etc/</span>hosts</span><br><span class="line">cat <span class="regexp">/etc/</span>hosts</span><br><span class="line"></span><br><span class="line"><span class="comment">##安装docker:</span></span><br><span class="line"><span class="comment">##卸载旧版本</span></span><br><span class="line"> yum remove -y docker \</span><br><span class="line">docker-client \</span><br><span class="line">docker-client-latest \</span><br><span class="line">docker-common \</span><br><span class="line">docker-latest \</span><br><span class="line">docker-latest-logrotate \</span><br><span class="line">docker-logrotate \</span><br><span class="line">docker-selinux \</span><br><span class="line">docker-engine-selinux \</span><br><span class="line">docker-engine</span><br><span class="line"></span><br><span class="line"><span class="comment">##设置yum docker repository</span></span><br><span class="line"> yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line">yum-config-manager --add-repo https:<span class="regexp">//</span>download.docker.com<span class="regexp">/linux/</span>centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="comment">##安装并启动 docker</span></span><br><span class="line"> yum install -y docker-ce-<span class="number">18.09</span>.<span class="number">7</span> docker-ce-cli-<span class="number">18.09</span>.<span class="number">7</span> containerd.io</span><br><span class="line"> systemctl enable docker</span><br><span class="line"> systemctl start docker</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 查看docker版本</span></span><br><span class="line">docker version</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 nfs-utils</span></span><br><span class="line">yum install -y nfs-utils</span><br><span class="line"><span class="comment">#配置K8S的yum源</span></span><br><span class="line"></span><br><span class="line">cat &lt;&lt;EOF &gt; <span class="regexp">/etc/yum</span>.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/kubernetes/yum</span><span class="regexp">/repos/</span>kubernetes-el7-x86_64</span><br><span class="line">enabled=<span class="number">1</span></span><br><span class="line">gpgcheck=<span class="number">0</span></span><br><span class="line">repo_gpgcheck=<span class="number">0</span></span><br><span class="line">gpgkey=http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/kubernetes/yum</span><span class="regexp">/doc/yum</span>-key.gpg</span><br><span class="line">       http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/kubernetes/yum</span><span class="regexp">/doc/</span>rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line"> </span><br><span class="line"><span class="comment">#关闭 防火墙、SeLinux、swap</span></span><br><span class="line"></span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line"></span><br><span class="line">setenforce <span class="number">0</span></span><br><span class="line">sed -i <span class="string">&quot;s/SELINUX=enforcing/SELINUX=disabled/g&quot;</span> <span class="regexp">/etc/</span>selinux/config</span><br><span class="line"></span><br><span class="line">swapoff -a</span><br><span class="line">yes | cp <span class="regexp">/etc/</span>fstab <span class="regexp">/etc/</span>fstab_bak</span><br><span class="line">cat <span class="regexp">/etc/</span>fstab_bak |grep -v swap &gt; <span class="regexp">/etc/</span>fstab</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改 /etc/sysctl.conf</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vi <span class="regexp">/etc/</span>sysctl.conf</span><br><span class="line"><span class="comment">## 添加以下内容</span></span><br><span class="line">net.ipv4.ip_forward = <span class="number">1</span></span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = <span class="number">1</span></span><br><span class="line">net.bridge.bridge-nf-call-iptables = <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="comment"># 令以上内容执行生效</span></span><br><span class="line">sysctl -p</span><br><span class="line"></span><br><span class="line"><span class="comment">## 安装kubelet、kubeadm、kubectl</span></span><br><span class="line">yum install -y kubelet-<span class="number">1.15</span>.<span class="number">1</span> kubeadm-<span class="number">1.15</span>.<span class="number">1</span> kubectl-<span class="number">1.15</span>.<span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">## 修改docker Cgroup Driver为systemd</span></span><br><span class="line"> vi <span class="regexp">/usr/</span>lib<span class="regexp">/systemd/</span>system/docker.service</span><br><span class="line"><span class="comment">## 在ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock添加</span></span><br><span class="line"> --exec-opt native.cgroupdriver=systemd</span><br><span class="line"></span><br><span class="line"><span class="comment">##设置 docker 镜像</span></span><br><span class="line">mkdir -p <span class="regexp">/etc/</span>docker</span><br><span class="line"> tee <span class="regexp">/etc/</span>docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://hrei34jl.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 重启 docker，并启动 kubelet</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line">systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##针对所有的 worker 节点执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只在 worker 节点执行 设置masterip</span></span><br><span class="line">echo <span class="string">&quot;192.168.31.59  apiserver.demo&quot;</span> &gt;&gt; <span class="regexp">/etc/</span>hosts</span><br><span class="line"><span class="comment"># 到k8s master 主机执行获得 join命令参数 待</span></span><br><span class="line">kubeadm token create --print-join-command</span><br><span class="line"></span><br><span class="line">获取到命令复制至k8s node执行： kubeadm join apiserver.demo:<span class="number">6443</span> --token <span class="number">1</span>rgjij.n5a0x5mma7v7cylj     --discovery-token-ca-cert-hash sha256:ee62f5d762d73b4dde5abc2dc2ae0dfb69cd0e19ab8587f1b257e60f9aa648d5 </span><br><span class="line"></span><br><span class="line">可以在k8s master执行：</span><br><span class="line">watch kubectl get pod -n kube-system</span><br><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure><p>node ready:</p><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-3.png" alt="kubectl get nodes"></p><h1 id="使用kubectl-访问Kubernetes集群"><a href="#使用kubectl-访问Kubernetes集群" class="headerlink" title="使用kubectl 访问Kubernetes集群"></a>使用kubectl 访问Kubernetes集群</h1><p>以下后续kubectl命令在k8s master下执行kubectl</p><ul><li>kubectl version<br><img src="/2022/08/22/K8S%E7%9F%A5/pasted-5.png" alt="kubectl version"></li></ul><h2 id="kubectl-deploy-nginx"><a href="#kubectl-deploy-nginx" class="headerlink" title="kubectl deploy nginx"></a>kubectl deploy nginx</h2><ul><li>kubectl run nginx(默认namespace:default)<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">run</span> nginx <span class="attribute">--image</span>=nginx <span class="attribute">--replicas</span>=3</span><br></pre></td></tr></table></figure><img src="/2022/08/22/K8S%E7%9F%A5/pasted-6.png" alt="kubectl run nginx "></li><li>查看pod 列表<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">get</span> pod -o wide -n <span class="keyword">default</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-7.png" alt="图片/2022/08/22/K8S知/pasted-7.png"></p><ul><li>查看pod详细信息<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">describe</span> pod  nginx<span class="number">-7</span>bb7cd8db5<span class="operator">-</span>kjfm4 <span class="operator">-</span>n <span class="keyword">default</span></span><br></pre></td></tr></table></figure><img src="/2022/08/22/K8S%E7%9F%A5/pasted-8.png" alt="kubectl describe pod "></li><li>映射端口<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl expose deployment nginx <span class="attribute">--port</span>=88 <span class="attribute">--target-port</span>=80 <span class="attribute">--type</span>=NodePort -n default</span><br></pre></td></tr></table></figure></li><li>查看service<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">get</span> svc -o wide -n <span class="keyword">default</span></span><br></pre></td></tr></table></figure><img src="/2022/08/22/K8S%E7%9F%A5/pasted-9.png" alt="查看service"></li><li><a href="http://192.168.31.59:32125/">http://192.168.31.59:32125</a><br><img src="/2022/08/22/K8S%E7%9F%A5/pasted-10.png" alt="访问"></li><li>查看pod日志<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">log</span> -f  nginx<span class="number">-7</span>bb7cd8db5-kjfm4 -n <span class="literal">default</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-14.png" alt="图片/2022/08/22/K8S知/pasted-14.png"></p><ul><li>删除deploy<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">delete</span> deployment nginx -n <span class="keyword">default</span></span><br><span class="line">kubectl <span class="keyword">delete</span> svc nginx -n <span class="keyword">default</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="kubectl-管理Kubernetes-命令"><a href="#kubectl-管理Kubernetes-命令" class="headerlink" title="kubectl 管理Kubernetes 命令"></a>kubectl 管理Kubernetes 命令</h2><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-11.png" alt="kubectl 管理Kubernetes 命令1"></p><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-12.png" alt="kubectl 管理Kubernetes 命令2"></p><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-13.png" alt="kubectl 管理Kubernetes 命令3"></p><p>##部署一个kuboard<br>kubectl apply -f <a href="https://kuboard.cn/install-script/kuboard.yaml">https://kuboard.cn/install-script/kuboard.yaml</a></p><h1 id="安装Kuboard"><a href="#安装Kuboard" class="headerlink" title="安装Kuboard"></a>安装Kuboard</h1><p>Kuboard 是 Kubernetes 的一款图形化管理界面。</p><p><a href="https://kuboard.cn/learning/">https://kuboard.cn/learning/</a></p><ul><li><p>安装命令</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https:<span class="regexp">//</span>kuboard.cn<span class="regexp">/install-script/</span>kuboard.yaml</span><br></pre></td></tr></table></figure></li><li><p>执行命令 获取登录token</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n kube-system get secret <span class="constructor">$(<span class="params">kubectl</span> -<span class="params">n</span> <span class="params">kube</span>-<span class="params">system</span> <span class="params">get</span> <span class="params">secret</span> | <span class="params">grep</span> <span class="params">kuboard</span>-<span class="params">user</span> | <span class="params">awk</span> &#x27;&#123;<span class="params">print</span> $1&#125;&#x27;)</span> -o go-template=&#x27;&#123;&#123;.data.token&#125;&#125;&#x27; <span class="pattern-match">| base64 -d</span></span><br></pre></td></tr></table></figure></li><li><p>访问:<a href="http://192.168.31.59:32567/dashboard">http://192.168.31.59:32567/dashboard</a><br>(使用master主机ip 访问32567端口)<br><img src="/2022/08/22/K8S%E7%9F%A5/pasted-15.png" alt="kuboard"></p></li><li><p>使用第二步获取token进行登录</p></li></ul><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-16.png" alt="kuboard界面"></p><h1 id="YAML文件部署-滚动更新-、回滚，弹性伸缩"><a href="#YAML文件部署-滚动更新-、回滚，弹性伸缩" class="headerlink" title="YAML文件部署(滚动更新 、回滚，弹性伸缩)"></a>YAML文件部署(滚动更新 、回滚，弹性伸缩)</h1><ul><li>nginx .yaml<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.15</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service-nodeport</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure></li><li>在k8s master执行 启动nginx:1.15 ，3个实例<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">apply</span> -f nginx.yaml --<span class="built_in">record</span></span><br></pre></td></tr></table></figure></li><li>新开一个终端：<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch kubectl <span class="built_in">get</span> pod -o wide  </span><br></pre></td></tr></table></figure></li><li>弹性伸缩<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale <span class="attribute">--replicas</span>=5 deployments/nginx</span><br><span class="line">kubectl scale <span class="attribute">--replicas</span>=10 deployments/nginx</span><br><span class="line">kubectl scale <span class="attribute">--replicas</span>=2 deployments/nginx</span><br></pre></td></tr></table></figure></li><li>滚动更新<br>nginx16  镜像nginx:1.16<br>nginx17 镜像nginx:1.17<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">apply</span> -f nginx16.yaml --<span class="built_in">record</span></span><br><span class="line">kubectl <span class="built_in">apply</span> -f nginx17.yaml --<span class="built_in">record</span></span><br></pre></td></tr></table></figure></li><li>列出版本<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl rollout <span class="built_in">history</span> deployment nginx</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-17.png" alt="列出版本"></p><ul><li>回滚版本<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl rollout undo deployment nginx <span class="attribute">--to-revision</span>=2</span><br></pre></td></tr></table></figure></li><li>删除nginx<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">delete</span> -f nginx16.yaml</span><br></pre></td></tr></table></figure></li></ul><h1 id="yaml详解"><a href="#yaml详解" class="headerlink" title="yaml详解"></a>yaml详解</h1><h2 id="deployment-yaml-详解"><a href="#deployment-yaml-详解" class="headerlink" title="deployment.yaml 详解"></a>deployment.yaml 详解</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span>   <span class="comment">#接口版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>                 <span class="comment">#接口类型</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cango-demo</span>               <span class="comment">#Deployment名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">cango-prd</span>           <span class="comment">#命名空间</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">cango-demo</span>              <span class="comment">#标签</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span>  <span class="comment">##由于replicas为3,则整个升级,pod个数在2-4个之间</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">1</span>      <span class="comment">#滚动升级时会先启动1个pod</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">1</span> <span class="comment">#滚动升级时允许的最大Unavailable的pod个数</span></span><br><span class="line">  <span class="attr">template:</span>         </span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">cango-demo</span>  <span class="comment">#模板名称必填</span></span><br><span class="line">    <span class="attr">sepc:</span> <span class="comment">#定义容器模板，该模板可以包含多个容器</span></span><br><span class="line">      <span class="attr">containers:</span>                                                                   </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cango-demo</span>                                                           <span class="comment">#镜像名称</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">swr.cn-east-2.myhuaweicloud.com/cango-prd/cango-demo:0.0.1-SNAPSHOT</span> <span class="comment">#镜像地址</span></span><br><span class="line">          <span class="attr">command:</span> [ <span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;cat /etc/config/path/to/special-key&quot;</span> ]    <span class="comment">#启动命令</span></span><br><span class="line">          <span class="attr">args:</span>                                                                <span class="comment">#启动参数</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&#x27;-storage.local.retention=$(STORAGE_RETENTION)&#x27;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&#x27;-storage.local.memory-chunks=$(STORAGE_MEMORY_CHUNKS)&#x27;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&#x27;-config.file=/etc/prometheus/prometheus.yml&#x27;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&#x27;-alertmanager.url=http://alertmanager:9093/alertmanager&#x27;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&#x27;-web.external-url=$(EXTERNAL_URL)&#x27;</span></span><br><span class="line">    <span class="comment">#如果command和args均没有写，那么用Docker默认的配置。</span></span><br><span class="line">    <span class="comment">#如果command写了，但args没有写，那么Docker默认的配置会被忽略而且仅仅执行.yaml文件的command（不带任何参数的）。</span></span><br><span class="line">    <span class="comment">#如果command没写，但args写了，那么Docker默认配置的ENTRYPOINT的命令行会被执行，但是调用的参数是.yaml中的args。</span></span><br><span class="line">    <span class="comment">#如果如果command和args都写了，那么Docker默认的配置被忽略，使用.yaml的配置。</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>  <span class="comment">#如果不存在则拉取</span></span><br><span class="line">          <span class="attr">livenessProbe:</span>       <span class="comment">#表示container是否处于live状态。如果LivenessProbe失败，LivenessProbe将会通知kubelet对应的container不健康了。随后kubelet将kill掉container，并根据RestarPolicy进行进一步的操作。默认情况下LivenessProbe在第一次检测之前初始化值为Success，如果container没有提供LivenessProbe，则也认为是Success；</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/health</span> <span class="comment">#如果没有心跳检测接口就为/</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">              <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">            <span class="attr">initialDelaySeconds:</span> <span class="number">60</span> <span class="comment">##启动后延时多久开始运行检测</span></span><br><span class="line">            <span class="attr">timeoutSeconds:</span> <span class="number">5</span></span><br><span class="line">            <span class="attr">successThreshold:</span> <span class="number">1</span></span><br><span class="line">            <span class="attr">failureThreshold:</span> <span class="number">5</span></span><br><span class="line">          <span class="attr">readinessProbe:</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/health</span> <span class="comment">#如果没有心跳检测接口就为/</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">              <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">            <span class="attr">initialDelaySeconds:</span> <span class="number">30</span> <span class="comment">##启动后延时多久开始运行检测</span></span><br><span class="line">            <span class="attr">timeoutSeconds:</span> <span class="number">5</span></span><br><span class="line">            <span class="attr">successThreshold:</span> <span class="number">1</span></span><br><span class="line">            <span class="attr">failureThreshold:</span> <span class="number">5</span></span><br><span class="line">          <span class="attr">resources:</span>              <span class="comment">##CPU内存限制</span></span><br><span class="line">            <span class="attr">requests:</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="number">2</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">2048Mi</span></span><br><span class="line">            <span class="attr">limits:</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="number">2</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">2048Mi</span></span><br><span class="line">          <span class="attr">env:</span>                    <span class="comment">##通过环境变量的方式，直接传递pod=自定义Linux OS环境变量</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">LOCAL_KEY</span>     <span class="comment">#本地Key</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">value</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CONFIG_MAP_KEY</span>  <span class="comment">#局策略可使用configMap的配置Key，</span></span><br><span class="line">              <span class="attr">valueFrom:</span></span><br><span class="line">                <span class="attr">configMapKeyRef:</span></span><br><span class="line">                  <span class="attr">name:</span> <span class="string">special-config</span>   <span class="comment">#configmap中找到name为special-config</span></span><br><span class="line">                  <span class="attr">key:</span> <span class="string">special.type</span>      <span class="comment">#找到name为special-config里data下的key</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">              <span class="attr">containerPort:</span> <span class="number">8080</span> <span class="comment">#对service暴露端口</span></span><br><span class="line">          <span class="attr">volumeMounts:</span>     <span class="comment">#挂载volumes中定义的磁盘</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">log-cache</span></span><br><span class="line">            <span class="attr">mount:</span> <span class="string">/tmp/log</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">sdb</span>       <span class="comment">#普通用法，该卷跟随容器销毁，挂载一个目录</span></span><br><span class="line">            <span class="attr">mountPath:</span> <span class="string">/data/media</span>    </span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs-client-root</span>    <span class="comment">#直接挂载硬盘方法，如挂载下面的nfs目录到/mnt/nfs</span></span><br><span class="line">            <span class="attr">mountPath:</span> <span class="string">/mnt/nfs</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">example-volume-config</span>  <span class="comment">#高级用法第1种，将ConfigMap的log-script,backup-script分别挂载到/etc/config目录下的一个相对路径path/to/...下，如果存在同名文件，直接覆盖。</span></span><br><span class="line">            <span class="attr">mountPath:</span> <span class="string">/etc/config</span>       </span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">rbd-pvc</span>                <span class="comment">#高级用法第2中，挂载PVC(PresistentVolumeClaim)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#使用volume将ConfigMap作为文件或目录直接挂载，其中每一个key-value键值对都会生成一个文件，key为文件名，value为内容，</span></span><br><span class="line">  <span class="attr">volumes:</span>  <span class="comment"># 定义磁盘给上面volumeMounts挂载</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">log-cache</span></span><br><span class="line">    <span class="attr">emptyDir:</span> &#123;&#125;</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">sdb</span>  <span class="comment">#挂载宿主机上面的目录</span></span><br><span class="line">    <span class="attr">hostPath:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/any/path/it/will/be/replaced</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">example-volume-config</span>  <span class="comment"># 供ConfigMap文件内容到指定路径使用</span></span><br><span class="line">    <span class="attr">configMap:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">example-volume-config</span>  <span class="comment">#ConfigMap中名称</span></span><br><span class="line">      <span class="attr">items:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">log-script</span>           <span class="comment">#ConfigMap中的Key</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">path/to/log-script</span>  <span class="comment">#指定目录下的一个相对路径path/to/log-script</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">backup-script</span>        <span class="comment">#ConfigMap中的Key</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">path/to/backup-script</span>  <span class="comment">#指定目录下的一个相对路径path/to/backup-script</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs-client-root</span>         <span class="comment">#供挂载NFS存储类型</span></span><br><span class="line">    <span class="attr">nfs:</span></span><br><span class="line">      <span class="attr">server:</span> <span class="number">10.42</span><span class="number">.0</span><span class="number">.55</span>          <span class="comment">#NFS服务器地址</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/opt/public</span>           <span class="comment">#showmount -e 看一下路径</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">rbd-pvc</span>                 <span class="comment">#挂载PVC磁盘</span></span><br><span class="line">    <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">      <span class="attr">claimName:</span> <span class="string">rbd-pvc1</span>         <span class="comment">#挂载已经申请的pvc磁盘</span></span><br></pre></td></tr></table></figure><h2 id="Service-yaml文件详解"><a href="#Service-yaml文件详解" class="headerlink" title="Service yaml文件详解"></a>Service yaml文件详解</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">matadata:</span>                                <span class="comment">#元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">string</span>                           <span class="comment">#service的名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">string</span>                      <span class="comment">#命名空间  </span></span><br><span class="line">  <span class="attr">labels:</span>                                <span class="comment">#自定义标签属性列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span></span><br><span class="line">  <span class="attr">annotations:</span>                           <span class="comment">#自定义注解属性列表  </span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">spec:</span>                                    <span class="comment">#详细描述</span></span><br><span class="line">  <span class="attr">selector:</span> []                           <span class="comment">#label selector配置，将选择具有label标签的Pod作为管理 </span></span><br><span class="line">                                         <span class="comment">#范围</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">string</span>                           <span class="comment">#service的类型，指定service的访问方式，默认为 </span></span><br><span class="line">                                         <span class="comment">#clusterIp</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">string</span>                      <span class="comment">#虚拟服务地址      </span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="string">string</span>                <span class="comment">#是否支持session</span></span><br><span class="line">  <span class="attr">ports:</span>                                 <span class="comment">#service需要暴露的端口列表</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>                         <span class="comment">#端口名称</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">string</span>                     <span class="comment">#端口协议，支持TCP和UDP，默认TCP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">int</span>                            <span class="comment">#服务监听的端口号</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="string">int</span>                      <span class="comment">#需要转发到后端Pod的端口号</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="string">int</span>                        <span class="comment">#当type = NodePort时，指定映射到物理机的端口号</span></span><br><span class="line">  <span class="attr">status:</span>                                <span class="comment">#当spce.type=LoadBalancer时，设置外部负载均衡器的地址</span></span><br><span class="line">    <span class="attr">loadBalancer:</span>                        <span class="comment">#外部负载均衡器    </span></span><br><span class="line">      <span class="attr">ingress:</span>                           <span class="comment">#外部负载均衡器 </span></span><br><span class="line">        <span class="attr">ip:</span> <span class="string">string</span>                       <span class="comment">#外部负载均衡器的Ip地址值</span></span><br><span class="line">        <span class="attr">hostname:</span> <span class="string">string</span>                 <span class="comment">#外部负载均衡器的主机名</span></span><br></pre></td></tr></table></figure><h2 id="pv-yaml"><a href="#pv-yaml" class="headerlink" title="pv.yaml"></a>pv.yaml</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="pvc-yaml"><a href="#pvc-yaml" class="headerlink" title="pvc.yaml"></a>pvc.yaml</h2><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">apiVersion</span><span class="punctuation">:</span> <span class="string">v1</span></span><br><span class="line"><span class="attribute">kind</span><span class="punctuation">:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attribute">metadata</span><span class="punctuation">:</span></span><br><span class="line">  <span class="attribute">name</span><span class="punctuation">:</span> <span class="string">nginx-pvc</span></span><br><span class="line">  <span class="attribute">namespace</span><span class="punctuation">:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attribute">spec</span><span class="punctuation">:</span></span><br><span class="line"><span class="attribute">spec</span><span class="punctuation">:</span></span><br><span class="line">  <span class="attribute">accessModes</span><span class="punctuation">:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attribute">resources</span><span class="punctuation">:</span></span><br><span class="line">    <span class="attribute">requests</span><span class="punctuation">:</span></span><br><span class="line">      <span class="attribute">storage</span><span class="punctuation">:</span> <span class="string">20Gi</span></span><br><span class="line">  <span class="attribute">storageClassName</span><span class="punctuation">:</span> <span class="string">nginx-pv</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="namespace-yaml"><a href="#namespace-yaml" class="headerlink" title="namespace.yaml"></a>namespace.yaml</h2><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">kind:</span> Namespace  --创建命名空间</span><br><span class="line"><span class="symbol">apiVersion:</span> v1</span><br><span class="line"><span class="symbol">metadata:</span></span><br><span class="line"><span class="symbol">  name:</span> nginx  --名称</span><br><span class="line"><span class="symbol">  labels:</span></span><br><span class="line"><span class="symbol">   name:</span> nginx</span><br></pre></td></tr></table></figure><h2 id="ingress-yaml"><a href="#ingress-yaml" class="headerlink" title="ingress.yaml"></a>ingress.yaml</h2><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">apiVersion</span><span class="punctuation">:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attribute">kind</span><span class="punctuation">:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attribute">metadata</span><span class="punctuation">:</span></span><br><span class="line">  <span class="attribute">name</span><span class="punctuation">:</span> <span class="string">ingress-yaohong1</span></span><br><span class="line">  <span class="attribute">namespace</span><span class="punctuation">:</span> <span class="string">kuboard</span></span><br><span class="line">  <span class="attribute">annotations</span><span class="punctuation">:</span></span><br><span class="line">       <span class="attribute">kubernetes.io/ingress.class</span><span class="punctuation">:</span> <span class="string">&quot;nginx&quot;</span></span><br><span class="line"><span class="attribute">spec</span><span class="punctuation">:</span></span><br><span class="line">  <span class="attribute">rules</span><span class="punctuation">:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">host: test.nginx1.com</span></span><br><span class="line">      <span class="attribute">http</span><span class="punctuation">:</span></span><br><span class="line">        <span class="attribute">paths</span><span class="punctuation">:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">path: /                </span></span><br><span class="line">          <span class="attribute">backend</span><span class="punctuation">: </span></span><br><span class="line">            <span class="attribute">serviceName</span><span class="punctuation">:</span> <span class="string">nginx-service</span></span><br><span class="line">            <span class="attribute">servicePort</span><span class="punctuation">:</span> <span class="string">80</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">host: test.kuboard.com</span></span><br><span class="line">      <span class="attribute">http</span><span class="punctuation">:</span></span><br><span class="line">        <span class="attribute">paths</span><span class="punctuation">:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">path: /               </span></span><br><span class="line">          <span class="attribute">backend</span><span class="punctuation">: </span></span><br><span class="line">            <span class="attribute">serviceName</span><span class="punctuation">:</span> <span class="string">kuboard</span></span><br><span class="line">            <span class="attribute">servicePort</span><span class="punctuation">:</span> <span class="string">80</span></span><br></pre></td></tr></table></figure><h1 id="Pod-和-Sevice联系"><a href="#Pod-和-Sevice联系" class="headerlink" title="Pod 和 Sevice联系"></a>Pod 和 Sevice联系</h1><ul><li>Kubernetes 中 Pod 是随时可以消亡的（节点故障、容器内应用程序错误等原因）。如果使用 Deployment 运行您的应用程序，Deployment 将会在 Pod 消亡后再创建一个新的 Pod 以维持所需要的副本数。每一个 Pod 有自己的 IP 地址，然而，对于 Deployment 而言，对应 Pod 集合是动态变化的。<br>这个现象导致了如下问题：<ul><li>如果某些 Pod（假设是 ‘backends’）为另外一些 Pod（假设是 ‘frontends’）提供接口，在 ‘backends’ 中的 Pod 集合不断变化（IP 地址也跟着变化）的情况下，</li><li>‘frontends’ 中的 Pod 如何才能知道应该将请求发送到哪个 IP 地址？</li></ul></li></ul><p>Service 存在的意义，就是为了解决这个问题。</p><h2 id="Kubernetes-Service"><a href="#Kubernetes-Service" class="headerlink" title="Kubernetes Service"></a>Kubernetes Service</h2><p>Kubernetes 中 Service 是一个 API 对象，通过 kubectl + YAML 或者 Kuboard，定义一个 Service，可以将符合 Service 指定条件的 Pod 作为可通过网络访问的服务提供给服务调用者。<br>Service 是 Kubernetes 中的一种服务发现机制：<br>    * Pod 有自己的 IP 地址<br>    * Service 被赋予一个唯一的 dns name<br>    * Service 通过 label selector 选定一组 Pod<br>    * Service 实现负载均衡，可将请求均衡分发到选定这一组 Pod 中</p><p>例如，假设有一个无状态的图像处理后端程序运行了 3 个 Pod 副本。这些副本是相互可替代的（前端程序调用其中任何一个都可以）。在后端程序的副本集中的 Pod 经常变化（销毁、重建、扩容、缩容等）的情况下，前端程序不应该关注这些变化。</p><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-18.png" alt="服务图"></p><h2 id="service网络–NodePort"><a href="#service网络–NodePort" class="headerlink" title="service网络–NodePort"></a>service网络–NodePort</h2><p>（1）通过设置nodePort映射到物理机，同时设置Service的类型为NodePort：</p><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-19.png" alt="NodePort"></p><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-21.png" alt="yaml配置"></p><h2 id="通过Loadbalance将服务暴露出来"><a href="#通过Loadbalance将服务暴露出来" class="headerlink" title="通过Loadbalance将服务暴露出来"></a>通过Loadbalance将服务暴露出来</h2><p>LoadBalancer 服务是暴露服务到 internet 的标准方式。在 GKE 上，这种方式会启动一个 Network Load Balancer[2]，它将给你一个单独的 IP 地址，转发所有流量到你的服务。</p><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-22.png" alt="Loadbalance"><br>这个方式的最大缺点是每一个用 LoadBalancer 暴露的服务都会有它自己的 IP 地址，每个用到的 LoadBalancer 都需要付费，这将是非常昂贵的。</p><h2 id="通过Ingress暴露服务"><a href="#通过Ingress暴露服务" class="headerlink" title="通过Ingress暴露服务"></a>通过Ingress暴露服务</h2><p>为什么使用Ingress，一个重要的原因是LoadBalancer服务都需要创建自己的负载均衡器，以及独有的公有Ip地址，而Ingress只需要一个公网Ip就能为许多服务提供访问。<br><img src="/2022/08/22/K8S%E7%9F%A5/pasted-23.png" alt="Ingress"><br>Ingress 事实上不是一种服务类型。相反，它处于多个服务的前端，扮演着“智能路由”或者集群入口的角色。你可以用 Ingress 来做许多不同的事情，各种不同类型的 Ingress 控制器也有不同的能力。</p><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-24.png" alt="Ingress2"></p><h3 id="了解Ingress的工作原理"><a href="#了解Ingress的工作原理" class="headerlink" title="了解Ingress的工作原理"></a>了解Ingress的工作原理</h3><ul><li><p>1）ingress是kubernetes的一个资源对象，用于编写定义规则。</p></li><li><p>2）反向代理负载均衡器，通常以Service的Port方式运行，接收并按照ingress定义的规则进行转发，通常为nginx，haproxy，traefik等，本次使用nginx。</p></li><li><p>3）ingress-controller，监听apiserver，获取服务新增，删除等变化，并结合ingress规则动态更新到反向代理负载均衡器上，并重载配置使其生效。</p></li></ul><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-25.png" alt="Ingress的工作原理"></p><ul><li>1.ingress controller通过和kubernetes api交互，动态的去感知集群中ingress规则变化，</li><li>2.然后读取它，按照自定义的规则，规则就是写明了哪个域名对应哪个service，生成一段nginx配置，</li><li>3.再写到nginx-ingress-control的pod里，这个Ingress controller的pod里运行着一个Nginx服务，控制器会把生成的nginx配置写入&#x2F;etc&#x2F;nginx.conf文件中，</li><li>4.然后reload一下使配置生效。以此达到域名分配置和动态更新的问题。</li></ul><h3 id="Ingress-可以解决什么问题"><a href="#Ingress-可以解决什么问题" class="headerlink" title="Ingress 可以解决什么问题"></a>Ingress 可以解决什么问题</h3><ul><li><p>1.动态配置服务<br>　　如果按照传统方式, 当新增加一个服务时, 我们可能需要在流量入口加一个反向代理指向我们新的k8s服务. 而如果用了Ingress, 只需要配置好这个服务, 当服务启动时, 会自动注册到Ingress的中, 不需要而外的操作.</p></li><li><p>2.减少不必要的端口暴露<br>　　配置过k8s的都清楚, 第一步是要关闭防火墙的, 主要原因是k8s的很多服务会以NodePort方式映射出去, 这样就相当于给宿主机打了很多孔, 既不安全也不优雅. 而Ingress可以避免这个问题, 除了Ingress自身服务可能需要映射出去, 其他服务都不要用NodePort方式</p></li></ul><p>通过相同的Ingress暴露多少服务</p><ul><li>1.将不同的服务映射到相同的主机不同的路径</li><li>2 将不同的服务映射到不同的主机上</li></ul><h3 id="安装Ingress"><a href="#安装Ingress" class="headerlink" title="安装Ingress"></a>安装Ingress</h3><ul><li>下载<a href="/download/ingress.zip">ingress脚本</a> ，解压<br>后上传至k8s master主机</li></ul><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-26.png" alt="包含文件"></p><ul><li>运行ingress-nginx <figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">apply</span> -f mandatory.yaml</span><br></pre></td></tr></table></figure></li><li>配置ingress-nginx-svc.yaml 修改externalIPS ip 为k8s master 和k8s node节点ip</li></ul><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-27.png" alt="ingress-nginx-svc.yaml"></p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">apply</span> -f ingress-nginx.svc.yaml</span><br></pre></td></tr></table></figure><ul><li><p>以下命令运行nginx 和kuboard镜像–目的测试ingress<br>创建kuboard 命名空间</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">apply</span> -f kuboard-<span class="keyword">namespace</span>.yaml</span><br></pre></td></tr></table></figure></li><li><p>创建nginx</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl  <span class="built_in">apply</span> -f nginx.yaml</span><br></pre></td></tr></table></figure></li><li><p>创建kuboard</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">apply</span> -f kuboard.yaml</span><br></pre></td></tr></table></figure></li><li><p>获取token  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n kuboard get secret <span class="constructor">$(<span class="params">kubectl</span> -<span class="params">n</span> <span class="params">kuboard</span> <span class="params">get</span> <span class="params">secret</span> | <span class="params">grep</span> <span class="params">kuboard</span>-<span class="params">user</span> | <span class="params">awk</span> &#x27;&#123;<span class="params">print</span> $1&#125;&#x27;)</span> -o go-template=&#x27;&#123;&#123;.data.token&#125;&#125;&#x27; <span class="pattern-match">| base64 -d</span></span><br><span class="line"><span class="pattern-match"></span></span><br></pre></td></tr></table></figure></li><li><p>host文件设置 </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span>.<span class="number">31.59</span> apiserver<span class="selector-class">.demo</span> test<span class="selector-class">.nginx</span><span class="selector-class">.com</span>  test<span class="selector-class">.kuboard</span><span class="selector-class">.com</span> test<span class="selector-class">.nginx1</span><span class="selector-class">.com</span> test<span class="selector-class">.nginx2</span>.com</span><br></pre></td></tr></table></figure></li><li><p>配置<a href="http://test.nginx.com/">http://test.nginx.com/</a> 访问nginx<br>kubectl apply -f ingress.yml</p></li></ul><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-28.png" alt="test.nginx.com"></p><ul><li>配置 <a href="http://test.nginx1.com/">http://test.nginx1.com/</a> 访问nginx <a href="http://test.kuboard.com/">http://test.kuboard.com/</a> 访问 kuboard <figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">apply</span> -f ingress1.yml</span><br></pre></td></tr></table></figure><img src="/2022/08/22/K8S%E7%9F%A5/pasted-29.png" alt="test.nginx1.com"></li></ul><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-30.png" alt="test.kuboard.com"></p><ul><li><a href="http://test.nginx2.com/nginx">http://test.nginx2.com/nginx</a> <a href="http://test.nginx2.com/kuboard">http://test.nginx2.com/kuboard</a>  同一域名不同路径<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">apply</span> -f ingress2.yml</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-31.png" alt="test.nginx2.com/nginx "></p><p>仅是模拟不同域名下不同路径 映射不同pod,正常访问kuboard 需要访问test.kuboard.com<br><img src="/2022/08/22/K8S%E7%9F%A5/pasted-33.png" alt="http://test.nginx2.com/kuboard"></p><ul><li>获取ingress<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">get</span> ingress <span class="comment">--all-namespaces</span></span><br></pre></td></tr></table></figure></li><li>删除<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">delete</span> -f nginx.yaml</span><br><span class="line"></span><br><span class="line">kubectl <span class="keyword">delete</span> -f kuboard.yaml</span><br><span class="line">kubectl <span class="keyword">delete</span> -f ingress.yml</span><br><span class="line">kubectl <span class="keyword">delete</span> -f ingress1.yml</span><br><span class="line">kubectl <span class="keyword">delete</span> -f ingress2.yml</span><br><span class="line">kubectl <span class="keyword">delete</span> -f kuboard-<span class="keyword">namespace</span>.yaml</span><br></pre></td></tr></table></figure></li></ul><h1 id="k8s-dns"><a href="#k8s-dns" class="headerlink" title="k8s-dns"></a>k8s-dns</h1><p>前面我们给大家讲解了 Service 的用法，我们可以通过 Service 生成的 ClusterIP(VIP)来访问 Pod 提供的服务，但是在使用的时候还有一个问题：我们怎么知道某个应用的 VIP 呢？比如我们有两个应用，一个是 api 应用，一个是 db 应用，两个应用都是通过 Deployment 进行管理的，并且都通过 Service 暴露出了端口提供服务。api 需要连接到 db 这个应用，我们只知道 db 应用的名称和 db 对应的 Service 的名称，但是并不知道它的 VIP 地址，我们前面的 Service 课程中是不是学习到我们通过 ClusterIP 就可以访问到后面的 Pod 服务，如果我们知道了 VIP 的地址是不是就行了？</p><p>那就是可以直接使用 Service 的名称，因为 Service 的名称不会变化，我们不需要去关心分配的 ClusterIP 的地址，因为这个地址并不是固定不变的，所以如果我们直接使用 Service 的名字，然后对应的 ClusterIP 地址的转换能够自动完成就很好了。我们知道名字和 IP 直接的转换是不是和我们平时访问的网站非常类似啊？他们之间的转换功能通过 DNS 就可以解决了，同样的，Kubernetes 也提供了 DNS 的方案来解决上面的服务发现的问题。<br>DNS 服务不是一个独立的系统服务，而是作为一种 addon 插件而存在，也就是说不是 Kubernetes 集群必须安装的，当然我们强烈推荐安装，可以将这个插件看成是一种运行在 Kubernetes 集群上的一直比较特殊的应用，现在比较推荐的两个插件：kube-dns 和 CoreDNS。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">get</span> pods -n kube-system -l <span class="attribute">k8s-app</span>=kube-dns -o wide</span><br></pre></td></tr></table></figure><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-36.png" alt="core dns"></p><h1 id="PV和PVC"><a href="#PV和PVC" class="headerlink" title="PV和PVC"></a>PV和PVC</h1><p>*　管理存储是管理计算的一个明显问题。该PersistentVolume子系统为用户和管理员提供了一个API，用于抽象如何根据消费方式提供存储的详细信息。为此，我们引入了两个新的API资源：PersistentVolume和PersistentVolumeClaim</p><p>*　　PersistentVolume（PV）是集群中由管理员配置的一段网络存储。 它是集群中的资源，就像节点是集群资源一样。 PV是容量插件，如Volumes，但其生命周期独立于使用PV的任何单个pod。 此API对象捕获存储实现的详细信息，包括NFS，iSCSI或特定于云提供程序的存储系统。</p><p>　　PersistentVolumeClaim（PVC）是由用户进行存储的请求。 它类似于pod。 Pod消耗节点资源，PVC消耗PV资源。Pod可以请求特定级别的资源（CPU和内存）。声明可以请求特定的大小和访问模式<br>访问模式：</p><ul><li>ReadWriteOnce – the volume can be mounted as read-write by a single node</li><li>ReadOnlyMany – the volume can be mounted read-only by many nodes</li><li>ReadWriteMany – the volume can be mounted as read-write by many nodes</li></ul><p>*　　虽然PersistentVolumeClaims允许用户使用抽象存储资源，但是PersistentVolumes对于不同的问题，用户通常需要具有不同属性（例如性能）。群集管理员需要能够提供各种PersistentVolumes不同的方式，而不仅仅是大小和访问模式，而不会让用户了解这些卷的实现方式。对于这些需求，有StorageClass 资源。<br>*　　StorageClass为管理员提供了一种描述他们提供的存储的“类”的方法。 不同的类可能映射到服务质量级别，或备份策略，或者由群集管理员确定的任意策略。 Kubernetes本身对于什么类别代表是不言而喻的。 这个概念有时在其他存储系统中称为“配置文件”。<br>*　　PVC和PV是一一对应的。</p><h2 id="生命周期-Provisioning-——-gt-Binding-——–-gt-Using——-gt-Releasing——-gt-Recycling"><a href="#生命周期-Provisioning-——-gt-Binding-——–-gt-Using——-gt-Releasing——-gt-Recycling" class="headerlink" title="(生命周期)Provisioning ——-&gt; Binding ——–&gt;Using——&gt;Releasing——&gt;Recycling"></a>(生命周期)Provisioning ——-&gt; Binding ——–&gt;Using——&gt;Releasing——&gt;Recycling</h2><ul><li>供应准备Provisioning—通过集群外的存储系统或者云平台来提供存储持久化支持。</li></ul><ul><li>静态提供Static：集群管理员创建多个PV。 它们携带可供集群用户使用的真实存储的详细信息。 它们存在于Kubernetes API中，可用于消费</li><li>动态提供Dynamic：当管理员创建的静态PV都不匹配用户的PersistentVolumeClaim时，集群可能会尝试为PVC动态配置卷。 此配置基于StorageClasses：PVC必须请求一个类，并且管理员必须已创建并配置该类才能进行动态配置。 要求该类的声明有效地为自己禁用动态配置。</li></ul><ul><li>绑定Bound—用户创建pvc并指定需要的资源和访问模式。在找到可用pv之前，pvc会保持未绑定状态。</li><li>使用Using—用户可在pod中像volume一样使用pvc。</li><li>释放Releasing—用户删除pvc来回收存储资源，pv将变成“released”状态。由于还保留着之前的数据，这些数据需要根据不同的策略来处理，否则这些存储资源无法被其他pvc使用。</li><li>回收Recycling—pv可以设置三种回收策略：保留（Retain），回收（Recycle）和删除（Delete）。</li></ul><ul><li>保留策略：允许人工处理保留的数据。</li><li>删除策略：将删除pv和外部关联的存储资源，需要插件支持。</li><li>回收策略：将执行清除操作，之后可以被新的pvc使用，需要插件支持。</li></ul><ul><li>注：目前只有NFS和HostPath类型卷支持回收策略，AWS EBS,GCE PD,Azure Disk和Cinder支持删除(Delete)策略。</li></ul><h2 id="PV和PVC–以NFS为例子"><a href="#PV和PVC–以NFS为例子" class="headerlink" title="PV和PVC–以NFS为例子"></a>PV和PVC–以NFS为例子</h2><p>NFS（Network File System）即网络文件系统，它允许网络中的计算机之间通过TCP&#x2F;IP网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。</p><ul><li>安装nfs-utils master node<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y <span class="built_in">nfs</span>-utils  rpcbind</span><br><span class="line">systemctl start rpcbind <span class="built_in">nfs</span></span><br><span class="line">systemctl enable  rpcbind <span class="built_in">nfs</span></span><br></pre></td></tr></table></figure></li><li>k8s主机设置nfs 共享<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p <span class="regexp">/pv/</span>nginx</span><br><span class="line">cd <span class="regexp">/pv/</span>nginx</span><br><span class="line">vi index.html</span><br></pre></td></tr></table></figure></li><li>index.html内容<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Welcome to nginx!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">35em</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">font-family</span>: Tahoma, Verdana, Arial, sans-serif;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome to nginx!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>For online documentation and support please refer to</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://nginx.org/&quot;</span>&gt;</span>nginx.org<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">Commercial support is available at</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://nginx.com/&quot;</span>&gt;</span>nginx.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>Thank you for using nginx.!!!!<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>设置共享盘 修改masterip<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi <span class="regexp">/etc/</span>exports</span><br></pre></td></tr></table></figure></li><li>添加以下内容 后保存 换一下k8s masterip<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/pv/</span>nginx   <span class="number">192.168</span>.<span class="number">31.59</span>/<span class="number">24</span>(rw,sync)</span><br></pre></td></tr></table></figure></li><li>执行exportfs -arv<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">exportfs -arv</span></span><br></pre></td></tr></table></figure></li><li>k8s master node执行 换一下k8s masterip<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">showmount</span> -e <span class="number">192.168.31.59</span></span><br></pre></td></tr></table></figure></li><li>下载<a href="/download/pv.zip">pv.zip</a> ,解压后上传至k8s master</li></ul><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-32.png" alt="pv 文件"></p><ul><li>创建nginx命名空间<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">apply</span> -f nginx-<span class="keyword">namespace</span>.yaml</span><br></pre></td></tr></table></figure></li><li>查看命名空间<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">get</span> ns</span><br></pre></td></tr></table></figure></li><li>创建pv 记得修改masterip<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">apply</span> -f nginxpv.yaml</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-37.png" alt="nginx pv"></p><ul><li>查看pv<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get <span class="built_in">pv</span> -<span class="built_in">n</span> nginx</span><br></pre></td></tr></table></figure></li><li>创建pvc<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">apply</span> -f nginxpvc.yaml</span><br></pre></td></tr></table></figure></li><li>查看pvc<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">get</span> pvc -n nginx</span><br></pre></td></tr></table></figure></li><li>运行nginx <figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">apply</span> -f nginx.yaml</span><br></pre></td></tr></table></figure></li><li>查看pod<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">get</span> pod -n nginx</span><br></pre></td></tr></table></figure></li><li>查看svc<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">kubectl</span> <span class="meta">get</span> <span class="keyword">svc</span> -n nginx</span><br></pre></td></tr></table></figure></li><li>查看ingress 信息<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">get</span> ingress -n nginx</span><br></pre></td></tr></table></figure></li><li>设置主机名：192.168.31.59 test.nginxpv.com</li><li>浏览器访问：<a href="http://test.nginxpv.com/">http://test.nginxpv.com/</a></li></ul><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-38.png" alt="test.nginxpv.com"></p><ul><li>删除<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">delete</span> -f nginx.yaml</span><br></pre></td></tr></table></figure></li></ul><h1 id="helm"><a href="#helm" class="headerlink" title="helm"></a>helm</h1><p>我们在 k8s 中部署一个应用，通常面临以下几个问题：</p><ul><li>如何统一管理、配置和更新这些分散的 k8s 的应用资源文件</li><li>如何分发和复用一套应用模板</li><li>如何将应用的一系列资源当做一个软件包管理</li></ul><h2 id="Helm-管理-k8s集群"><a href="#Helm-管理-k8s集群" class="headerlink" title="Helm 管理 k8s集群"></a>Helm 管理 k8s集群</h2><p>Helm 可以理解为 Kubernetes 的包管理工具，可以方便地发现、共享和使用为Kubernetes构建的应用。<br>Helm 采用客户端&#x2F;服务器架构，有如下组件组成：</p><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-34.png" alt="helm"><br>Helm CLI 是 Helm 客户端，可以在本地执行</p><p>Tiller 是服务器端组件，在 Kubernetes 群集上运行，并管理 Kubernetes 应用程序的生命周期</p><p>Repository 是 Chart 仓库，Helm客户端通过HTTP协议来访问仓库中Chart的索引文件和压缩包。</p><p>chart Helm的打包格式叫做chart，所谓chart就是一系列文件, 它描述了一组相关的 k8s 集群资源</p><p>release 使用 helm install 命令在 Kubernetes 集群中部署的 Chart 称为 Release</p><h2 id="mac安装"><a href="#mac安装" class="headerlink" title="mac安装"></a>mac安装</h2><ul><li>k8s master主机下<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">create</span> serviceaccount --<span class="keyword">namespace</span> kube-<span class="keyword">system</span> tiller</span><br></pre></td></tr></table></figure><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create clusterrolebinding <span class="keyword">default</span>-view --clusterrole=<span class="keyword">cluster</span>-admin --serviceaccount=<span class="keyword">default</span>:<span class="keyword">default</span></span><br></pre></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">create</span> clusterrolebinding tiller-<span class="keyword">cluster</span>-admin --clusterrole=<span class="keyword">cluster</span>-admin --serviceaccount=kube-<span class="keyword">system</span>:tiller</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-39.png" alt="kubectl tiller"></p><ul><li>copy master上 &#x2F;root&#x2F;.kube&#x2F;onfig文件至mac 用户目录下.kube&#x2F;</li><li>下载 mac 版本helm<br><a href="https://get.helm.sh/helm-v2.15.0-darwin-amd64.tar.gz">https://get.helm.sh/helm-v2.15.0-darwin-amd64.tar.gz</a><br>其它版本：<a href="https://github.com/helm/helm/releases/tag/v2.15.0">https://github.com/helm/helm/releases/tag/v2.15.0</a></li><li>mac电脑 下载解压后<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp helm <span class="regexp">/usr/</span>local/bin</span><br><span class="line">chmod +x <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>helm</span><br></pre></td></tr></table></figure></li><li>mac命令执行<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm init <span class="attr">--service-account</span> tiller <span class="attr">--upgrade</span> <span class="attr">--tiller-image</span>=registry<span class="selector-class">.cn-hangzhou</span><span class="selector-class">.aliyuncs</span>.com/google_containers/tiller:v2.<span class="number">15.1</span> <span class="attr">--stable-repo-url</span> https:<span class="comment">//kubernetes.oss-cn-hangzhou.aliyuncs.com/charts</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-40.png" alt="helm init"></p><ul><li>成功后 查看helm 版本<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm <span class="built_in">version</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-41.png" alt="helm version"></p><h2 id="helm-chart-的基本结构"><a href="#helm-chart-的基本结构" class="headerlink" title="helm chart 的基本结构"></a>helm chart 的基本结构</h2><ul><li>helm create nginxhelm<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">helm create nginxhelm</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-43.png" alt="nginxhelm 目录"></p><p>charts 目录存放依赖的chart</p><p>Chart.yaml 包含Chart的基本信息，包括chart版本，名称等</p><p>templates 目录下存放应用一系列 k8s 资源的 yaml 模板<br>_helpers.tpl 此文件中定义一些可重用的模板片断，此文件中的定义在任何资源定义模板中可用</p><p>NOTES.txt 介绍chart 部署后的帮助信息，如何使用chart等</p><p>values.yaml 包含了必要的值定义（默认值）, 用于存储 </p><p>templates 目录中模板文件中用到变量的值</p><h2 id="helm-部署"><a href="#helm-部署" class="headerlink" title="helm 部署"></a>helm 部署</h2><ul><li>检查 语法<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">helm</span> lint nginxhelm/ </span><br></pre></td></tr></table></figure><img src="/2022/08/22/K8S%E7%9F%A5/pasted-44.png" alt="helm lint nginxhelm"></li><li>打包：<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm <span class="keyword">package</span> <span class="title">nginxhelm --debug</span></span><br></pre></td></tr></table></figure></li><li>部署<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm install nginxhelm <span class="comment">--name nginxhelm</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-46.png" alt="helm install "></p><ul><li>在k8s节点进行访问 curl <a href="http://clusterip/">http://clusterip</a></li></ul><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-47.png" alt="访问"></p><h2 id="helm（升级-和回退）"><a href="#helm（升级-和回退）" class="headerlink" title="helm（升级 和回退）"></a>helm（升级 和回退）</h2><ul><li><p>修改：Chart.yaml version 0.2.1–&gt;0.2.2<br><img src="/2022/08/22/K8S%E7%9F%A5/pasted-48.png" alt="Chart.yaml"></p></li><li><p>打包：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm <span class="keyword">package</span> <span class="title">nginxhelm --debug</span></span><br></pre></td></tr></table></figure></li><li><p>查看版本信息：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">helm search nginxhelm -l</span></span><br></pre></td></tr></table></figure></li><li><p>升级</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">helm upgrade nginxhelm nginxhelm</span> </span><br></pre></td></tr></table></figure><p>(helmproject项目有什么更改都可以通过upgrade进行更新k8s)</p></li><li><p>查看已经升级到最新版本</p> <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">helm list</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-49.png" alt=" helm list"></p><ul><li>回退： <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">helm</span> rollback nginxhelm <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-50.png" alt="helm rollback 后查看helm list"></p><ul><li>删除<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm <span class="built_in">delete</span> <span class="comment">--purge nginxhelm </span></span><br></pre></td></tr></table></figure></li></ul><h2 id="helm-常用命令"><a href="#helm-常用命令" class="headerlink" title="helm 常用命令"></a>helm 常用命令</h2><p><img src="/2022/08/22/K8S%E7%9F%A5/pasted-42.png" alt="图片/2022/08/22/K8S知/pasted-42.png"></p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li>k8s 教程：<a href="https://www.kubernetes.org.cn/doc-11">https://www.kubernetes.org.cn/doc-11</a></li><li>k8s 安装：<a href="https://kuboard.cn/install/install-dashboard.html">https://kuboard.cn/install/install-dashboard.html</a></li><li>k8s pc&#x2F;PVC:<a href="http://www.mamicode.com/info-detail-1523110.html">http://www.mamicode.com/info-detail-1523110.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker知识</title>
      <link href="/2022/08/21/Docker%E7%9F%A5%E8%AF%86/"/>
      <url>/2022/08/21/Docker%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="部署方式演变"><a href="#部署方式演变" class="headerlink" title="部署方式演变"></a>部署方式演变</h1><p><img src="/2022/08/21/Docker%E7%9F%A5/pasted-0.png" alt="部署方式演变"></p><ul><li><p>传统部署时代<br>早期，企业直接将应用程序部署在物理机上。由于物理机上不能为应用程序定义资源使用边界，我们也就很难合理地分配计算资源。例如：如果多个应用程序运行在同一台物理机上，可能发生这样的情况：其中的一个应用程序消耗了大多数的计算资源，导致其他应用程序不能正常运行。应对此问题的一种解决办法是，将每一个应用程序运行在不同的物理机上。然而，这种做法无法大规模实施，因为资源利用率很低，且企业维护更多物理机的成本昂贵。<br><img src="/2022/08/21/Docker%E7%9F%A5/pasted-1.png" alt="传统部署时代"></p></li><li><p>虚拟化部署时代</p><ul><li>针对上述问题，虚拟化技术应运而生。用户可以在单台物理机的CPU上运行多个虚拟机（Virtual Machine）。</li><li>虚拟化技术使得应用程序被虚拟机相互分隔开，限制了应用程序之间的非法访问，进而提供了一定程度的安全性。</li><li>虚拟化技术提高了物理机的资源利用率，可以更容易地安装或更新应用程序，降低了硬件成本，因此可以更好地规模化实施。</li><li>每一个虚拟机可以认为是被虚拟化的物理机之上的一台完整的机器，其中运行了一台机器的所有组件，包括虚拟机自身的操作系统。<br><img src="/2022/08/21/Docker%E7%9F%A5/pasted-2.png" alt="虚拟化部署时代"></li></ul><p>  </p></li><li><p>容器化部署时代<br>容器与虚拟机类似，但是降低了隔离层级，共享了操作系统。因此，容器可以认为是轻量级的。<br>与虚拟机相似，每个容器拥有自己的文件系统、CPU、内存、进程空间等<br>运行应用程序所需要的资源都被容器包装，并和底层基础架构解耦<br>容器化的应用程序可以跨云服务商、跨Linux操作系统发行版进行部署</p></li></ul><p><img src="/2022/08/21/Docker%E7%9F%A5/pasted-3.png" alt="容器化部署时代"></p><h1 id="什么是docker"><a href="#什么是docker" class="headerlink" title="什么是docker"></a>什么是docker</h1><ul><li><p>Docker 是一个开源的应用容器引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在本地编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。</p></li><li><p>简单的理解，Docker类似于集装箱，各式各样的货物，经过集装箱的标准化进行托管，而集装箱和集装箱之间没有影响。也就是说，Docker平台就是一个软件集装箱化平台，这就意味着我们自己可以构建应用程序，将其依赖关系一起打包到一个容器中，然后这容器就很容易运送到其他的机器上进行运行，而且非常易于装载、复制、移除，非常适合软件弹性架构。</p></li></ul><h2 id="docker跟虚拟机区别"><a href="#docker跟虚拟机区别" class="headerlink" title="docker跟虚拟机区别"></a>docker跟虚拟机区别</h2><p>Docker可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。</p><p>两者有什么差异呢？</p><p>虚拟机（virtual machine）是在操作系统中模拟硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的Ubuntu应用了。</p><p>Docker仅仅是封装函数库，并没有模拟完整的操作系统，如图：</p><p><img src="/2022/08/21/Docker%E7%9F%A5/pasted-9.png" alt="docker跟虚拟机区别1"><br>由于容器所需的资源要少得多（例如，它们不需要一个完整的 OS），所以它们易于部署且可快速启动。这使你能够具有更高的密度，也就是说，这允许你在同一硬件单元上运行更多服务，从而降低了成本</p><p>对比<br><img src="/2022/08/21/Docker%E7%9F%A5/pasted-4.png" alt="docker跟虚拟机区别2"><br>  <br><img src="/2022/08/21/Docker%E7%9F%A5/pasted-8.png" alt="docker跟虚拟机区别3">  </p><h2 id="docker-好处（节省项目环境部署时间）"><a href="#docker-好处（节省项目环境部署时间）" class="headerlink" title="docker 好处（节省项目环境部署时间）"></a>docker 好处（节省项目环境部署时间）</h2><ul><li><p>场景1：单项目打包</p><ul><li><p>每次部署项目到测试、生产等环境，都要部署一大堆依赖的软件、工具，而且部署期间出现问题几率很大，不经意就花费了很长时间。</p></li><li><p>Docker主要理念就是环境打包部署，可在任意Docker Engine运行。前期我们只需要将每个项目环境打包到镜像，push到镜像仓库，当有需要部署这个项目时，直接pull镜像启动容器，这个项目就可以访问了！一次构建多次部署，一劳永逸。</p></li></ul></li><li><p>场景二：环境一致性</p><ul><li><p>开发工程师在Windows系统上开发项目，测试、生产环境操作系统都是Linux系统，这就产生了环境不一致的情况：项目在开发电脑本地运行没问题，到了测试或生产环境就运行不起来，解决这问题最好方式就是这三处环境保持一致。软件版本、操作系统、物理机、云主机……试想下，能做到吗？</p></li><li><p>Docker将项目环境打包成镜像，可以在任何Docker Engine上浪。此时Docker就是我们这些项目的基石，Docker可移植性，保持运行状态一致性，可想而知，是否更容易解决问题呢？</p></li></ul></li><li><p>场景三：持续集成</p><p>  *一个项目版本快速迭代的测试场景，需要一个合理的CI（持续集成）&#x2F;CD（持续部署）环境支撑。CI&#x2F;CD是一个周期性自动化项目测试流程，包括构建、部署、测试、发布等工作，很少需要人工干预。</p></li></ul><p>项目测试流程大致如下图：</p><p><img src="/2022/08/21/Docker%E7%9F%A5/pasted-11.png" alt="图片/2022/08/21/Docker知/pasted-11.png"></p><p>Docker结合Jenkins构建持续集成环境大致如下图：</p><p><img src="/2022/08/21/Docker%E7%9F%A5/pasted-12.png" alt="图片/2022/08/21/Docker知/pasted-12.png"><br>Docker在上面这个图的作用是项目镜像构建和快速部署，打通测试环境与生产环境，高度保持多个环境之间一致性。</p><ul><li>场景四：微服务<ul><li><p>微服务是近几年来IT圈内谈论比较多的一个名词，意义也很简单：尽可能细粒度拆分业务程序架构，由多个独立服务组成业务系统。</p></li><li><p>Docker的容器设计原则：一个容器一个服务，容器之间相互隔离，不妨试想一下，如果容器作为这些独立服务的部署单元，是不是有点恰到好处呢？</p></li></ul></li><li>场景五：弹性伸缩<ul><li><p>说到弹性伸缩，通常是集群模式下存在。像AWS AutoScaling，可以自定义资源阈值，SLB自动添加EC2云主机，应对业务访问量突发情况。</p></li><li><p>当适用Docker技术以后，这种弹性伸缩的单元就是云主机之上的容器了。</p></li><li><p>容器集群化管理已经有成熟的解决方案，比如：官方的Swarm，谷歌的K8S</p></li><li><p>由于Docker容器快速启动特性，可以很快速的启动几十个、上百个容器来提供更多并发和资源利用率（如果宿主机资源不够，还需要加主机到集群中）。</p></li></ul></li></ul><h2 id="docker-好处总结"><a href="#docker-好处总结" class="headerlink" title="docker 好处总结"></a>docker 好处总结</h2><p>根据上述应用场景总结下Docker特点：开箱即用，快速部署，可移植性强，环境隔离等。<br>简化部署流程，提高生产力！</p><h1 id="mac安装docker"><a href="#mac安装docker" class="headerlink" title="mac安装docker"></a>mac安装docker</h1><p><a href="https://petertanblog.github.io/2022/08/21/Mac%E6%8A%80%E5%B7%A7/#%E5%AE%89%E8%A3%85Docker">mac安装docker</a></p><h1 id="docker安装nginx"><a href="#docker安装nginx" class="headerlink" title="docker安装nginx"></a>docker安装nginx</h1><ul><li><p>run nginx</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> run -d --name nginx  -p <span class="number">8081</span>:<span class="number">80</span> ngin</span><br></pre></td></tr></table></figure></li><li><p>访问Nginx<br><a href="http://localhost:8081/">http://localhost:8081</a><br><img src="/2022/08/21/Docker%E7%9F%A5/pasted-13.png" alt="访问Nginx"></p></li><li><p>查看log</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker logs -f nginx</span></span><br></pre></td></tr></table></figure><p><img src="/2022/08/21/Docker%E7%9F%A5/pasted-14.png" alt="查看log"></p></li><li><p>进入容器</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -<span class="keyword">it</span> nginx bash</span><br></pre></td></tr></table></figure><p><img src="/2022/08/21/Docker%E7%9F%A5/pasted-15.png" alt="进入容器"></p></li><li><p>停止容器</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop nginx</span><br></pre></td></tr></table></figure></li><li><p>查看容器情况</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -<span class="selector-tag">a</span></span><br></pre></td></tr></table></figure><p><img src="/2022/08/21/Docker%E7%9F%A5/pasted-16.png" alt="查看容器情况"></p><ul><li>清理停止容器<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">container</span> prune</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2022/08/21/Docker%E7%9F%A5/pasted-17.png" alt="清理停止容器"></p><ul><li>新建目录 在某个目录新建html<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir html</span><br></pre></td></tr></table></figure></li><li>进入目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> html</span><br></pre></td></tr></table></figure></li><li>创建页面<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;welcome to nginx&#x27;</span> &gt; <span class="built_in">index</span>.html</span><br></pre></td></tr></table></figure></li><li>运行命令<br>把命令行xxx换成html目录下<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name some-nginx -v <span class="regexp">/xxx/</span>html:<span class="regexp">/usr/</span>share<span class="regexp">/nginx/</span>html -p <span class="number">8081</span>:<span class="number">80</span> -d nginx</span><br></pre></td></tr></table></figure></li><li>重新访问<a href="http://localhost:8081/">http://localhost:8081</a><br><img src="/2022/08/21/Docker%E7%9F%A5/pasted-18.png" alt="重新访问"></li></ul><h2 id="运行-nginx的总结"><a href="#运行-nginx的总结" class="headerlink" title="运行 nginx的总结"></a>运行 nginx的总结</h2><p>docker核心：镜像，容器，仓库</p><p>docker 常用命令：</p><ul><li>run— 运行一个镜像</li><li>images –查看本地镜像库</li><li>ps -a –查看本地所有容器状态</li><li>container prune –清理不正常容器</li><li>stop –停止容器</li><li>logs -f 容器id或容器名称 –查看日志</li><li>exec -it 容器id或容器名称  sh –进入容器</li><li>docker info–查看docker 信息</li></ul><h1 id="Docker-daemon"><a href="#Docker-daemon" class="headerlink" title="Docker daemon"></a>Docker daemon</h1><ul><li>docker采用C&#x2F;S架构，Dcoker daemon作为服务端接受来自客户端请求，并处理这些请求，比如创建容器、管理镜像。</li><li>为了兼容OCI标准，Docker1.1之后也做了架构调整，Docker容器运行已经不是简单的通过Docker daemon来启动，而是集成了containerd、runc等多个组件。</li></ul><p><img src="/2022/08/21/Docker%E7%9F%A5/pasted-19.png" alt="Docker daemon"></p><ul><li>Containerd：是一个简单的守护进程，管理shim，向Docker Engine提供接口。使用UnixSocket通信，协议是grpc。</li><li>Shim：管理一个容器</li><li>runC：运行一个容器。是基于OCI标准的一个容器技术实现，是一个可以直接创建和运行容器的工具。runc直接与容器所依赖的cgroups&#x2F;kernel等进行交互，负责容器所需环境。</li></ul><h2 id="docker-镜像（image）"><a href="#docker-镜像（image）" class="headerlink" title="docker -镜像（image）"></a>docker -镜像（image）</h2><ul><li>Docker的流行，很大因素是取决于有数十万计免费的应用镜像，使得用户或者开发者很容器找到可用的镜像。</li><li>镜像不是一个单一的文件，而是有多层构成。可以理解为镜像是创建容器的模板，一个镜像可以创建N个容器。镜像通常封装了一个应用的基础环境。</li><li>Docker 镜像（Image），就相当于是一个 root 文件系统（不包含linux内核而有精简linux操作系统）</li></ul><h2 id="docker–容器-container"><a href="#docker–容器-container" class="headerlink" title="docker–容器(container)"></a>docker–容器(container)</h2><ul><li><p>Container中文意思是集装箱，很多人叫容器，其实延续了原理的Linux container，不管叫哪个，含义是一样的。我觉得叫容器比较合适。容器本质上是Linux系统上的一个进程，这个父进程可能会有多个子进程组成，这个一组进程受资源限制，与其他组进程之间隔离。这种运行时的状态成为容器。</p></li><li><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p></li></ul><h2 id="docker-镜像仓库-images-Repository"><a href="#docker-镜像仓库-images-Repository" class="headerlink" title="docker 镜像仓库(images Repository)"></a>docker 镜像仓库(images Repository)</h2><ul><li>容器是通过镜像创建的，大量的镜像需要找一个地方存放，这就需要Registry（注册中心）。</li><li>企业通常自建私有仓库，也可以使用公共仓库，例如：<ul><li>Docker Hub 地址：<a href="https://hub.docker.com/">https://hub.docker.com</a></li><li>Docker官方提供的公共托管Registry，上面有很多现成的镜像，Docker CLI默认就是从这个仓库下载的。</li><li>VMware Harbor 地址：<a href="https://github.com/goharbor/harbor">https://github.com/goharbor/harbor</a> VMware Harbor（简称Harbor）项目是由VMware中国研发团队开发的开源容器镜像仓库系统</li></ul></li></ul><h1 id="build-java环境-dockerfile"><a href="#build-java环境-dockerfile" class="headerlink" title="build java环境(dockerfile)"></a>build java环境(dockerfile)</h1><p>我们要运行一个spring boot web项目，我们就需要安装java，配置环境变量等等<br>现在我使用DockerFile  创建有java环境镜像</p><ul><li>设置<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">阿里云镜像加速</a><br><img src="/2022/08/21/Docker%E7%9F%A5/pasted-35.png" alt="阿里云镜像加速"></li><li>centos Dockerfile内容<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">FROM centos </span><br><span class="line">LABEL Author=<span class="string">&quot;ywtana&lt;xx@qq.com&gt;&quot;</span> </span><br><span class="line">RUN sed -i -e <span class="string">&quot;s|mirrorlist=|#mirrorlist=|g&quot;</span> /etc/yum.repos.d/CentOS-* &amp;&amp; \</span><br><span class="line">    sed -i -e <span class="string">&quot;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&quot;</span> /etc/yum.repos.d/CentOS-* &amp;&amp; \ </span><br><span class="line">    yum -y update &amp;&amp; \ </span><br><span class="line">    yum install -y java-11-openjdk tzdata &amp;&amp; \</span><br><span class="line">    yum clean packages &amp;&amp; \</span><br><span class="line">    <span class="built_in">cp</span> /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; \</span><br><span class="line">    <span class="built_in">echo</span> Asia/Shanghai &gt; /etc/timezone &amp;&amp; \</span><br><span class="line">    <span class="built_in">rm</span> -rf /tmp/* /var/cache/*</span><br><span class="line">RUN groupadd -r <span class="built_in">test</span> &amp;&amp; \</span><br><span class="line">    useradd -g <span class="built_in">test</span>  -r <span class="built_in">test</span> &amp;&amp; \</span><br><span class="line">    <span class="built_in">mkdir</span> /test  &amp;&amp; \</span><br><span class="line">    <span class="built_in">chown</span> -R <span class="built_in">test</span>:<span class="built_in">test</span>  /test</span><br><span class="line">USER <span class="built_in">test</span></span><br><span class="line">WORKDIR /test</span><br><span class="line">RUN <span class="built_in">ls</span> -al /</span><br><span class="line"></span><br></pre></td></tr></table></figure>build命令<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t openjdk11_centos .</span><br></pre></td></tr></table></figure>build成功后<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker images</span></span><br></pre></td></tr></table></figure>运行 test用户登录<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -u <span class="built_in">test</span>:<span class="built_in">test</span> -itd --name openjdk openjdk11_centos</span></span><br></pre></td></tr></table></figure>进入容器：<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -<span class="keyword">it</span> openjdk sh</span><br></pre></td></tr></table></figure>进入容器后输入<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java <span class="built_in">version</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="/2022/08/21/Docker%E7%9F%A5/pasted-37.png" alt="java version"></p><p><img src="/2022/08/21/Docker%E7%9F%A5/pasted-38.png" alt="test目录"></p><h2 id="Dockfile描述"><a href="#Dockfile描述" class="headerlink" title="Dockfile描述"></a>Dockfile描述</h2><p><img src="/2022/08/21/Docker%E7%9F%A5/pasted-20.png" alt="Dockfile描述"></p><h2 id="DockerFile-指令"><a href="#DockerFile-指令" class="headerlink" title="DockerFile 指令"></a>DockerFile 指令</h2><p><img src="/2022/08/21/Docker%E7%9F%A5/pasted-21.png" alt="DockerFile 指令1"><br><img src="/2022/08/21/Docker%E7%9F%A5/pasted-22.png" alt="DockerFile 指令2"></p><h1 id="docker-命令"><a href="#docker-命令" class="headerlink" title="docker 命令"></a>docker 命令</h1><h2 id="上传docker镜像至阿里云"><a href="#上传docker镜像至阿里云" class="headerlink" title="上传docker镜像至阿里云"></a>上传docker镜像至阿里云</h2><ul><li>点击<a href="https://cr.console.aliyun.com/cn-hangzhou/instance/namespaces">链接</a>进行阿里云镜像命名空间<br><img src="/2022/08/21/Docker%E7%9F%A5/pasted-32.png" alt="创建命名空间"></li><li>设置<a href="https://cr.console.aliyun.com/cn-hangzhou/instance/credentials">访问密码</a></li></ul><p><img src="/2022/08/21/Docker%E7%9F%A5/pasted-33.png" alt="访问密码"></p><ul><li>打开终端登录阿里云Docker Registry<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker login <span class="attr">--username</span>=<span class="number">3586</span>*****@<span class="number">163</span><span class="selector-class">.com</span> registry<span class="selector-class">.cn-hangzhou</span><span class="selector-class">.aliyuncs</span>.com</span><br></pre></td></tr></table></figure></li><li>docker tag<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">tag</span> <span class="title">nginx</span>  registry.cn-hangzhou.aliyuncs.com/test_peter/nginx:latest</span><br></pre></td></tr></table></figure></li><li>docker push<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">push</span> registry.cn-hangzhou.aliyuncs.com<span class="regexp">/test_peter/</span>nginx:latest</span><br></pre></td></tr></table></figure></li><li>docker pull<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com<span class="regexp">/test_peter/</span>nginx:latest</span><br></pre></td></tr></table></figure><img src="/2022/08/21/Docker%E7%9F%A5/pasted-23.png" alt="docker 命令"></li></ul><h2 id="docker命令说明"><a href="#docker命令说明" class="headerlink" title="docker命令说明"></a>docker命令说明</h2><p><img src="/2022/08/21/Docker%E7%9F%A5/pasted-24.png" alt="docker 命令1"></p><p><img src="/2022/08/21/Docker%E7%9F%A5/pasted-25.png" alt="docker 命令2"></p><h2 id="docker-run-参数说明"><a href="#docker-run-参数说明" class="headerlink" title="docker run 参数说明"></a>docker run 参数说明</h2><p>语法：docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</p><ul><li>-d: 后台运行容器，并返回容器ID；</li><li>-i: 以交互模式运行容器，通常与 -t 同时使用；</li><li>-p: 指定端口映射，格式为：主机(宿主)端口:容器端口</li><li>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li><li>–name&#x3D;”nginx-lb”: 为容器指定一个名称；</li><li>–dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；</li><li>-h “mars”: 指定容器的hostname；</li><li>-e username&#x3D;”ritchie”: 设置环境变量；</li><li>–env-file&#x3D;[]: 从指定文件读入环境变量；</li><li>–cpuset&#x3D;”0-2” or –cpuset&#x3D;”0,1,2”: 绑定容器到指定CPU运行；</li><li>-m :设置容器使用内存最大值；</li><li>–net&#x3D;”bridge”: 指定容器的网络连接类型，支持 bridge&#x2F;host&#x2F;none&#x2F;container: 四种类型；</li><li>–volume , -v: 绑定一个卷</li></ul><h1 id="docker-镜像与容器联系和存储驱动"><a href="#docker-镜像与容器联系和存储驱动" class="headerlink" title="docker 镜像与容器联系和存储驱动"></a>docker 镜像与容器联系和存储驱动</h1><ul><li>Docker镜像是由多个只读层添加而成，启动容器时，Docker加载值读镜像层并在镜像栈顶部添加一个读写层。</li><li>如果运行中的容器修改了现有的一个已经存在的文件，那么该文件将会在读写层下面的只读层复制到读写层，该文件的只读版本仍然存在，只是已经被读写曾中该文件的副本所隐层，这就是我们所说的写时复制，Elasticsearch也是用了写时复制。和这个略有不同。</li><li>默认情况下，容器不使用任何 volume，此时，容器的数据被保存在容器之内，它只在容器的生命周期内存在，关闭并重启容器，其数据不会受到影响，但是删除Docker容器，数据将会全部丢失。当然，也可以使用 docker commit 命令将它持久化为一个新的镜像</li><li>Docker的数据持久化即使数据不随着container的结束而结束，数据存在于host机器上——要么存在于host的某个指定目录中（使用bind mount），要么使用docker自己管理的volume（&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes下）</li><li>docker run 指定 -v参数</li><li>bind mount例如：<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name some-nginx -v <span class="regexp">/root/</span>html:<span class="regexp">/usr/</span>share<span class="regexp">/nginx/</span>html -p <span class="number">8081</span>:<span class="number">80</span> -d nginx</span><br></pre></td></tr></table></figure></li><li>使用docker volume create my-volume-2 后<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name some-nginx -v my-volume<span class="number">-2</span><span class="symbol">:/usr/share/nginx/html</span> -p <span class="number">8081</span><span class="symbol">:</span><span class="number">80</span> -d nginx</span><br></pre></td></tr></table></figure></li></ul><h1 id="docker网络"><a href="#docker网络" class="headerlink" title="docker网络"></a>docker网络</h1><ul><li><p>Docker自身的4种网络工作方式，和一些自定义网络模式<br>安装Docker时，它会自动创建三个网络，bridge（创建容器默认连接到此网络）、 none 、host</p><ul><li>host：容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。</li><li>Container：创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围。<br>None：该模式关闭了容器的网络功能。</li><li>Bridge：此模式会为每一个容器分配、设置IP等，并将容器连接到一个docker0虚拟网桥，通过docker0网桥以及Iptables nat表配置与宿主机通信。</li></ul></li><li><p>使用docker network ls 命令列出这些网络</p></li></ul><p><img src="/2022/08/21/Docker%E7%9F%A5/pasted-26.png" alt="docker network ls"></p><ul><li>run创建Docker容器时<ul><li>host模式：使用 –net&#x3D;host 指定。</li><li>none模式：使用 –net&#x3D;none 指定。</li><li>bridge模式：使用 –net&#x3D;bridge 指定，默认设置。</li><li>container模式：使用 –net&#x3D;container:NAME_or_ID 指定。</li></ul></li></ul><h1 id="docker-原理"><a href="#docker-原理" class="headerlink" title="docker 原理"></a>docker 原理</h1><p><img src="/2022/08/21/Docker%E7%9F%A5/pasted-27.png" alt="docker 原理"></p><ul><li><p>命名空间（namespaces）是 Linux 为我们提供的用于分离进程树、网络接口、挂载点以及进程间通信等资源的方法。</p></li><li><p>CGroups:让系统中所运行任务(进程)的用户定义组分配资源—比如CPU时间、系统内存、网络带宽</p></li><li><p>UnionFS:把文件系统上多个目录(分支)内容联合挂载到同一个目录下</p></li></ul><h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><p>命名空间（namespaces）是 Linux 为我们提供的用于分离进程树、网络接口、挂载点以及进程间通信等资源的方法。在日常使用 Linux 或者 macOS 时，我们并没有运行多个完全分离的服务器的需要，但是如果我们在服务器上启动了多个服务，这些服务其实会相互影响的，每一个服务都能看到其他服务的进程，也可以访问宿主机器上的任意文件，这是很多时候我们都不愿意看到的，我们更希望运行在同一台机器上的不同服务能做到完全隔离，就像运行在多台不同的机器上一样。</p><p><img src="/2022/08/21/Docker%E7%9F%A5/pasted-28.png" alt="namespace"></p><h2 id="CGroups"><a href="#CGroups" class="headerlink" title="CGroups"></a>CGroups</h2><p>我们通过 Linux 的命名空间为新创建的进程隔离了文件系统、网络并与宿主机器之间的进程相互隔离，但是命名空间并不能够为我们提供物理资源上的隔离，比如 CPU 或者内存，如果在同一台机器上运行了多个对彼此以及宿主机器一无所知的『容器』，这些容器却共同占用了宿主机器的物理资源。</p><p><img src="/2022/08/21/Docker%E7%9F%A5/pasted-29.png" alt="CGroups"></p><h2 id="UnionFS"><a href="#UnionFS" class="headerlink" title="UnionFS"></a>UnionFS</h2><p>Linux 的命名空间和控制组分别解决了不同资源隔离的问题，前者解决了进程、网络以及文件系统的隔离，后者实现了 CPU、内存等资源的隔离，但是在 Docker 中还有另一个非常重要的问题需要解决 - 也就是镜像。<br><img src="/2022/08/21/Docker%E7%9F%A5/pasted-31.png" alt="UnionFS"></p><h1 id="docker-常用镜像"><a href="#docker-常用镜像" class="headerlink" title="docker 常用镜像"></a>docker 常用镜像</h1><h2 id="docker-mysql"><a href="#docker-mysql" class="headerlink" title="docker mysql"></a>docker mysql</h2><ul><li>运行mysql 并映射本地数据文件夹 ，映射容器服务的 3306 端口到宿主机的 3306 端口。外部可以直接通过宿主机ip:3306 访问到  的服务；–restart&#x3D;always参数能够使我们在重启docker时,自动启动相关容器<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysql --restart=always -p <span class="number">3306</span>:<span class="number">3306</span> -v <span class="regexp">/Users/</span>tanyanwen<span class="regexp">/Downloads/</span>html<span class="regexp">/mysql:/</span>var<span class="regexp">/lib/my</span>sql -e MYSQL_ROOT_PASSWORD=<span class="number">123456</span> -d mysql:<span class="number">5.7</span></span><br></pre></td></tr></table></figure></li><li>命令进入mysql容器 <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql <span class="regexp">/bin/</span>bash</span><br></pre></td></tr></table></figure></li><li>输入mysql命令 登录mysql<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -<span class="selector-tag">p</span></span><br></pre></td></tr></table></figure><img src="/2022/08/21/Docker%E7%9F%A5/pasted-36.png" alt="mysql命令"></li></ul><h2 id="docker-redis"><a href="#docker-redis" class="headerlink" title="docker redis"></a>docker redis</h2><ul><li>运行redis 镜像 并映射容器服务的 6379 端口到宿主机的 6379 端口。外部可以直接通过宿主机ip:6379 访问到 Redis 的服务；–restart&#x3D;always参数能够使我们在重启docker时,自动启动相关容器<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">run</span> -itd <span class="attribute">--restart</span>=always --name redis -p 6379:6379 redis</span><br></pre></td></tr></table></figure></li></ul><h2 id="ubuntu-build-openjdk11环境"><a href="#ubuntu-build-openjdk11环境" class="headerlink" title="ubuntu build openjdk11环境"></a>ubuntu build openjdk11环境</h2><ul><li>Dockfile<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu </span><br><span class="line">LABEL Author=<span class="string">&quot;peter&lt;xx@qq.com&gt;&quot;</span> </span><br><span class="line">RUN apt update -y &amp;&amp; \  </span><br><span class="line"> apt upgrade -y &amp;&amp; \</span><br><span class="line"> apt install  -y openjdk-11-jre-headless tzdata &amp;&amp; \</span><br><span class="line"> <span class="built_in">cp</span> /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; \</span><br><span class="line"> <span class="built_in">echo</span> Asia/Shanghai &gt; /etc/timezone &amp;&amp; \</span><br><span class="line"> <span class="built_in">rm</span> -rf /tmp/* /var/cache/*</span><br><span class="line"> RUN groupadd -r  <span class="built_in">test</span> &amp;&amp; \</span><br><span class="line">    useradd -g <span class="built_in">test</span> -r <span class="built_in">test</span> &amp;&amp; \</span><br><span class="line">    <span class="built_in">mkdir</span> /test  &amp;&amp; \</span><br><span class="line">    <span class="built_in">chown</span> -R <span class="built_in">test</span>:<span class="built_in">test</span>  /test</span><br><span class="line">USER <span class="built_in">test</span></span><br><span class="line">WORKDIR /test</span><br><span class="line">RUN <span class="built_in">ls</span> -al /</span><br></pre></td></tr></table></figure></li><li>执行build命令<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t openjdk11_ubuntu .</span><br></pre></td></tr></table></figure></li><li>运行<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">run</span> -u test:test -<span class="keyword">it</span> <span class="comment">--name openjdk openjdk11_ubuntu</span></span><br></pre></td></tr></table></figure></li><li>查看java<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -<span class="built_in">version</span></span><br></pre></td></tr></table></figure><img src="/2022/08/21/Docker%E7%9F%A5/pasted-41.png" alt="java -version"></li></ul><h2 id="alpine-build-openjdk11环境"><a href="#alpine-build-openjdk11环境" class="headerlink" title="alpine build openjdk11环境"></a>alpine build openjdk11环境</h2><ul><li>Dockfile<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine </span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> Author=<span class="string">&quot;peter&lt;xx@qq.com&gt;&quot;</span> </span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&#x27;s/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g&#x27;</span> /etc/apk/repositories &amp;&amp; \</span></span><br><span class="line"><span class="language-bash"> apk update &amp;&amp; \  </span></span><br><span class="line"> apk upgrade &amp;&amp; \</span><br><span class="line"> apk <span class="keyword">add</span><span class="language-bash"> openjdk11 tzdata &amp;&amp; \</span></span><br><span class="line"><span class="language-bash"> <span class="built_in">cp</span> /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; \</span></span><br><span class="line"><span class="language-bash"> <span class="built_in">echo</span> Asia/Shanghai &gt; /etc/timezone &amp;&amp; \</span></span><br><span class="line"><span class="language-bash"> <span class="built_in">rm</span> -rf /tmp/* /var/cache/apk/*</span></span><br><span class="line"> <span class="keyword">RUN</span><span class="language-bash"> addgroup <span class="built_in">test</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    adduser -G <span class="built_in">test</span>  <span class="built_in">test</span> -D &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">mkdir</span> /test  &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">chown</span> -R <span class="built_in">test</span>:<span class="built_in">test</span>  /test</span></span><br><span class="line"><span class="keyword">USER</span> test</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /test</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ls</span> -al /</span></span><br></pre></td></tr></table></figure></li><li>执行build命令<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">docker build -t openjdk11_alpine .</span><br></pre></td></tr></table></figure></li><li>运行<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">run</span> -u test:test -<span class="keyword">it</span> <span class="comment">--name openjdk openjdk11_alpine</span></span><br></pre></td></tr></table></figure></li><li>查看java<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -<span class="built_in">version</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="/2022/08/21/Docker%E7%9F%A5/pasted-42.png" alt="java -version "></p><h1 id="查看docker容器信息"><a href="#查看docker容器信息" class="headerlink" title="查看docker容器信息"></a>查看docker容器信息</h1><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器<span class="built_in">id</span>/容器名字</span><br></pre></td></tr></table></figure><p><img src="/2022/08/21/Docker%E7%9F%A5/pasted-39.png" alt="docker inspect info"></p><h1 id="docker-cache信息"><a href="#docker-cache信息" class="headerlink" title="docker cache信息"></a>docker cache信息</h1><ul><li>查看<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system <span class="built_in">df</span></span><br></pre></td></tr></table></figure></li><li>删除</li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac技巧</title>
      <link href="/2022/08/21/Mac%E6%8A%80%E5%B7%A7/"/>
      <url>/2022/08/21/Mac%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="查看隐藏文件"><a href="#查看隐藏文件" class="headerlink" title="查看隐藏文件"></a>查看隐藏文件</h1><ul><li>1.点击左侧的访达图标。</li><li>2.在左侧菜单栏中点击房子图标的目录选项。</li><li>3.通过按快捷键 【shift cmmand 。】来让隐藏文件显示出来。</li><li>4.对文件进行查看。若是开头有个原点符号,即为隐藏文件。</li></ul><h1 id="mac安装Brew"><a href="#mac安装Brew" class="headerlink" title="mac安装Brew"></a>mac安装Brew</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/bin/</span>zsh -c <span class="string">&quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</span></span><br></pre></td></tr></table></figure><p>如下图安装<br><img src="/2022/08/21/Mac%E6%8A%80/pasted-1.png" alt="mac安装Brew"><br>安装成功：</p><p><img src="/2022/08/21/Mac%E6%8A%80/pasted-8.png" alt="brew安装成功"></p><ul><li>brew -v<br><img src="/2022/08/21/Mac%E6%8A%80/pasted-9.png" alt="brew -v"></li></ul><h1 id="多线程下载Axel"><a href="#多线程下载Axel" class="headerlink" title="多线程下载Axel"></a>多线程下载Axel</h1><p>axel linux下轻量级下载加速工具。</p><ul><li>安装<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>axel</span><br></pre></td></tr></table></figure></li><li>用法：</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">--max-speed</span>=x, -s x 指定最大下载速度。</span><br><span class="line"><span class="attr">--num-connections</span>=x, -n x指定链接的数量。</span><br><span class="line"><span class="attr">--output</span>=x, -o x 指定下载的文件在本地保存的名字。如果指定的参数是一个文件夹，则文件会下载到指定的文件夹下。</span><br><span class="line"><span class="attr">--search</span><span class="selector-attr">[=x]</span>, -S<span class="selector-attr">[x]</span>Axel将会使用文件搜索引擎来查找文件的镜像。缺省时用的是filesearching.com。可以指定使用多少个不同的镜像来下载文件。</span><br><span class="line">检测镜像将会花费一定的时间，因为程序会测试服务器的速度，以及文件存在与否。</span><br><span class="line"><span class="attr">--no-proxy</span>, -N不使用代理服务器来下载文件。当然此选项对于透明代理来说无意义。</span><br><span class="line"><span class="attr">--verbose</span>如果想得到更多的状态信息，可以使用这个参数。</span><br><span class="line"><span class="attr">--quiet</span>, -q不向标准输出平台(stdout)输入信息。</span><br><span class="line"><span class="attr">--alternate</span>, -a指定这个参数后将显示一个交替变化的进度条。它显示不同的线程的进度和状态，以及当前的速度和估计的剩余下载时间。</span><br><span class="line"><span class="attr">--header</span>=x, -H x添加HTTP头域，格式为“Header: Value”。</span><br><span class="line"><span class="attr">--user-agent</span>=x, -U x有些web服务器会根据不同的User-Agent返回不同的内容。这个参数就可以用来指定User-Agent头域。缺省时此头域值包括“Axel”，它的版本号以及平台信息。</span><br><span class="line"><span class="attr">--help</span>, -h返回参数的简要介绍信息。</span><br><span class="line"><span class="attr">--version</span>, -V 版本信息</span><br></pre></td></tr></table></figure><ul><li>例子<br>下载lnmp安装包指定10个线程，存到&#x2F;tmp&#x2F;：<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axel -n <span class="number">10</span> -o <span class="regexp">/tmp/</span> http:<span class="regexp">//</span>www.jsdig.com/lnmp.tar.gz</span><br></pre></td></tr></table></figure></li></ul><h1 id="Mac重新安装Node-Js"><a href="#Mac重新安装Node-Js" class="headerlink" title="Mac重新安装Node Js"></a>Mac重新安装Node Js</h1><p>Node.js 的生态就很奇怪，太散了，版本又多。所以决定用 homebrew 来管理 nvm，然后用 nvm 管理 node.js。</p><ul><li>删除NodeJs<br>删除 &#x2F;usr&#x2F;local&#x2F;lib 下的任意 node 和 node_modules 的文件或目录<br>删除 &#x2F;usr&#x2F;local&#x2F;include 下的任意 node 和 node_modules 的文件或目录<br>删除 Home 目录下的任意 node 和 node_modules 的文件或目录<br>删除 &#x2F;usr&#x2F;local&#x2F;bin 下的任意 node 的可执行文件<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf <span class="regexp">/opt/</span>local<span class="regexp">/bin/</span>node <span class="regexp">/opt/</span>local<span class="regexp">/include/</span>node <span class="regexp">/opt/</span>local<span class="regexp">/lib/</span>node_modules</span><br></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>npm <span class="regexp">/usr/</span>local<span class="regexp">/share/m</span>an<span class="regexp">/man1/</span>node.<span class="number">1</span> <span class="regexp">/usr/</span>local<span class="regexp">/lib/</span>dtrace/node.d</span><br></pre></td></tr></table></figure>执行完成测试：测试 nvm、node、npm 三个命令是否还在<br>1.安装 nvm，用 nvm 控制 Node.js 的版本</li><li>安装Nodejs<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brew install nvm</span><br><span class="line">``</span><br><span class="line">* 设置~/.bash_profile 中</span><br><span class="line">安装完成后，在 ~/.bash_profile 中添加以下内容，就可以在 bash 里面用 nvm 命令</span><br></pre></td></tr></table></figure></li></ul><p>#Node.js<br>source $(brew –prefix nvm)&#x2F;nvm.sh</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">* </span>更新 .bash<span class="emphasis">_profile 的缓存，使修改生效</span></span><br><span class="line"><span class="emphasis">``</span></span><br><span class="line"><span class="emphasis">source ~/.bash_</span>profile</span><br></pre></td></tr></table></figure><ul><li>通过 nvm 安装 Node.js<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install <span class="keyword">node</span><span class="title"></span></span><br></pre></td></tr></table></figure></li><li>安装完成后，查看是否安装成功<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm <span class="comment">--version</span></span><br></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nvm list</span></span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">node</span> <span class="title">-v</span></span><br></pre></td></tr></table></figure><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">npm</span> -v</span><br></pre></td></tr></table></figure></li><li>安装 cnpm，淘宝 NPM 镜像（方便网速不行的地区）<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https:<span class="regexp">//</span>registry.npm.taobao.org</span><br></pre></td></tr></table></figure>通过 brew 管理 nvm，再通过 nvm 管理 node。一个管一个，方便干净。</li></ul><h1 id="查看文件和文件夹大小"><a href="#查看文件和文件夹大小" class="headerlink" title="查看文件和文件夹大小"></a>查看文件和文件夹大小</h1><p>du可以查看文件及文件夹的大小。</p><ul><li>查看当前文件夹下文件和文件夹大小<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -sh *</span><br></pre></td></tr></table></figure></li><li>排序 &#x2F;&#x2F;统计当前目录大小 并安大小 排序<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -sm * | <span class="built_in">sort</span> -n</span><br></pre></td></tr></table></figure></li></ul><h1 id="每次重启终端都需要重新执行source-x2F-bash-profile"><a href="#每次重启终端都需要重新执行source-x2F-bash-profile" class="headerlink" title="每次重启终端都需要重新执行source .&#x2F;bash_profile"></a>每次重启终端都需要重新执行source .&#x2F;bash_profile</h1><p>Mac电脑配置完flutter环境变量后发现每次重启终端都需要重新执行source .&#x2F;bash_profile环境变量才能生效，检查发现是因为装了iTem2+zsh，导致每次加载的是 ~&#x2F;.zshrc文件，而 .zshrc文件中并没有定义环境变量。</p><p>解决：在.zshrc文件最后一行添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure><p>重新保存后再次重新打开终端即可。</p><h1 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h1><ul><li>Axel下载Docker<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axel -n <span class="number">10</span> https:<span class="regexp">//</span>desktop.docker.com<span class="regexp">/mac/</span>stable<span class="regexp">/amd64/</span><span class="number">64133</span>/Docker.dmg</span><br></pre></td></tr></table></figure></li><li>下载完成双击打开Docker ，如图所示 把docker复制至Applications目录</li></ul><p><img src="/2022/08/21/Mac%E6%8A%80/pasted-2.png" alt="安装docker"></p><ul><li>打开docker</li></ul><p><img src="/2022/08/21/Mac%E6%8A%80/pasted-3.png" alt="打开docker"></p><p><img src="/2022/08/21/Mac%E6%8A%80/pasted-5.png" alt="docker 提供图形化界面"></p><ul><li><p>打开 终端</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> <span class="literal">info</span></span><br></pre></td></tr></table></figure><p><img src="/2022/08/21/Mac%E6%8A%80/pasted-4.png" alt="docker info"></p></li><li><p>docker 镜像加速<br>打开docker 图形化设置找到 docker Engine 如下图所示添加 网易镜像加速地址，输入完成则点击Apply and Restart</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;http://hub-mirror.c.163.com&quot;</span>]</span><br></pre></td></tr></table></figure><p><img src="/2022/08/21/Mac%E6%8A%80/pasted-6.png" alt="图片/2022/08/21/Mac技/pasted-6.png"></p></li><li><p>docker run hello-world</p></li></ul><p><img src="/2022/08/21/Mac%E6%8A%80/pasted-7.png" alt="图片/2022/08/21/Mac技/pasted-7.png"></p><p> “registry-mirrors”: [“<a href="http://hub-mirror.c.163.com&quot;]">http://hub-mirror.c.163.com&quot;]</a></p><h1 id="如何解决Mac显示“您没有权限来打开应用-eclipse”的问题"><a href="#如何解决Mac显示“您没有权限来打开应用-eclipse”的问题" class="headerlink" title="如何解决Mac显示“您没有权限来打开应用 eclipse”的问题"></a>如何解决Mac显示“您没有权限来打开应用 eclipse”的问题</h1><p>  网上下载的最新版本Eclipse IDE for RCP and RAP Developers，今天在开启打开应用时报错您没有权限来打开应用 eclipse，请联系系统管理员来解决，<br> 打开terminal终端，输入以下命令，待执行完后，重新尝试打开应用即可：</p> <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codesign -f -s - --deep <span class="regexp">/Applications/</span>Eclipse.app</span><br></pre></td></tr></table></figure><h1 id="卸载mysql"><a href="#卸载mysql" class="headerlink" title="卸载mysql"></a>卸载mysql</h1><ul><li>关闭 MySQL，在系统偏好设置中点击 MySQL，然后点击 Stop MySQL Server</li></ul><p><img src="/2022/08/21/Mac%E6%8A%80/pasted-10.png" alt="设置"></p><p><img src="/2022/08/21/Mac%E6%8A%80/pasted-11.png" alt="mysql"></p><ul><li>执行命令 <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> sudo rm <span class="regexp">/usr/</span>local/mysql</span><br><span class="line">sudo rm -rf <span class="regexp">/usr/</span>local/mysql*</span><br><span class="line">sudo rm -rf <span class="regexp">/Library/</span>StartupItems/MySQLCOM</span><br><span class="line">sudo rm -rf <span class="regexp">/var/</span>db<span class="regexp">/receipts/</span>com.mysql.*</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA技巧</title>
      <link href="/2022/08/18/IDEA%E6%8A%80%E5%B7%A7/"/>
      <url>/2022/08/18/IDEA%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="idea-自动去掉无用的包"><a href="#idea-自动去掉无用的包" class="headerlink" title="idea 自动去掉无用的包"></a>idea 自动去掉无用的包</h1><p>第一步：打开IDEA –&gt; File –&gt; Setting</p><p>第二步：打开Editor –&gt;Gerneral–&gt; 点击Auto Import<br>图中方框内勾选即可<br><img src="/2022/08/18/IDEA%E6%8A%80/pasted-0.png" alt="idea 自动去掉无用的包"></p><h1 id="IDEA-右侧maven，ant等侧边栏消失如何恢复"><a href="#IDEA-右侧maven，ant等侧边栏消失如何恢复" class="headerlink" title="IDEA 右侧maven，ant等侧边栏消失如何恢复"></a>IDEA 右侧maven，ant等侧边栏消失如何恢复</h1><ul><li>点击view –&gt;tool windows–&gt;下拉找到自己想要添加到侧边栏的选项即可</li></ul><p><img src="/2022/08/18/IDEA%E6%8A%80/pasted-1.png" alt="添加侧边栏"></p><h1 id="Idea-出现-https-start-spring-io-出现-超时-x2F-错误-等等"><a href="#Idea-出现-https-start-spring-io-出现-超时-x2F-错误-等等" class="headerlink" title="Idea 出现 https://start.spring.io 出现 超时 &#x2F; 错误 等等"></a>Idea 出现 <a href="https://start.spring.io/">https://start.spring.io</a> 出现 超时 &#x2F; 错误 等等</h1><ul><li>新建Spring项目<br><img src="/2022/08/18/IDEA%E6%8A%80/pasted-2.png" alt="新建Spring项目"></li><li>出错</li></ul><p><img src="/2022/08/18/IDEA%E6%8A%80/pasted-3.png" alt="出错"></p><ul><li>将 <a href="https://start.spring.io/">https://start.spring.io</a> 改为: <a href="https://start.aliyun.com/">https://start.aliyun.com/</a></li></ul><p><img src="/2022/08/18/IDEA%E6%8A%80/pasted-4.png" alt="点击设置"><br><img src="/2022/08/18/IDEA%E6%8A%80/pasted-5.png" alt="修改为阿里云地址"><br><img src="/2022/08/18/IDEA%E6%8A%80/pasted-6.png" alt="出现Alibaba Spring Library"></p><h1 id="idea-去除所有未引用的包"><a href="#idea-去除所有未引用的包" class="headerlink" title="idea 去除所有未引用的包"></a>idea 去除所有未引用的包</h1><ul><li>去掉当前页面或类下直接快捷键Ctrl + Alt + O;</li></ul><h1 id="idea切换大小写快捷键"><a href="#idea切换大小写快捷键" class="headerlink" title="idea切换大小写快捷键"></a>idea切换大小写快捷键</h1><ul><li>快捷键:Ctrl+Shift+u 功能:转换标量的大小写效果</li></ul>]]></content>
      
      
      <categories>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eclipse 技巧</title>
      <link href="/2022/08/18/Eclipse-%E6%8A%80%E5%B7%A7/"/>
      <url>/2022/08/18/Eclipse-%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="Eclipse设置代码自动提示"><a href="#Eclipse设置代码自动提示" class="headerlink" title="Eclipse设置代码自动提示"></a>Eclipse设置代码自动提示</h1><ul><li><p>第一步：打开Eclipse –&gt; Window –&gt; Preferences</p></li><li><p>第二步：点击Java –&gt; 打开Editor –&gt; 点击Content Assist</p></li><li><p>第三步：设置Auto activition triggers for Java 的值为 .abcdefghijklmnopqrstuvwxyz (记得别忘记那个小数点了 不然打个小数点没提示) 然后点击Apply保存配置即可。<br>注：有的版本要区分大小写 ：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="/2022/08/18/Eclipse-%E6%8A%80/pasted-0.png" alt="Eclipse设置代码自动提示"></p>]]></content>
      
      
      <categories>
          
          <category> Eclipse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Eclipse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql绿色版安装</title>
      <link href="/2022/08/16/mysql%E7%BB%BF%E8%89%B2%E7%89%88%E5%AE%89%E8%A3%85/"/>
      <url>/2022/08/16/mysql%E7%BB%BF%E8%89%B2%E7%89%88%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="下载mysql"><a href="#下载mysql" class="headerlink" title="下载mysql"></a>下载mysql</h1><p><a href="https://www.mysql.com/">https://www.mysql.com/</a>,<br>版本：5.7.32</p><ul><li><p>安装服务</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld <span class="attr">--install</span> <span class="built_in">mysql</span>(服务名称)</span><br></pre></td></tr></table></figure></li><li><p>删除服务</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld <span class="attr">--remove</span> <span class="built_in">mysql</span>(服务名称)</span><br></pre></td></tr></table></figure></li><li><p>初始化mysql：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">mysqld</span> <span class="literal">--</span><span class="comment">initialize</span> <span class="literal">--</span><span class="comment">console</span></span><br></pre></td></tr></table></figure><p>会打印root 密码</p></li><li><p>启动服务</p></li><li><p>登录mysql,使用登录密码为上面初始化mysql是自动生成的初始密码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -<span class="selector-tag">p</span></span><br></pre></td></tr></table></figure></li><li><p>修改密码：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>退出服务，重新用新密码登录</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> Mysql 绿色版安装 </tag>
            
            <tag> Mysql修改root密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql重置root密码</title>
      <link href="/2022/08/16/%E5%85%B3%E4%BA%8Emysql/"/>
      <url>/2022/08/16/%E5%85%B3%E4%BA%8Emysql/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql-重置root密码"><a href="#mysql-重置root密码" class="headerlink" title="mysql 重置root密码"></a>mysql 重置root密码</h1><p>如果不小心忘记了mysql的root密码？可以通过如下步骤进行重置。</p><ul><li><p>停止 mysql 服务<br>打开系统偏好设置 ——&gt; MySQL ——&gt; Stop MySQL Server</p></li><li><p>跳过授权验证 打开终端，输入 </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld_safe <span class="comment">--skip-grant-tables ，</span></span><br></pre></td></tr></table></figure><p>以此来跳过授权验证。</p></li><li><p>无密码登陆mysql，重置root密码 重新打开一个终端，然后输入</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mysql -uroot</span></span><br></pre></td></tr></table></figure><p>直接登陆（无需密码）。</p></li><li><p>登录成功后重置root密码，依次输入：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use mysql<span class="comment">;</span></span><br></pre></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> authentication_string=<span class="keyword">password</span>(<span class="string">&#x27;root&#x27;</span>) <span class="keyword">where</span> <span class="keyword">user</span>=<span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p>第六步 关闭mysqld_safe 客户端窗口 </p></li><li><p>启动mysql服务</p></li><li><p>用密码登录mysql</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -<span class="selector-tag">p</span></span><br></pre></td></tr></table></figure></li><li><p>重置root 密码</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">PASSWORD</span> <span class="keyword">FOR</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> = <span class="keyword">PASSWORD</span>(<span class="string">&#x27;newpass&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>建立一个具有所有权限并且可以远程连接的用户</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;root&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>;</span><br></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;172.16.%.%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;redhat&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges<span class="comment">;</span></span><br></pre></td></tr></table></figure></li></ul><p>补充：Mac中MySQL的默认安装位置：&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> mysql重置root密码 </tag>
            
            <tag> Mysql修改Root密码 </tag>
            
            <tag> Mysql 开启用户远程访问 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Admin</title>
      <link href="/2022/08/10/Hexo-Admin/"/>
      <url>/2022/08/10/Hexo-Admin/</url>
      
        <content type="html"><![CDATA[<p>使用Hexo 写博客 并使用gitHub page 发布互联网，所以Hexo 是个好东西。<br>以下分享就是使用Hexo Admin 主要解决写文章复制粘贴图片问题</p><h1 id="Hexo-Admin"><a href="#Hexo-Admin" class="headerlink" title="Hexo Admin"></a>Hexo Admin</h1><ul><li>安装Hexo -admin<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install --<span class="keyword">save</span> <span class="keyword">save</span> hexo-admin</span><br></pre></td></tr></table></figure></li><li>安装完成 下载<a href="/download/hexo-admin.7z">补丁</a> （目前是hexo-admin 版本是2.3.0）<br><img src="/2022/08/10/Hexo-Admi/pasted-0.png" alt="以下文件"><br>补丁主要解决：<ul><li>粘贴上传图片路径显示问题</li><li>汉化</li><li>添加按文章存储图片功能（方便管理）<br>原本系统默认将图片统一存储在“images”目录下，文章一多，图片数量疯涨，就不容易维护，所以我添加了按文章存储图片的功能，图片将存储在与文章同目录的同名文件夹下。<br><img src="/2022/08/10/Hexo-Admi/pasted-2.png" alt="按文章存储图片"><br>只需要在设置界面，勾选“图片存储在资源目录下”选项即可</li></ul></li></ul><p><img src="/2022/08/10/Hexo-Admi/pasted-1.png" alt="图片存储在资源目录下"></p><ul><li>解压完成后把里面文件复制至node_modules\hexo-admin</li><li>使用Hexo s -d命令进行启动</li></ul><p><img src="/2022/08/10/Hexo-Admi/pasted-3.png" alt="Hexo admin 界面"></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Hexo admin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-小功能</title>
      <link href="/2022/08/09/Hexo-%E5%B0%8F%E5%8A%9F%E8%83%BD/"/>
      <url>/2022/08/09/Hexo-%E5%B0%8F%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>Hexo 小功能分享</p><h1 id="站内搜索"><a href="#站内搜索" class="headerlink" title="站内搜索"></a>站内搜索</h1><ul><li>安装插件：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install hexo<span class="operator">-</span>generator<span class="operator">-</span><span class="keyword">search</span> <span class="comment">--save</span></span><br></pre></td></tr></table></figure></li><li>在站点根 _config.yml 里头添加设置项：<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.<span class="keyword">xml</span></span><br><span class="line">  <span class="title">field</span>: post</span><br></pre></td></tr></table></figure></li><li>编辑 Hexo 主题配置文件maupassant&#x2F;_config.yml，添加以下配置<figure class="highlight mercury"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self_search: <span class="built_in">true</span> ## Use a jQuery-based <span class="meta">local</span> search engine, <span class="built_in">true</span>/<span class="built_in">false</span>.</span><br></pre></td></tr></table></figure></li><li>再次启动hexo<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成文件</span></span><br><span class="line"><span class="attribute">hexo</span> g</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>效果<br><img src="/2022/08/09/Hexo-%E5%B0%8F%E5%8A%9F/pasted-0.png" alt="站内搜索效果"></li></ul><h1 id="百度统计"><a href="#百度统计" class="headerlink" title="百度统计"></a>百度统计</h1><ul><li>直接在百度统计网站上建立一个网站 获取uid<br><a href="https://tongji.baidu.com/web5/10000252043/welcome/login">https://tongji.baidu.com/web5/10000252043/welcome/login</a></li><li>编辑 Hexo 主题配置文件maupassant&#x2F;_config.yml，添加以下配置<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">baidu_analytics:</span> </span><br></pre></td></tr></table></figure></li></ul><h1 id="google统计"><a href="#google统计" class="headerlink" title="google统计"></a>google统计</h1><ul><li>直接在google统计网站上建立一个网站 获取uid<br><a href="https://analytics.google.com/analytics/web/#/">https://analytics.google.com/analytics/web/#/</a><br>*��站上建立一个网站 获取uid<br><a href="https://analytics.google.com/analytics/web/#/">https://analytics.google.com/analytics/web/#/</a></li><li>编辑 Hexo 主题配置文件maupassant&#x2F;_config.yml，添加以下配置<figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">google_analytics</span>: <span class="comment">## Your Google Analytics tracking id, e.g. UA-42425684-2</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="中文显示"><a href="#中文显示" class="headerlink" title="中文显示"></a>中文显示</h1><p>编辑站内目录下 _config.yml，添加以下配置</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">title:</span> perter blog</span><br><span class="line"><span class="symbol">subtitle:</span> perter的技术分享</span><br><span class="line"><span class="symbol">description:</span> perter的技术分享</span><br><span class="line"><span class="symbol">keywords:</span></span><br><span class="line"><span class="symbol">author:</span> Peter tan</span><br><span class="line"><span class="symbol">language:</span> <span class="built_in">zh</span>-CN</span><br><span class="line"><span class="symbol">timezone:</span> Asia/Shanghai</span><br></pre></td></tr></table></figure><h1 id="菜单配置"><a href="#菜单配置" class="headerlink" title="菜单配置"></a>菜单配置</h1><p>编辑 Hexo 主题配置文件maupassant&#x2F;_config.yml，添加以下配置</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  - page: home</span><br><span class="line">    directory: .</span><br><span class="line">    <span class="attribute">icon</span>: fa-home</span><br><span class="line">  - <span class="attribute">page</span>: archive</span><br><span class="line">    <span class="attribute">directory</span>: archives/</span><br><span class="line">    <span class="attribute">icon</span>: fa-archive</span><br><span class="line"><span class="attribute">info</span>:</span><br><span class="line">  <span class="attribute">avatar</span>: /img/head.jpg</span><br><span class="line">  <span class="attribute">discription</span>: 我喜欢计算编程,专注后端开发 性能调优 spring 框架</span><br><span class="line">  <span class="attribute">outlinkitem</span>:</span><br><span class="line">#    - <span class="attribute">name</span>: twitter</span><br><span class="line">#      <span class="attribute">outlink</span>: <span class="attribute">https</span>:<span class="comment">//twitter.com/username</span></span><br><span class="line">#      <span class="attribute">message</span>: Twitter</span><br><span class="line">    - <span class="attribute">name</span>: envelope</span><br><span class="line">      <span class="attribute">outlink</span>: <span class="attribute">mailto</span>:beityw<span class="variable">@hotmail</span>.com</span><br><span class="line">      <span class="attribute">message</span>: Email</span><br><span class="line">    - <span class="attribute">name</span>: github</span><br><span class="line">      <span class="attribute">outlink</span>: <span class="attribute">https</span>:<span class="comment">//github.com/peterTanBlog/</span></span><br><span class="line">      <span class="attribute">message</span>: Github</span><br><span class="line">#    - <span class="attribute">name</span>: rss</span><br><span class="line">#      <span class="attribute">outlink</span>: /atom.xml</span><br><span class="line">#      <span class="attribute">message</span>: RSS</span><br><span class="line"></span><br><span class="line"><span class="attribute">links</span>:</span><br><span class="line">  - <span class="attribute">title</span>: 我的博客</span><br><span class="line">    <span class="attribute">url</span>: <span class="attribute">https</span>:<span class="comment">//smallwenzi.github.io</span></span><br><span class="line">    <span class="attribute">src</span>: <span class="attribute">https</span>:<span class="comment">//smallwenzi.github.io/img/head.jpg</span></span><br><span class="line">    <span class="attribute">desc</span>: 我的博客    </span><br><span class="line">    </span><br></pre></td></tr></table></figure><h1 id="百度和google收录网站"><a href="#百度和google收录网站" class="headerlink" title="百度和google收录网站"></a>百度和google收录网站</h1><ul><li>安装插件</li></ul><p>hexo-generator-sitemap 【该包用于支持Google搜索引擎】</p><p>hexo-generator-baidu-sitemap 【该包用于支持百度搜索引擎】</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cnpm <span class="keyword">install </span>hexo-generator-sitemap --save</span><br><span class="line">cnpm <span class="keyword">install </span>hexo-generator-<span class="keyword">baidu-sitemap </span>--save</span><br></pre></td></tr></table></figure><ul><li>编辑站内目录下 _config.yml，添加以下配置<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">sitemap:</span></span><br><span class="line"><span class="symbol"> path:</span> sitemap.xml</span><br><span class="line"><span class="symbol">baidusitemap:</span></span><br><span class="line"><span class="symbol"> path:</span> baidusitemap.xml</span><br></pre></td></tr></table></figure></li><li>执行hexo g和hexo d进行发布网站</li></ul><h2 id="google-收录网站"><a href="#google-收录网站" class="headerlink" title="google 收录网站"></a>google 收录网站</h2><ul><li>打开<a href="https://search.google.com/search-console/welcome?hl=zh-CN&utm_source=wmx&utm_medium=deprecation-pane&utm_content=home">google search console</a>, 并添加需要抓取的域名，并把googlexxx.html文件放在网站根目录 如下图<br><img src="/2022/08/09/Hexo-%E5%B0%8F%E5%8A%9F/pasted-1.png" alt="google search console"><br>输入自己博客地址 然后点击验证按钮，成功则返回下图：<br><img src="/2022/08/09/Hexo-%E5%B0%8F%E5%8A%9F/pasted-2.png" alt="完成验证"></li><li>点击上图前往资源页面，或通过<a href="https://search.google.com/search-console/sitemaps?resource_id=https://petertanblog.github.io/">link</a>进入，并提交你的sitemap.xml<br><img src="/2022/08/09/Hexo-%E5%B0%8F%E5%8A%9F/pasted-3.png" alt="输入sitemap.xml"><br><img src="/2022/08/09/Hexo-%E5%B0%8F%E5%8A%9F/pasted-4.png" alt="提交站点"></li></ul><h2 id="百度收录网站"><a href="#百度收录网站" class="headerlink" title="百度收录网站"></a>百度收录网站</h2><ul><li>建立站点管理，打开<a href="https://ziyuan.baidu.com/site/index#/">link</a>, 并填写你的域名<br><img src="/2022/08/09/Hexo-%E5%B0%8F%E5%8A%9F/pasted-5.png" alt="填写你的域名"></li><li>勾选对应站点属性<br><img src="/2022/08/09/Hexo-%E5%B0%8F%E5%8A%9F/pasted-6.png" alt="勾选对应站点属性"></li><li>下载认证文件，并放在网站根&#x2F;source目录<br><img src="/2022/08/09/Hexo-%E5%B0%8F%E5%8A%9F/pasted-7.png" alt="验证站点"></li></ul><p>source 目录下验证文件，hexo g运行后就会复制文件至public 目录：</p><p><img src="/2022/08/09/Hexo-%E5%B0%8F%E5%8A%9F/pasted-14.png" alt="source目录"></p><ul><li>执行hexo g和hexo d进行发布网站 后进行 上图点击这里确认验证文件可以正常访问–&gt;点击完成验证</li></ul><h2 id="新链接由我们主动推送给百度"><a href="#新链接由我们主动推送给百度" class="headerlink" title="新链接由我们主动推送给百度"></a>新链接由我们主动推送给百度</h2><ul><li><p>在<a href="https://ziyuan.baidu.com/site/index#/">站点管理</a> 点击刚才添加的网站<br><img src="/2022/08/09/Hexo-%E5%B0%8F%E5%8A%9F/pasted-8.png" alt="站点管理"></p></li><li><p>点击菜单：资源提交–&gt;普通收录，我们就看到token<br><img src="/2022/08/09/Hexo-%E5%B0%8F%E5%8A%9F/pasted-10.png" alt="普通收录"></p></li><li><p>安装插件：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm <span class="keyword">install </span>hexo-<span class="keyword">baidu-url-submit </span>--save</span><br></pre></td></tr></table></figure></li><li><p>编辑站内目录下 _config.yml，添加以下配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">baidu_url_submit:</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">100</span> <span class="comment"># 提交最新的一个链接</span></span><br><span class="line">  <span class="attr">host:</span>  <span class="comment"># 在百度站长平台中注册的域名</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">第二步获取的token</span> <span class="comment"># 请注意这是您的秘钥，所以请不要把博客源代码发布在公众仓库里!</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidu_urls.txt</span> <span class="comment"># 文本文档的地址，新链接会保存在此文本文档里</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">   <span class="attr">repository:</span> <span class="string">xxx</span></span><br><span class="line">   <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">baidu_url_submitter</span> </span><br></pre></td></tr></table></figure></li><li><p>执行hexo g和hexo d进行发布网站 就会看到<br>新的链接就会主动推送给百度，然后百度就会更快地派爬虫来发现你站点中的新链接，可以在第一时间收录新建的链接。</p></li></ul><p><img src="/2022/08/09/Hexo-%E5%B0%8F%E5%8A%9F/pasted-9.png" alt="推送"></p><h1 id="主题配置文件"><a href="#主题配置文件" class="headerlink" title="主题配置文件"></a>主题配置文件</h1><ul><li>将maupassant 下_config.yml 复制副本并命名为_config.maupassant.yml，最后把文件copy 至hexo目录下<br><img src="/2022/08/09/Hexo-%E5%B0%8F%E5%8A%9F/pasted-11.png" alt="_config.maupassant.yml"></li></ul><h1 id="开启文章目录"><a href="#开启文章目录" class="headerlink" title="开启文章目录"></a>开启文章目录</h1><ul><li>打开站内目录_config.yml 添加metadata 设置toc参数<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">toc:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li>运行hexo s -d 访问<a href="http://localhost:4000/admin/">http://localhost:4000/admin/</a> 这样就能后台设置toc参数</li></ul><p><img src="/2022/08/09/Hexo-%E5%B0%8F%E5%8A%9F/pasted-12.png" alt="后台设置toc参数"><br>页面显示目录效果：<br><img src="/2022/08/09/Hexo-%E5%B0%8F%E5%8A%9F/pasted-13.png" alt="页面显示目录效果"></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> hexo 站内搜索 </tag>
            
            <tag> hexo 百度统计 </tag>
            
            <tag> hexo google统计 </tag>
            
            <tag> 百度收录hexo博客 </tag>
            
            <tag> google收录hexo 博客 </tag>
            
            <tag> maupassant 主题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo添加评论插件</title>
      <link href="/2022/08/09/Hexo%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8F%82%E5%8A%A0/"/>
      <url>/2022/08/09/Hexo%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8F%82%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<p>utterances 是一个基于 Github issues 构建的轻量级评论插件。使用 Github 账号登录后才能评论。</p><h1 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h1><ul><li>关于maupassant主题：<br><a href="https://github.com/tufu9441/maupassant-hexo">https://github.com/tufu9441/maupassant-hexo</a></li><li>在hexo目录下 git bash命令框执行<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github<span class="selector-class">.com</span>:tufu9441/maupassant-hexo<span class="selector-class">.git</span> themes/maupassant</span><br><span class="line">cnpm install hexo-renderer-pug <span class="attr">--save</span></span><br><span class="line">cnpm install hexo-renderer-sass <span class="attr">--save</span></span><br></pre></td></tr></table></figure></li><li>编辑hexo 目录下_config.yml 修改主题<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">theme:</span> maupassant</span><br></pre></td></tr></table></figure></li><li>在hexo目录下 git bash命令框启动<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo s</span></span><br></pre></td></tr></table></figure>效果<br><img src="/2022/08/09/Hexo%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8F%82/pasted-1.png" alt="效果"></li></ul><h1 id="配置-Github-仓库"><a href="#配置-Github-仓库" class="headerlink" title="配置 Github 仓库"></a>配置 Github 仓库</h1><p>由于是基于 Github issues，我们需要一个仓库来存储评论， 所以我们需要在 Github 上创建一个空库，并且必须是 pulbic 的，这样用户才可以查看并发布评论。</p><p><img src="/2022/08/09/Hexo%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8F%82/pasted-2.png" alt="Github 仓库"></p><h1 id="安装-Github-App"><a href="#安装-Github-App" class="headerlink" title="安装 Github App"></a>安装 Github App</h1><p>安装地址：<a href="https://github.com/apps/utterances">https://github.com/apps/utterances</a></p><p>访问安装地址，进入安装页面，单击 Install 按钮；<br><img src="/2022/08/09/Hexo%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8F%82/pasted-3.png" alt="utterances"></p><p>选择关联的仓库，我们选择刚刚建好的仓库；<br><img src="/2022/08/09/Hexo%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8F%82/pasted-4.png" alt="选择刚刚建好的仓库"><br>至此，Github 端配置完成，接下来在网页或博客中配置使用 utterances。</p><h1 id="使用-utterances"><a href="#使用-utterances" class="headerlink" title="使用 utterances"></a>使用 utterances</h1><ul><li>编辑 Hexo 主题配置文件maupassant&#x2F;_config.yml，添加以下配置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">utterances:</span> <span class="comment">## See: https://utteranc.es</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">## If you want to use Utterances comment system, please set the value to true.</span></span><br><span class="line">  <span class="attr">repo:</span>  <span class="comment">## The repository utterances will connect to, e.g. tufu9441/comments</span></span><br><span class="line">  <span class="attr">identifier:</span> <span class="string">title</span> <span class="comment">## The mapping between blog posts and GitHub issues.</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">github-light</span> <span class="comment">## Choose an Utterances theme which matches your blog.</span></span><br></pre></td></tr></table></figure></li><li>再次启动hexo<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo s</span></span><br></pre></td></tr></table></figure>效果</li></ul><p><img src="/2022/08/09/Hexo%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8F%82/pasted-5.png" alt="评论"></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> maupassant 主题 </tag>
            
            <tag> utterances 评论插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 搭建博客</title>
      <link href="/2022/08/08/Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/08/08/Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>这是一篇很详尽的独立博客搭建教程 里面以windows 为例 介绍了github、Hexo和hexo-admin设置等过程</p><h1 id="系统环境配置"><a href="#系统环境配置" class="headerlink" title="系统环境配置"></a>系统环境配置</h1><p>要使用Hexo，需要在你的系统中支持Nodejs以及Git，如果还没有，那就开始安装吧！</p><h2 id="安装Node-Js"><a href="#安装Node-Js" class="headerlink" title="安装Node Js"></a>安装Node Js</h2><p> 下载NodeJs:<a href="https://nodejs.org/download/release/v14.20.0/">NodeJs 14.20</a></p><p> 安装Nodejs:<a href="https://www.runoob.com/nodejs/nodejs-install-setup.html">教程</a></p><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>下载地址：<a href="https://git-scm.com/download/">git</a></p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><ul><li><p>git bash 命令框安装淘宝镜像</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https:<span class="regexp">//</span>registry.npm.taobao.org </span><br></pre></td></tr></table></figure></li><li><p>git bash 命令框安装Hexo</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-<span class="keyword">cli</span> </span><br></pre></td></tr></table></figure></li><li><p>git bash 命令框查看版本</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo -v</span></span><br></pre></td></tr></table></figure><p><img src="/2022/08/08/Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A/pasted-1.png" alt="hexo-v"></p></li><li><p>git bash 命令框初始化</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">init</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="/2022/08/08/Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A/pasted-2.png" alt="hexo -init"><br>文件夹下就会有以下文件<br><img src="/2022/08/08/Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A/pasted-3.png" alt="文件夹图"></p><ul><li>git bash 命令框启动 hexo 并访问<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo s</span></span><br></pre></td></tr></table></figure><img src="/2022/08/08/Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A/pasted-4.png" alt="访问"><br>打开<a href="http://localhost:4000/">http://localhost:4000/</a>, 看到如下, 成功</li></ul><p><img src="/2022/08/08/Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A/pasted-5.png" alt="页面"></p><h1 id="Github-Pages设置"><a href="#Github-Pages设置" class="headerlink" title="Github Pages设置"></a>Github Pages设置</h1><ul><li><p>注册Github并创建一个仓库<br>注册很简单, 假设已经注册<br>创建一个新的仓库,仓库名为perteTanBlog.github.io,其他的可以不勾选,仓库是公共仓库<br><img src="/2022/08/08/Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A/pasted-6.png" alt="创建仓库"></p></li><li><p>生成SSH Keys ：在git bash执行</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> ssh-keygen -t rsa -C <span class="string">&quot;邮件地址&quot;</span> <span class="regexp">//</span>这个邮件地址是你注册github时绑定的</span><br><span class="line">然后<span class="number">4</span>个回车,如果文件存在让你覆盖你就ok就行</span><br></pre></td></tr></table></figure></li><li><p>git bash 命令框查看ssh key:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~<span class="regexp">/.ssh/i</span>d_rsa.pub</span><br></pre></td></tr></table></figure></li><li><p>打开Github,添加新的SSH Key<br><img src="/2022/08/08/Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A/pasted-7.png" alt="找到SSH and GPG key"><br><img src="/2022/08/08/Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A/pasted-8.png" alt="添加SSH key"></p></li><li><p>git bash 输入: ssh -T <a href="mailto:&#103;&#105;&#x74;&#x40;&#103;&#105;&#116;&#104;&#117;&#x62;&#x2e;&#99;&#x6f;&#109;">&#103;&#105;&#x74;&#x40;&#103;&#105;&#116;&#104;&#117;&#x62;&#x2e;&#99;&#x6f;&#109;</a>, 出现如下图所示, 添加成功(如果有让你输入的,你就yes就行)<br><img src="/2022/08/08/Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A/pasted-9.png" alt="git bash"></p></li></ul><h1 id="发布博客至互联网"><a href="#发布博客至互联网" class="headerlink" title="发布博客至互联网"></a>发布博客至互联网</h1><ul><li>打开博客所在文件夹下,打开_config.yml<br><img src="/2022/08/08/Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A/pasted-10.png" alt="_config.yml"></li><li>拉到最后, 替换以下内容<br><img src="/2022/08/08/Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A/pasted-11.png" alt="_config.yml"></li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">deploy:</span></span><br><span class="line"><span class="symbol">  type:</span> git</span><br><span class="line"><span class="symbol">  repository:</span> git ssh地址</span><br><span class="line"><span class="symbol">  branch:</span> master</span><br></pre></td></tr></table></figure><ul><li>安装hexo-deployer-git自动部署发布工具<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install hexo-deployer-git <span class="comment">--save</span></span><br></pre></td></tr></table></figure></li><li>git bash 命令框执行hexo g命令生成页面 <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo g</span></span><br></pre></td></tr></table></figure></li><li>上传页面到Github<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo d</span></span><br></pre></td></tr></table></figure>此时访问<a href="https://username.github.io就可以访问你的博客啦/">https://username.github.io就可以访问你的博客啦</a></li></ul><h1 id="hexo-常用命令"><a href="#hexo-常用命令" class="headerlink" title="hexo 常用命令"></a>hexo 常用命令</h1><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="string">&quot;name&quot;</span>       <span class="meta"># 新建文章</span></span><br><span class="line">hexo <span class="keyword">new</span> page <span class="string">&quot;name&quot;</span>  <span class="meta"># 新建页面</span></span><br><span class="line">hexo g                <span class="meta"># 生成页面</span></span><br><span class="line">hexo d                <span class="meta"># 部署</span></span><br><span class="line">hexo g -d             <span class="meta"># 生成页面并部署</span></span><br><span class="line">hexo s                <span class="meta"># 本地预览</span></span><br><span class="line">hexo clean            <span class="meta"># 清除缓存和已生成的静态文件</span></span><br><span class="line">hexo help             <span class="meta"># 帮助</span></span><br></pre></td></tr></table></figure><h1 id="注意事项（避雷）"><a href="#注意事项（避雷）" class="headerlink" title="注意事项（避雷）"></a>注意事项（避雷）</h1><ul><li>要注意浏览器自动缓存问题，在第一次输入后，如果不清除缓存，就算做了更改，浏览器还是会用上一次的DNS解析结果尽管这可能是错误的，所以如果更改设置后还是和原来一样的错误结果，可以试试清除浏览器缓存</li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
