<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<link rel="stylesheet" type="text/css" href="file:///D:/soft_setup/nyfedit7pro/scripts/highlight.styles/default.css" />
		<style>
			body, table{font-family: 微软雅黑; font-size: 18pt}
			
			table{border-collapse: collapse; border: 1px solid gray; border-width: 2px 1px 2px 1px;}
			th{border: 1px solid gray; padding: 4px; background-color: #ddd;}
			td{border: 1px solid gray; padding: 4px;}
			tr:nth-child(2n){background-color: #f8f8f8;}
			pre{border: 2px solid #d6d6d6; padding: 0px; border-radius: 3px;}
		</style>
	
<link rel="stylesheet" type="text/css" href="1817fd6e_11c10399_0.css">
</head>
	<body>
		<div>
			<div>
				<div>
					<div>
						<div><br />
						</div>
						<pre>
<code id="ID_17370E44968" class="hljs processing"><ol><li><span class="hljs-keyword">public</span> class <span class="hljs-keyword">HashMap</span>&lt;K,V&gt;</li><li>    extends AbstractMap&lt;K,V&gt; <span class="hljs-comment">//【1】继承的AbstractMap中，已经实现了Map接口</span></li><li>        <span class="hljs-comment">//【2】又实现了这个接口，多余，但是设计者觉得没有必要删除，就这么地了</span></li><li>    implements Map&lt;K,V&gt;, Cloneable, Serializable{</li><li>                </li><li>                </li><li>        <span class="hljs-comment">//【3】后续会用到的重要属性：先粘贴过来：</span></li><li>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">16</span>;<span class="hljs-comment">//哈希表主数组的默认长度</span></li><li>        <span class="hljs-comment">//定义了一个float类型的变量，以后作为：默认的装填因子，加载因子是表示Hsah表中元素的填满的程度</span></li><li>        <span class="hljs-comment">//太大容易引起哈西冲突，太小容易浪费  0.75是经过大量运算后得到的最好值</span></li><li>        <span class="hljs-comment">//这个值其实可以自己改，但是不建议改，因为这个0.75是大量运算得到的</span></li><li>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75</span>f;</li><li>        <span class="hljs-keyword">transient</span> Entry&lt;K,V&gt;[] table;<span class="hljs-comment">//主数组,每个元素为Entry类型</span></li><li>        <span class="hljs-keyword">transient</span> <span class="hljs-built_in">int</span> <span class="hljs-built_in">size</span>;</li><li>        <span class="hljs-built_in">int</span> threshold;<span class="hljs-comment">//数组扩容的界限值,门槛值   16*0.75=12 </span></li><li>        <span class="hljs-keyword">final</span> <span class="hljs-built_in">float</span> loadFactor;<span class="hljs-comment">//用来接收装填因子的变量</span></li><li>        </li><li>        <span class="hljs-comment">//【4】查看构造器：内部相当于：this(16,0.75f);调用了当前类中的带参构造器</span></li><li>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">HashMap</span>() {</li><li>        <span class="hljs-keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</li><li>    }</li><li>        <span class="hljs-comment">//【5】本类中带参数构造器：--》作用给一些数值进行初始化的！</span></li><li>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">HashMap</span>(<span class="hljs-built_in">int</span> initialCapacity, <span class="hljs-built_in">float</span> loadFactor) {</li><li></li><li>        <span class="hljs-comment">//【6】给capacity赋值，capacity的值一定是 大于你传进来的initialCapacity 的 最小的 2的倍数</span></li><li>        <span class="hljs-built_in">int</span> capacity = <span class="hljs-number">1</span>;</li><li>        <span class="hljs-keyword">while</span> (capacity &lt; initialCapacity)</li><li>            capacity &lt;&lt;= <span class="hljs-number">1</span>;</li><li></li><li>                <span class="hljs-comment">//【7】给loadFactor赋值，将装填因子0.75赋值给loadFactor</span></li><li>        <span class="hljs-keyword">this</span>.loadFactor = loadFactor;</li><li>                <span class="hljs-comment">//【8】数组扩容的界限值,门槛值</span></li><li>        threshold = (<span class="hljs-built_in">int</span>)Math.<span class="hljs-built_in">min</span>(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="hljs-number">1</span>);</li><li>                </li><li>                <span class="hljs-comment">//【9】给table数组赋值，初始化数组长度为16</span></li><li>        table = <span class="hljs-keyword">new</span> Entry[capacity];</li><li>                   </li><li>    }</li><li>        <span class="hljs-comment">//【10】调用put方法：</span></li><li>        <span class="hljs-keyword">public</span> V put(K <span class="hljs-built_in">key</span>, V value) {</li><li>                <span class="hljs-comment">//【11】对空值的判断</span></li><li>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">key</span> == <span class="hljs-keyword">null</span>)</li><li>            <span class="hljs-keyword">return</span> putForNullKey(value);</li><li>                <span class="hljs-comment">//【12】调用hash方法，获取哈希码</span></li><li>        <span class="hljs-built_in">int</span> hash = hash(<span class="hljs-built_in">key</span>);</li><li>                <span class="hljs-comment">//【14】得到key对应在数组中的位置</span></li><li>        <span class="hljs-built_in">int</span> i = indexFor(hash, table.length);</li><li>                <span class="hljs-comment">//【16】如果你放入的元素，在主数组那个位置上没有值，e==null  那么下面这个循环不走</span></li><li>                <span class="hljs-comment">//当在同一个位置上放入元素的时候</span></li><li>        <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="hljs-keyword">null</span>; e = e.next) {</li><li>            <span class="hljs-keyword">Object</span> k;</li><li>                        <span class="hljs-comment">//哈希值一样  并且  equals相比一样   </span></li><li>                        <span class="hljs-comment">//(k = e.key) == key  如果是一个对象就不用比较equals了</span></li><li>            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.<span class="hljs-built_in">key</span>) == <span class="hljs-built_in">key</span> || <span class="hljs-built_in">key</span>.equals(k))) {</li><li>                V oldValue = e.value;</li><li>                e.value = value;</li><li>                e.recordAccess(<span class="hljs-keyword">this</span>);</li><li>                <span class="hljs-keyword">return</span> oldValue;</li><li>            }</li><li>        }</li><li></li><li>        modCount++;</li><li>                <span class="hljs-comment">//【17】走addEntry添加这个节点的方法：</span></li><li>        addEntry(hash, <span class="hljs-built_in">key</span>, value, i);</li><li>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</li><li>    }</li><li>        </li><li>        <span class="hljs-comment">//【13】hash方法返回这个key对应的哈希值，内部进行二次散列，为了尽量保证不同的key得到不同的哈希码！</span></li><li>        <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> hash(<span class="hljs-keyword">Object</span> k) {</li><li>        <span class="hljs-built_in">int</span> h = <span class="hljs-number">0</span>;</li><li>        <span class="hljs-keyword">if</span> (useAltHashing) {</li><li>            <span class="hljs-keyword">if</span> (k <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">String</span>) {</li><li>                <span class="hljs-keyword">return</span> sun.misc.Hashing.stringHash32((<span class="hljs-keyword">String</span>) k);</li><li>            }</li><li>            h = hashSeed;</li><li>        }</li><li>                <span class="hljs-comment">//k.hashCode()函数调用的是key键值类型自带的哈希函数，</span></li><li>                <span class="hljs-comment">//由于不同的对象其hashCode()有可能相同，所以需对hashCode()再次哈希，以降低相同率。</span></li><li>        h ^= k.hashCode();</li><li></li><li>        <span class="hljs-comment">// This function ensures that hashCodes that differ only by</span></li><li>        <span class="hljs-comment">// constant multiples at each bit position have a bounded</span></li><li>        <span class="hljs-comment">// number of collisions (approximately 8 at default load factor).</span></li><li>                <span class="hljs-comment">/*</span></li><li>                接下来的一串与运算和异或运算，称之为“扰动函数”，</li><li>                扰动的核心思想在于使计算出来的值在保留原有相关特性的基础上，</li><li>                增加其值的不确定性，从而降低冲突的概率。</li><li>                不同的版本实现的方式不一样，但其根本思想是一致的。</li><li>                往右移动的目的，就是为了将h的高位利用起来，减少哈西冲突</li><li>                */</li><li>        h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);</li><li>        <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);</li><li>    }</li><li>        <span class="hljs-comment">//【15】返回int类型数组的坐标</span></li><li>        <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> indexFor(<span class="hljs-built_in">int</span> h, <span class="hljs-built_in">int</span> length) {</li><li>                <span class="hljs-comment">//其实这个算法就是取模运算：h%length，取模效率不如位运算</span></li><li>        <span class="hljs-keyword">return</span> h &amp; (length<span class="hljs-number">-1</span>);</li><li>    }</li><li>        <span class="hljs-comment">//【18】调用addEntry</span></li><li>        <span class="hljs-keyword">void</span> addEntry(<span class="hljs-built_in">int</span> hash, K <span class="hljs-built_in">key</span>, V value, <span class="hljs-built_in">int</span> bucketIndex) {</li><li>                <span class="hljs-comment">//【25】size的大小  大于 16*0.75=12的时候，比如你放入的是第13个，这第13个你打算放在没有元素的位置上的时候</span></li><li>        <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">size</span> &gt;= threshold) &amp;&amp; (<span class="hljs-keyword">null</span> != table[bucketIndex])) {</li><li>                        <span class="hljs-comment">//【26】主数组扩容为2倍</span></li><li>            resize(<span class="hljs-number">2</span> * table.length);</li><li>                        <span class="hljs-comment">//【30】重新调整当前元素的hash码</span></li><li>            hash = (<span class="hljs-keyword">null</span> != <span class="hljs-built_in">key</span>) ? hash(<span class="hljs-built_in">key</span>) : <span class="hljs-number">0</span>;</li><li>                        <span class="hljs-comment">//【31】重新计算元素位置</span></li><li>            bucketIndex = indexFor(hash, table.length);</li><li>        }</li><li>                <span class="hljs-comment">//【19】将hash,key,value,bucketIndex位置  封装为一个Entry对象：</span></li><li>        createEntry(hash, <span class="hljs-built_in">key</span>, value, bucketIndex);</li><li>    }</li><li>        <span class="hljs-comment">//【20】</span></li><li>        <span class="hljs-keyword">void</span> createEntry(<span class="hljs-built_in">int</span> hash, K <span class="hljs-built_in">key</span>, V value, <span class="hljs-built_in">int</span> bucketIndex) {</li><li>                <span class="hljs-comment">//【21】获取bucketIndex位置上的元素给e</span></li><li>        Entry&lt;K,V&gt; e = table[bucketIndex];</li><li>                <span class="hljs-comment">//【22】然后将hash, key, value封装为一个对象，然后将下一个元素的指向为e （链表的头插法）</span></li><li>                <span class="hljs-comment">//【23】将新的Entry放在table[bucketIndex]的位置上</span></li><li>        table[bucketIndex] = <span class="hljs-keyword">new</span> Entry&lt;&gt;(hash, <span class="hljs-built_in">key</span>, value, e);</li><li>                <span class="hljs-comment">//【24】集合中加入一个元素 size+1</span></li><li>        <span class="hljs-built_in">size</span>++;</li><li>    }</li><li>    <span class="hljs-comment">//【27】</span></li><li>        <span class="hljs-keyword">void</span> resize(<span class="hljs-built_in">int</span> newCapacity) {</li><li>        Entry[] oldTable = table;</li><li>        <span class="hljs-built_in">int</span> oldCapacity = oldTable.length;</li><li>        <span class="hljs-keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) {</li><li>            threshold = Integer.MAX_VALUE;</li><li>            <span class="hljs-keyword">return</span>;</li><li>        }</li><li>                <span class="hljs-comment">//【28】创建长度为newCapacity的数组</span></li><li>        Entry[] newTable = <span class="hljs-keyword">new</span> Entry[newCapacity];</li><li>        <span class="hljs-built_in">boolean</span> oldAltHashing = useAltHashing;</li><li>        useAltHashing |= sun.misc.VM.isBooted() &amp;&amp;</li><li>                (newCapacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</li><li>        <span class="hljs-built_in">boolean</span> rehash = oldAltHashing ^ useAltHashing;</li><li>                <span class="hljs-comment">//【28.5】转让方法：将老数组中的东西都重新放入新数组中</span></li><li>        transfer(newTable, rehash);</li><li>                <span class="hljs-comment">//【29】老数组替换为新数组</span></li><li>        table = newTable;</li><li>                <span class="hljs-comment">//【29.5】重新计算</span></li><li>        threshold = (<span class="hljs-built_in">int</span>)Math.<span class="hljs-built_in">min</span>(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="hljs-number">1</span>);</li><li>    }</li><li>        <span class="hljs-comment">//【28.6】</span></li><li>        <span class="hljs-keyword">void</span> transfer(Entry[] newTable, <span class="hljs-built_in">boolean</span> rehash) {</li><li>        <span class="hljs-built_in">int</span> newCapacity = newTable.length;</li><li>        <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e : table) {</li><li>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">null</span> != e) {</li><li>                Entry&lt;K,V&gt; next = e.next;</li><li>                <span class="hljs-keyword">if</span> (rehash) {</li><li>                    e.hash = <span class="hljs-keyword">null</span> == e.<span class="hljs-built_in">key</span> ? <span class="hljs-number">0</span> : hash(e.<span class="hljs-built_in">key</span>);</li><li>                }</li><li>                                <span class="hljs-comment">//【28.7】将哈希值，和新的数组容量传进去，重新计算key在新数组中的位置</span></li><li>                <span class="hljs-built_in">int</span> i = indexFor(e.hash, newCapacity);</li><li>                                <span class="hljs-comment">//【28.8】头插法</span></li><li>                e.next = newTable[i];<span class="hljs-comment">//获取链表上元素给e.next</span></li><li>                newTable[i] = e;<span class="hljs-comment">//然后将e放在i位置 </span></li><li>                e = next;<span class="hljs-comment">//e再指向下一个节点继续遍历</span></li><li>            }</li><li>        }</li><li>    }</li><li></li><li></li><li></li><li></li><li></li><li></li><li>}</li></ol></code></pre>
						<div><br />
						</div>
					</div>
				</div>
			</div>
		</div>
	
<script type="text/javascript" language="javascript" src="jquery.js"></script>
<script type="text/javascript" language="javascript" src="itemlink.js"></script><footer style="font-size: small; font-style: italic; text-align: right; margin-top: 16em; padding-top: 4px; border-top: 2px solid gray;">Generated with <a href="http://www.wjjsoft.com/mybase.html?ref=htmltree_export" target=_blank>Mybase Desktop 8.2.12</a></footer></body>
</html>